<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>直播 | 文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.9de76d75.js" as="script"><link rel="preload" href="/assets/js/2.98ea7a63.js" as="script"><link rel="preload" href="/assets/js/68.c6d12518.js" as="script"><link rel="prefetch" href="/assets/js/10.fa8eed47.js"><link rel="prefetch" href="/assets/js/11.f98f25e0.js"><link rel="prefetch" href="/assets/js/12.1ab9b5a3.js"><link rel="prefetch" href="/assets/js/13.75251b00.js"><link rel="prefetch" href="/assets/js/14.b5068189.js"><link rel="prefetch" href="/assets/js/15.33abd7e1.js"><link rel="prefetch" href="/assets/js/16.34ed8053.js"><link rel="prefetch" href="/assets/js/17.b3d52ea3.js"><link rel="prefetch" href="/assets/js/18.cbe71205.js"><link rel="prefetch" href="/assets/js/19.c632cb86.js"><link rel="prefetch" href="/assets/js/20.90d9a221.js"><link rel="prefetch" href="/assets/js/21.15cb7700.js"><link rel="prefetch" href="/assets/js/22.62ea968a.js"><link rel="prefetch" href="/assets/js/23.b743fdd5.js"><link rel="prefetch" href="/assets/js/24.5d157647.js"><link rel="prefetch" href="/assets/js/25.1935fba3.js"><link rel="prefetch" href="/assets/js/26.fd22f8ee.js"><link rel="prefetch" href="/assets/js/27.f47adfe7.js"><link rel="prefetch" href="/assets/js/28.d9f5719d.js"><link rel="prefetch" href="/assets/js/29.82cbf665.js"><link rel="prefetch" href="/assets/js/3.b96f613e.js"><link rel="prefetch" href="/assets/js/30.9f901f01.js"><link rel="prefetch" href="/assets/js/31.d9e2f61c.js"><link rel="prefetch" href="/assets/js/32.b14052e9.js"><link rel="prefetch" href="/assets/js/33.1b2e5efd.js"><link rel="prefetch" href="/assets/js/34.4bf7f44f.js"><link rel="prefetch" href="/assets/js/35.98d5fd2b.js"><link rel="prefetch" href="/assets/js/36.cdaf1c2f.js"><link rel="prefetch" href="/assets/js/37.a67bdb9a.js"><link rel="prefetch" href="/assets/js/38.5d856b83.js"><link rel="prefetch" href="/assets/js/39.27169c95.js"><link rel="prefetch" href="/assets/js/4.268c621c.js"><link rel="prefetch" href="/assets/js/40.8763c647.js"><link rel="prefetch" href="/assets/js/41.cd839f43.js"><link rel="prefetch" href="/assets/js/42.a97bf97a.js"><link rel="prefetch" href="/assets/js/43.fd126bb1.js"><link rel="prefetch" href="/assets/js/44.50e2b10d.js"><link rel="prefetch" href="/assets/js/45.0c29263b.js"><link rel="prefetch" href="/assets/js/46.fdee27aa.js"><link rel="prefetch" href="/assets/js/47.c7c7e966.js"><link rel="prefetch" href="/assets/js/48.80bc6f0a.js"><link rel="prefetch" href="/assets/js/49.d457b0ac.js"><link rel="prefetch" href="/assets/js/5.f577ebb9.js"><link rel="prefetch" href="/assets/js/50.cea3b0e6.js"><link rel="prefetch" href="/assets/js/51.eaab3e31.js"><link rel="prefetch" href="/assets/js/52.010a2dfb.js"><link rel="prefetch" href="/assets/js/53.3622f7b6.js"><link rel="prefetch" href="/assets/js/54.817aba2b.js"><link rel="prefetch" href="/assets/js/55.c3984ff9.js"><link rel="prefetch" href="/assets/js/56.6f20785e.js"><link rel="prefetch" href="/assets/js/57.07c7f6fc.js"><link rel="prefetch" href="/assets/js/58.4ec50d24.js"><link rel="prefetch" href="/assets/js/59.626b42b0.js"><link rel="prefetch" href="/assets/js/6.b9249342.js"><link rel="prefetch" href="/assets/js/60.ba2af5c7.js"><link rel="prefetch" href="/assets/js/61.6e22c298.js"><link rel="prefetch" href="/assets/js/62.df85ea27.js"><link rel="prefetch" href="/assets/js/63.cd3c1f6a.js"><link rel="prefetch" href="/assets/js/64.d0f75a86.js"><link rel="prefetch" href="/assets/js/65.12e0c392.js"><link rel="prefetch" href="/assets/js/66.aac422ac.js"><link rel="prefetch" href="/assets/js/67.3ff890c6.js"><link rel="prefetch" href="/assets/js/69.455e0c09.js"><link rel="prefetch" href="/assets/js/7.375eddd0.js"><link rel="prefetch" href="/assets/js/70.73d975e7.js"><link rel="prefetch" href="/assets/js/71.66528e07.js"><link rel="prefetch" href="/assets/js/72.a608a326.js"><link rel="prefetch" href="/assets/js/73.b8ed0811.js"><link rel="prefetch" href="/assets/js/74.68f4db5d.js"><link rel="prefetch" href="/assets/js/75.85059bdc.js"><link rel="prefetch" href="/assets/js/8.a04b9d9b.js"><link rel="prefetch" href="/assets/js/9.04a00c43.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>iOS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>iOS笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iOS笔记/工具.html" class="sidebar-link">工具</a></li><li><a href="/iOS笔记/计算机网络.html" class="sidebar-link">计算机网络</a></li><li><a href="/iOS笔记/架构.html" class="sidebar-link">架构</a></li><li><a href="/iOS笔记/视频播放器设计（基于FFmpeg）.html" class="sidebar-link">视频播放器设计（基于FFmpeg）</a></li><li><a href="/iOS笔记/视频常识.html" class="sidebar-link">视频常识</a></li><li><a href="/iOS笔记/数据结构与算法分析.html" class="sidebar-link">数据结构与算法分析</a></li><li><a href="/iOS笔记/算法.html" class="sidebar-link">算法</a></li><li><a href="/iOS笔记/音频常识.html" class="sidebar-link">音频常识</a></li><li><a href="/iOS笔记/音视频开发.html" class="sidebar-link">音视频开发</a></li><li><a href="/iOS笔记/直播.html" class="active sidebar-link">直播</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS笔记/直播.html#弹幕" class="sidebar-link">弹幕</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/直播.html#视频相关理论" class="sidebar-link">视频相关理论</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/直播.html#足迹效果" class="sidebar-link">足迹效果</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/直播.html#视频播放原理-2" class="sidebar-link">视频播放原理</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/直播.html#视频采集输出数据格式" class="sidebar-link">视频采集输出数据格式</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/直播.html#为什么要进行视频编码" class="sidebar-link">为什么要进行视频编码？</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/直播.html#h264硬编码" class="sidebar-link">H264硬编码</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/直播.html#yuv" class="sidebar-link">YUV</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/直播.html#色彩组成" class="sidebar-link">色彩组成</a></li></ul></li><li><a href="/iOS笔记/App启动优化.html" class="sidebar-link">App启动优化</a></li><li><a href="/iOS笔记/Audio.html" class="sidebar-link">Audio</a></li><li><a href="/iOS笔记/AudioToolbox.html" class="sidebar-link">AudioToolbox</a></li><li><a href="/iOS笔记/AVFoundation.html" class="sidebar-link">AVFoundation</a></li><li><a href="/iOS笔记/C.html#.html" class="sidebar-link">C</a></li><li><a href="/iOS笔记/C.html#.html" class="sidebar-link">C#</a></li><li><a href="/iOS笔记/C++.html" class="sidebar-link">C++</a></li><li><a href="/iOS笔记/CoreAudio.html" class="sidebar-link">CoreAudio</a></li><li><a href="/iOS笔记/CoreVideo.html" class="sidebar-link">CoreVideo</a></li><li><a href="/iOS笔记/FFmpeg.html" class="sidebar-link">FFmpeg</a></li><li><a href="/iOS笔记/Flutter.html" class="sidebar-link">Flutter</a></li><li><a href="/iOS笔记/GPUImage.html" class="sidebar-link">GPUImage</a></li><li><a href="/iOS笔记/ijkPlayer.html" class="sidebar-link">ijkPlayer</a></li><li><a href="/iOS笔记/iOS细节.html" class="sidebar-link">iOS细节</a></li><li><a href="/iOS笔记/iOS性能优化.html" class="sidebar-link">iOS性能优化</a></li><li><a href="/iOS笔记/LFLiveKit.html" class="sidebar-link">LFLiveKit</a></li><li><a href="/iOS笔记/Metal.html" class="sidebar-link">Metal</a></li><li><a href="/iOS笔记/Objective-C.html" class="sidebar-link">Objective-C</a></li><li><a href="/iOS笔记/OpenGL相关概念.html" class="sidebar-link">OpenGL相关概念</a></li><li><a href="/iOS笔记/pthread.html" class="sidebar-link">pthread</a></li><li><a href="/iOS笔记/ReactNative.html" class="sidebar-link">React Native</a></li><li><a href="/iOS笔记/RunLoop.html" class="sidebar-link">RunLoop</a></li><li><a href="/iOS笔记/UI视图.html" class="sidebar-link">UI视图</a></li><li><a href="/iOS笔记/VideoToolbox.html" class="sidebar-link">VideoToolbox</a></li><li><a href="/iOS笔记/WebAssembly.html" class="sidebar-link">WebAssembly</a></li><li><a href="/iOS笔记/WebRTC.html" class="sidebar-link">WebRTC</a></li><li><a href="/iOS笔记/第三方.html" class="sidebar-link">第三方</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="直播"><a href="#直播" class="header-anchor">#</a> 直播</h1> <h2 id="弹幕"><a href="#弹幕" class="header-anchor">#</a> 弹幕</h2> <h3 id="barragerenderer"><a href="#barragerenderer" class="header-anchor">#</a> BarrageRenderer</h3> <ul><li><p>BarrageSprite</p> <ul><li><p>BarrageFloatSprite</p> <ul><li>BarrageFloatImageSprite</li> <li>BarrageFloatTextSprite</li></ul></li> <li><p>BarrageWalkSprite</p> <ul><li>BarrageWalkImageSprite</li> <li>BarrageWalkTextSprite</li></ul></li></ul></li></ul> <h3 id="性能瓶颈"><a href="#性能瓶颈" class="header-anchor">#</a> 性能瓶颈</h3> <ul><li><p>弹幕阴影</p> <ul><li>用NSStrokeColorAttributeName替代阴影</li></ul></li> <li><p>弹幕量大</p> <ul><li>可以采用异步绘制将弹幕合成一张图片提交给layer</li></ul></li></ul> <h2 id="视频相关理论"><a href="#视频相关理论" class="header-anchor">#</a> 视频相关理论</h2> <h3 id="视频"><a href="#视频" class="header-anchor">#</a> 视频</h3> <p>根据人眼视觉暂留原理，每秒超过 24 帧的图像变化看上去是平滑连续的，这样的连续画面叫视频。</p> <h3 id="分辨率"><a href="#分辨率" class="header-anchor">#</a> 分辨率</h3> <p>分辨率是以横向和纵向的像素数量来衡量的，表示平面像素的精细程度。视频精细程度并不只取决于视频分辨率，还取决于屏幕分辨率。
1080P的P指Progressive scan（逐行扫描），即垂直方向像素点，也就是“高”，所以1920X1080叫1080P，不叫1920P。分辨率影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小。</p> <ul><li><p>上采样</p> <p>当720P的视频在1080P屏幕上播放时，需要将图像放大，放大操作也叫上采样。上采样几乎都是采用内插值方法，即在原有图像的像素点之间采用合适的插值算法插入新的元素，所以图像放大也称为图像插值。</p> <p>邻插值算法、双线性插值法、双三次插值法，除此之外还有很多更复杂效果更有的算法，比如小波插值、分形等等。</p></li> <li><p>下采样</p> <p>当1080P的视频在720P屏幕上播放时，需要将图像缩小，缩小操作也叫下采样。</p> <p>下采样的定义为：对于一个样值序列，间隔几个样值取样一次，得到新序列。
对于一幅分辨率为 MN 的图像，对其进行 s 倍下采样，即得到 (M/s)(N/s) 分辨率的图像（s 应为 M、N 的公约数），就是把原始图像 s*s 窗口内的图像变成一个像素，这个像素点的值就是窗口内所有像素的均值。
最佳体验为屏幕与视频分辨率相同且全屏播放，视频分辨率过高的话屏幕没有能力去呈现，视频分辨率过低的话无法发挥屏幕的能力。</p></li></ul> <h3 id="码率"><a href="#码率" class="header-anchor">#</a> 码率</h3> <p>比特率即码率，在不同领域有不同的含义，在多媒体领域，指单位时间播放音频或视频的比特数，可以理解成吞吐量或带宽。
单位为 bps , 即 bits per second，每秒传输的数据量，常用单位有：kbps、mbps 等。</p> <p>计算公式：码率（kbps）= 文件大小（kb）/ 时长（s）</p> <p>通俗一点理解就是取样率，取样率越大，精度就越高，图像质量越好，但数据量也越大，所以要找到一个平衡点：用最低的比特率达到最少的失真。
在一个视频中，不同时段画面的复杂程度是不同的，比如高速变化的场景和几乎静止的场景，所需的数据量也是不同的，若都使用同一种比特率是不太合理的，所以引入了动态比特率。</p> <p>编码器每秒编出的数据大小，单位是kbps，比如800kbps代表编码器每秒产生800kb（或100KB）的数据。</p> <ul><li><p>动态比特率</p> <p>简称为 VBR，即 Variable Bit Rate，比特率可以随着图像复杂程度的不同而随之变化。
图像内容简单的片段采用较小的码率，图像内容复杂的片段采用较大的码率，这样既保证了播放质量，又兼顾了数据量的限制。
比如 RMVB 视频文件，其中的 VB 就是指 VBR，表示采用动态比特率编码方式，达到播放质量与体积兼得的效果。</p></li> <li><p>静态比特率</p> <p>简称为 CBR，即 Constant Bit Rate，比特率恒定。
图像内容复杂的片段质量不稳定，图像内容简单的片段质量较好。
上面列出的计算公式显然是针对 CBR ，除 VBR 和 CBR 外，还有 CVBR（Constrained VariableBit Rate） 、ABR (Average Bit Rate) 等等。</p></li></ul> <h3 id="采样率"><a href="#采样率" class="header-anchor">#</a> 采样率</h3> <p>每秒从连续信号中提取并组成离散信号的采样个数，单位为赫兹（Hz）。
对于取样率、采样率和抽样率，没必要纠结它们的区别，都是同义词。</p> <ul><li><p>音频中的采样率</p> <p>指把音频信号数字化后 1 个通道 1 秒钟采取多少个样本，如 44.1kHz 的采样率，就是指 1 个通道 1 秒钟有 44.1k 个数据。</p></li> <li><p>视频中的采样率</p> <p>视频一般不标识采样率属性。</p> <p>采样率本身就是一个可泛化的概念，对于视频来说，若非要用采样率来描述的话，那就要分为两个层面：帧频和场频。
从帧频层面来说，采样率就是指帧率，指 1 秒钟显示多少帧图像。
从场频层面来说，采样率就是指像素频率，指 1 秒钟显示多少个像素。
像素频率是显示器的一个指标，可以理解成显示器的最大带宽，可以起到限制分辨率和刷新率的作用，根据含义可得出一个公式：
像素频率 = 帧率 X 帧像素数量</p> <p>帧率 = 138.5 x 1024 x 1024 / 1920 / 1080 ≈ 70.04 ， 得出的 70Hz 为正常的帧率范围，也可以反向确定对像素频率的理解是正确的。</p></li></ul> <h3 id="帧率"><a href="#帧率" class="header-anchor">#</a> 帧率</h3> <p>用于测量显示帧数的量度。单位为 FPS（Frames per Second，每秒显示帧数）或赫兹（Hz）。
前面提到每秒超过 24 帧的图像变化看上去是平滑连续的，这是针对电影等视频而言，对游戏来说 24 帧是不流畅的。
为什么 24fps 的电影感觉流畅，而 24fps 的游戏就感觉很卡呢？
第一个原因：两者图像生成原理不同
电影的一帧在一段时间曝光，每一帧都包含一段时间的信息，而游戏的画面则是由显卡计算生成的，一帧只包含那一瞬间的信息。
前者为电影的一帧，后者为游戏的一帧，可以看到在电影中动作会出现拖影，给人以动感的效果，连贯而不卡。
第二个原因：电影的FPS是稳定的，而游戏则是不稳定的
电影若为 24fps，那就表示每隔 1/24 秒刷新一次画面，帧间隔是固定的。
游戏若为 60fps，表示大约每隔 1/60 秒刷新一次画面，帧间隔是不稳定的，即使 1 秒能显示 60 帧，那也可能是前半秒显示了 59 帧，后半秒显示了 1 帧。</p> <ul><li>影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。如果码率为变量，则帧率也会影响体积，帧率越高，每秒钟经过的画面越多，需要的码率也越高，体积也越大。帧率就是在1秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。</li></ul> <h3 id="视频编码"><a href="#视频编码" class="header-anchor">#</a> 视频编码</h3> <p>通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式。
视频数据在时域和空域层面都有极强的相关性，这也表示有大量的时域冗余信息和空域冗余信息，压缩技术就是去掉数据中的冗余信息。</p> <ul><li><p>去除时域冗余信息</p> <p>运动补偿：通过先前的局部图像来预测、补偿当前的局部图像，可有效减少帧序列冗余信息。
运动表示：不同区域的图像使用不同的运动矢量来描述运动信息，运动矢量通过熵编码进行压缩（熵编码在编码过程中不会丢失信息）。
运动估计：从视频序列中抽取运动信息。
通用的压缩标准使用基于块的运动估计和运动补偿。</p></li> <li><p>去除空域冗余信息</p> <p>变换编码：将空域信号变换到另一正交矢量空间，使其相关性下降，数据冗余度减小。
量化编码：对变换编码产生的变换系数进行量化，控制编码器的输出位率。
熵编码： 对变换、量化后得到的系数和运动信息，进行进一步的无损压缩。
视频压缩编码技术可分为两大类：无损压缩和有损压缩。</p> <ul><li><p>无损压缩</p> <p>无损压缩也称为可逆编码，重构后的数据与原数据完全相同，适用于磁盘文件的压缩等。
主要采用熵编码方式，包括香农编码、哈夫曼编码和算术编码等。
&lt;1&gt;香农编码
香农编码采用信源符号的累计概率分布函数来分配码字，效率不高，实用性不大，但对其他编码方法有很好的理论指导意义。
&lt;2&gt;哈夫曼编码
哈夫曼编码完全依据出现概率来构造异字头的平均长度最短的码字。
基本方法为：先对图像数据扫描一遍，计算出各种像素出现的概率，按概率的大小指定不同长度的唯一码字，由此得到一张该图像的霍夫曼码表。
编码后的图像数据记录的是每个像素的码字，而码字与实际像素值的对应关系记录在码表中。
&lt;3&gt;算术编码
算术编码是用符号的概率和编码间隔两个基本参数来描述的，在给定符号集和符号概率的情况下，算术编码可以给出接近最优的编码结果。
使用算术编码的压缩算法通常先要对输入符号的概率进行估计，然后再编码，估计越准，编码结果就越接近最优的结果。</p></li> <li><p>有损压缩</p> <p>有损压缩也称为不可逆编码，重构后的数据与原数据有差异，适用于任何允许有失真的场景，例如视频会议、可视电话、视频广播、视频监控等。
编码方式包括预测编码、变换编码、量化编码、混合编码等。</p></li></ul></li></ul> <h3 id="编码标准"><a href="#编码标准" class="header-anchor">#</a> 编码标准</h3> <p>定义：为保证编码的正确性，编码要规范化、标准化，所以就有了编码标准。
研制视频编码标准的有两大正式组织：ISO/IEC（国际标准化组织）、ITU-T（国际电信联盟通信标准部）。
ISO/IEC 制定的编码标准有：MPEG-1、MPEG-2、MPEG-4、MPEG-7、MPEG-21 和 MPEG-H 等。
ITU-T 制定的编码标准有：H.261、H.262、H.263、H.264 和 H.265 等。
MPEG-x 和 H.26x 标准的视频编码都是采用有损压缩的混合编码方式，主要区别在于处理图像的分辨率、预测精度、搜索范围、量化步长等参数的不同，所以其应用场合也不同。</p> <ul><li><p>MPEG-x系列</p> <p>（1）MPEG-1
MPEG-1 共 5 部分。
第 2 部分视频编码方案，规定了逐行扫描视频的编码方案。
第 3 部分音频编码方案，将音频流的压缩分为 3 层并依次增大压缩比，广为流传的 MP3（MPEG-1 Layer 3）就是按照此部分编码方案压缩之后的文件格式。
（2）MPEG-2
MPEG-2 共 11 个部分，在 MPEG-1 的基础上提高了码率和质量。
第 2 部分视频编码方案，规定了隔行扫描视频的编码方案，是和 ITU-T 共同开发的，ITU-T 称其为 H.262。
第 3 部分音频编码方案，延续了 MPEG-1 的 3 层压缩方案，压缩后文件格式仍未 MP3，但在压缩算法上有所改进。
第 7 部分首次提出 AAC（MPEG Advanced Audio Coding）编码，目的以更小的容量和更好的音质取代 MP3 格式。
（3）MPEG-4
MPEG-4 共 27 个部分，更加注重多媒体系统的交互性和灵活性。
第 3 部分音频编码方案，优化了 AAC 编码算法，并在推出后逐渐取代 MP3，比如和视频封装在一起的音频优先考虑 AAC 格式，但就民用而言大部分还是使用 MP3 格式。
第 10 部分提出 AVC（Advanced Video Coding）编码，是和 ITU-T 共同开发的，ITU-T 称其为 H.264。
第 14 部分提出了 MP4 格式封装，官方文件后缀名是 &quot;.mp4&quot;，还有其他的以 mp4 为基础进行的扩展或缩水版本的格式，包括：M4V,  3GP, F4V 等。
（4）MPEG-7
MPEG-7 不同于 MPEG-1、MPEG-2、MPEG-4，它不是音视频压缩标准。
MPEG-7 被称为 &quot;多媒体内容描述接口&quot;，目的就是产生一种描述多媒体信息的标准，并将该描述与所描述的内容相联系，以实现快速有效的检索。
（5）MPEG-12
MPEG-12 其实就是一些关键技术的集成，通过这种集成环境对全球数字媒体资源进行管理，实现内容描述、创建、发布、使用、识别、收费管理、版权保护等功能。
（6）MPEG-H
MPEG-H 包含了 1 个数字容器标准、1 个视频压缩标准、1 个音频压缩标准和 2 个一致性测试标准。
其中视频压缩标准为高效率视频编码（HEVC），和 ITU-T 联合开发，相比 H.264/MPEG-4 AVC 数据压缩率增加了 1 倍。</p></li> <li><p>H.26x 系列</p> <p>1）H.261
H.261 是第一个实用的数字视频编码标准，使用了混合编码框架，包括了基于运动补偿的帧间预测，基于离散余弦变换的空域变换编码，量化，zig-zag 扫描和熵编码。
H.261 的设计相当成功，之后的视频编码国际标准基本上都是基于 H.261 的设计框架，包括 MPEG-1，MPEG-2／H.262，H.263，甚至 H.264。
（2）H.262
H.262 由 MPEG-1 扩充而来，支持隔行扫描，在技术内容上和 MPEG-2 视频标准一致，DVD 就是采用了该技术。
（3）H.263
H.263 是一种用于视频会议的低码率视频编码标准，在 H.261 基础上发展而来。
与 H.261 相比采用了半象素的运动补偿，并增加了 4 种有效的压缩编码模式，在低码率下能够提供比 H.261 更好的图像效果。
H.263 于 1995 年推出第一版，后续在 1998 年和 2000 年还推出了第二版 H.263+、第三版 H.263++ 。
（4）H.264
（5）H.265</p> <ul><li><p>H.264</p> <p>H.264 又称为 MPEG-4 第 10 部分，即 MPEG-4 AVC，它是一种面向块，基于运动补偿的视频编码标准。
于 2003 年正式发布，现在已经成为高精度视频录制、压缩和发布的最常用格式之一。
H.264 可以在低码率情况下提供高质量的视频图像，相比 H.263 可节省 50% 的码率。
相比 H.263，H.264 不需设置较多的编码选项，降低了编码的复杂度。
H.264 可以根据不同的环境使用不同的传输和播放速率，并且提供了丰富的错误处理工具，可以很好的控制或消除丢包和误码。
H.264 性能的改进是以增加复杂性为代价而获得的，H.264 编码的计算复杂度大约相当于 H.263 的 3 倍，解码复杂度大约相当于 H.263 的 2 倍。
H.264 协议中定义了三种帧，分别为 I 帧、P 帧以及 B 帧。</p> <ul><li><p>帧种类</p> <ul><li><p>IDR帧</p> <p>把第一个首个I帧叫IDR。当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。</p></li> <li><p>I帧</p> <p>I帧即帧内编码帧、关键帧，可以理解为一帧画面的完整保留，解码时只需要本帧数据就可以完成，不需要参考其他画面，数据量比较大。  保存完整画面。数据量比较大。解码只需要本帧就可以。</p> <ul><li><p>一帧图像</p> <p>一帧图像划分成一个或多个片</p> <ul><li><p>片</p> <p>每片包含整数个宏块，最多包含整个图像的宏块，片的目的是为了限制五码的扩算和传输，使编码片相互间保持独立。</p> <ul><li><p>I宏块</p> <p>多个块组成一个宏块，通常是16个块组成一个宏块</p> <ul><li><p>16块</p> <ul><li>块(4x4像素)</li> <li>块(4x4像素)</li> <li>块(4x4像素)</li> <li>...</li></ul></li> <li><p>16块</p></li> <li><p>16块</p></li> <li><p>...</p></li></ul></li> <li><p>B宏块</p> <p>多个块组成一个宏块，通常是16个块组成一个宏块</p> <ul><li><p>16块</p> <ul><li>块(4x4像素)</li> <li>块(4x4像素)</li> <li>块(4x4像素)</li> <li>...</li></ul></li> <li><p>16块</p></li> <li><p>16块</p></li> <li><p>...</p></li></ul></li> <li><p>P宏块</p> <p>多个块组成一个宏块，通常是16个块组成一个宏块</p> <ul><li><p>16块</p> <ul><li>块(4x4像素)</li> <li>块(4x4像素)</li> <li>块(4x4像素)</li> <li>...</li></ul></li> <li><p>16块</p></li> <li><p>16块</p></li> <li><p>...</p></li></ul></li></ul></li> <li><p>...</p></li></ul></li></ul></li> <li><p>P帧</p> <p>P帧即前向预测编码帧，记录当前帧跟上一关键帧（或P帧）的差别，解码时依赖之前缓存的画面，叠加上本帧定义的差别，才能生成最终画面，数据量较 I 帧小很多。</p></li> <li><p>B帧</p> <p>B帧即双向预测编码帧，记录当前帧跟前后帧的差别，解码时依赖前面的I帧（或P帧）和后面的P帧，数据量比I帧和P帧小很多。
数据压缩比大约为：  I帧：P帧：B帧  =  7：20：50，可见 P 帧和 B 帧极大的节省了数据量，节省出来的空间可以用来多保存一些 I 帧，以实现在相同码率下，提供更好的画质。</p></li></ul></li> <li><p>片</p> <ul><li><p>I片</p> <ul><li>只包含I宏块</li></ul></li> <li><p>P片</p> <ul><li>包含P和I宏块</li></ul></li> <li><p>B片</p> <ul><li>包含B和I宏块</li></ul></li> <li><p>SP片</p> <ul><li>用于不同编码流之间的切换</li></ul></li> <li><p>SI片</p> <ul><li>特殊类型的编码宏块</li></ul></li></ul></li> <li><p>组成部分NALU(Nal Unit)</p> <ul><li><p>开始码</p> <ul><li>必须是&quot;00 00 00 01&quot; 或&quot;00 00 01&quot;</li></ul></li> <li><p>NAL类型</p> <ul><li><p>1</p> <ul><li>非IDR图像中不采用数据划分的片段，表示这是一个P帧或B帧，个人理解这句话的意思是，它不能用于数据划分，所以它不是一个I帧</li></ul></li> <li><p>5</p> <ul><li>IDR图像的片段，表示这是一个I帧，I帧前面必须有SPS和PPS数据，个人理解是因为它能用来前后数据划分，所以是一个I帧</li></ul></li> <li><p>7</p> <ul><li><p>序列参数集(SPS)</p> <p>SPS包含的是针对一连续编码视频序列的参数，如seq_parameter_set_id、帧数及POC的约束、参数帧数目、解码图像尺寸和帧场编码模式选择标识等。</p></li></ul></li> <li><p>8</p> <ul><li><p>图像参数集（PPS）</p> <p>PPS对应的是一个序列中某一副图像或者某几幅图像，参数如标识符pic_parameter_set_id、可选的seq_parameter_set_id、熵编码模式选择标识、片组数组、初始量化参数和去方块铝箔系数调整标识等。</p></li></ul></li></ul></li> <li><p>视频数据</p></li></ul></li></ul></li> <li><p>H.265</p> <p>H.265 即高效视频编码（High Efficiency Video Coding ，简称 HEVC），于 2013 年正式推出。
H.265 编码架构和 H.264 相似，主要也包含，帧内预测、帧间预测、转换、量化、去区块滤波器、熵编码等模块。
H.265 编码架构整体被分为编码单位、预测单位和转换单位。
H.265 在 H.264 的基础之上，使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。
在码率减少 51-74% 的情况下，H.265 编码视频的质量还能与 H.264 编码视频近似甚至更好。
H.265 可以在有限带宽下传输更高质量的网络视频，智能手机、平板机等移动设备将能直接在线播放 1080p 的全高清视频，让网络视频跟上了显示屏 “高分辨率化” 的脚步。</p></li></ul></li></ul> <h3 id="视频封装格式"><a href="#视频封装格式" class="header-anchor">#</a> 视频封装格式</h3> <p>视频封装格式如 mp4、mkv，用来存储或传输编码数据，可以理解成一个容器。
封装就是按照一定规则把音视频、字幕等数据组织起来，包含编码类型等公共信息，播放器可以按照这些信息来匹配解码器、同步音视频。
不同的封装格式支持的视音频编码格式是不一样的，比如 MKV 格式支持比较多，RMVB 则主要支持 Real 公司的视音频编码格式。</p> <h3 id="视频解码"><a href="#视频解码" class="header-anchor">#</a> 视频解码</h3> <p>定义：将视频压缩编码过的数据，解压缩成为视频原始数据，即视频编码的反过程。</p> <p>对于一个播放器来说，很重要的一个指标就是能支持多少种视频解码。</p> <h3 id="视频播放原理"><a href="#视频播放原理" class="header-anchor">#</a> 视频播放原理</h3> <ul><li><p>解封装</p> <p>就是将输入的封装格式的数据，分离成为音频压缩编码数据和视频压缩编码数据。例如，FLV 格式的数据，经过解封装操作后，输出 H.264 编码的视频码流和 AAC 编码的音频码流。</p></li> <li><p>解码</p> <p>将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含 AAC，MP3，AC-3 等等，视频的压缩编码标准则包含 H.264，MPEG2，VC-1 等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如 YUV420P，RGB 等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如 PCM 数据。</p></li> <li><p>视音频同步</p> <p>根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。</p></li></ul> <h3 id="视频与流媒体"><a href="#视频与流媒体" class="header-anchor">#</a> 视频与流媒体</h3> <p>上面播放原理中分析的是本地视频文件，如果播放的是互联网上的视频，步骤则为：解协议，解封装，解码音视频，音视频同步，多了一个解协议的步骤。</p> <ul><li><p>解协议</p> <p>解协议：将流媒体协议的数据，解析为标准的相应的封装格式数据。</p> <p>视音频在网络上传播的时候，常常采用各种流媒体协议，例如 HTTP，RTMP， MMS 等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。</p> <p>这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。</p> <p>解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用 RTMP 协议传输的数据，经过解协议操作后，输出 FLV 格式的数据。</p></li></ul> <h3 id="time-base"><a href="#time-base" class="header-anchor">#</a> time_base</h3> <p>如果把1秒分为25等份，你可以理解就是一把尺，那么每一格表示的就是1/25秒。此时的time_base={1，25}
如果你是把1秒分成90000份，每一个刻度就是1/90000秒，此时的time_base={1，90000}。所谓时间基表示的就是每个刻度是多少秒</p> <h3 id="pts"><a href="#pts" class="header-anchor">#</a> PTS</h3> <p>PTS：Presentation Time Stamp。PTS主要用于度量解码后的视频帧什么时候被显示出来</p> <ul><li><p>pts的值就是占多少个时间刻度（时间基）。它的单位不是秒，而是时间刻度。只有pts乘以time_base两者同时在一起，才能表达出时间是多少。</p> <ul><li>根据pts来计算一桢在整个视频中的时间位置：
timestamp(秒) = pts * av_q2d(st-&gt;time_base)</li></ul></li></ul> <h3 id="dts"><a href="#dts" class="header-anchor">#</a> DTS</h3> <p>DTS：Decode Time Stamp。DTS主要是标识读入内存中的ｂｉｔ流在什么时候开始送入解码器中进行解码</p> <h3 id="duration"><a href="#duration" class="header-anchor">#</a> duration</h3> <ul><li>计算帧的长度：
time(秒) = st-&gt;duration * av_q2d(st-&gt;time_base)</li></ul> <h3 id="视频帧和游戏帧的不同"><a href="#视频帧和游戏帧的不同" class="header-anchor">#</a> 视频帧和游戏帧的不同</h3> <ul><li>视频帧是连续的画面，最低要求24fps</li> <li>游戏帧是一个静止的画面，最低要求60fps</li></ul> <h3 id="采集视频制式选择"><a href="#采集视频制式选择" class="header-anchor">#</a> 采集视频制式选择</h3> <p>如果录制的视频不是在电视机上播放，而仅仅只是在电脑上播放，那么选择哪种制式都没有问题，一般根据帧率来决定，比如想要更高的帧率，则可以选择NTSC制式，如果想要在电视机上直接播放录制的视频，最好使用PAL制式</p> <ul><li><p>PAL</p> <ul><li>每秒25帧，适用于我国电视机，电压220V，50Hz</li></ul></li> <li><p>NTSC</p> <ul><li>每秒30帧，主要适用于北美国家的电视机，北美电压是110V，60Hz</li></ul></li></ul> <h3 id="常见媒体的fps帧率"><a href="#常见媒体的fps帧率" class="header-anchor">#</a> 常见媒体的FPS帧率</h3> <ul><li>电影：24fps</li> <li>电视（PAL）：25fps</li> <li>电视（NTSL）：30fps</li></ul> <h3 id="gop"><a href="#gop" class="header-anchor">#</a> GOP</h3> <p>表示多少秒一个I帧</p> <h3 id="avc"><a href="#avc" class="header-anchor">#</a> AVC</h3> <h3 id="大端和小端"><a href="#大端和小端" class="header-anchor">#</a> 大端和小端</h3> <p>iOS系统默认存储的是小端数据</p> <ul><li><p>小端</p> <ul><li>高字节在高地址, 低字节在低地址</li></ul></li> <li><p>大端</p> <ul><li>高字节在低地址, 低字节在高地址</li></ul></li></ul> <h2 id="足迹效果"><a href="#足迹效果" class="header-anchor">#</a> 足迹效果</h2> <h3 id="caemitterlayer"><a href="#caemitterlayer" class="header-anchor">#</a> CAEmitterLayer</h3> <ul><li><p>[CAEmitterLayer layer]</p></li> <li><p>emitterPosition</p> <ul><li>发射器在xy平面的中心位置</li></ul></li> <li><p>emitterSize</p> <ul><li>发射器的尺寸大小</li></ul></li> <li><p>renderMode</p> <ul><li><p>渲染模式</p> <ul><li><p>kCAEmitterLayerUnordered</p> <ul><li>粒子是无序出现的，多个发射源将混合</li></ul></li> <li><p>kCAEmitterLayerOldestFirst</p> <ul><li>声明久的粒子会被渲染在最上层</li></ul></li> <li><p>kCAEmitterLayerOldestLast</p> <ul><li>年轻的粒子会被渲染在最上层</li></ul></li> <li><p>kCAEmitterLayerBackToFront</p> <ul><li>粒子的渲染按照Z轴的前后顺序进行</li></ul></li> <li><p>kCAEmitterLayerAdditive</p> <ul><li>进行粒子混合</li></ul></li></ul></li></ul></li> <li><p>preservesDepth</p> <ul><li>开启三维效果</li></ul></li> <li><p>创建粒子</p> <ul><li><p>[CAEmitterCell emitterCell]</p> <ul><li><p>birthRate</p> <ul><li>粒子的创建速率，默认为1/s</li></ul></li> <li><p>lifetime</p> <ul><li>粒子存活时间</li></ul></li> <li><p>lifetimeRange</p> <ul><li>粒子的生存时间容差</li></ul></li> <li><p>contents</p> <ul><li>粒子显示的内容，传CGImage</li></ul></li> <li><p>color</p> <ul><li>颜色，传CGColor</li></ul></li> <li><p>name</p> <ul><li>粒子的名字</li></ul></li> <li><p>velocity</p> <ul><li>粒子的运行速度</li></ul></li> <li><p>velocityRange</p> <ul><li>粒子速度的容差</li></ul></li> <li><p>emissionLongitude</p> <ul><li>粒子在xy平面的发射角度</li></ul></li> <li><p>emissionRange</p> <ul><li>粒子发射角度的容差</li></ul></li> <li><p>scale</p> <ul><li>缩放比例</li></ul></li></ul></li></ul></li> <li><p>emitterCells</p> <ul><li>创建的粒子添加到该数组</li></ul></li></ul> <h2 id="视频播放原理-2"><a href="#视频播放原理-2" class="header-anchor">#</a> 视频播放原理</h2> <h3 id="封装格式数据mp4、flv"><a href="#封装格式数据mp4、flv" class="header-anchor">#</a> 封装格式数据mp4、flv...</h3> <ul><li><p>解封装</p> <ul><li><p>视频压缩数据H264、H265...</p> <ul><li><p>视频解码</p> <ul><li><p>视频像素数据YUV...</p> <ul><li><p>音视频同步</p> <ul><li>视频输出</li></ul></li></ul></li></ul></li></ul></li> <li><p>音频压缩数据AAC、MP3...</p> <ul><li><p>音频解码</p> <ul><li><p>音频采样数据PCM...</p> <ul><li><p>音视频同步</p> <ul><li>音频输出</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul> <h2 id="视频采集输出数据格式"><a href="#视频采集输出数据格式" class="header-anchor">#</a> 视频采集输出数据格式</h2> <h3 id="yuv优点"><a href="#yuv优点" class="header-anchor">#</a> YUV优点</h3> <p>YUV的原理是把亮度与色度分离，研究证明,人眼对亮度的敏感超过色度。利用这个原理，可以把色度信息减少一点，人眼也无法查觉这一点。YUV三个字母中，其中”Y”表示明亮度（Lumina nce或Luma），也就是灰阶值；而”U”和”V”表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色</p> <ul><li>彩色YUV图像转黑白YUV图像转换非常简单，这一特性用在与电视信号上</li> <li>YUV是数据总尺寸小于RGB格式</li></ul> <h3 id="rgb"><a href="#rgb" class="header-anchor">#</a> RGB</h3> <h2 id="为什么要进行视频编码"><a href="#为什么要进行视频编码" class="header-anchor">#</a> 为什么要进行视频编码？</h2> <p>首先我们假设一种场景， 采集一分钟数据，需要多大的空间来存储。
1、视频分辨率是 1280 * 720.
2、一秒钟之内至少需要16帧画面（正常开发通常会采集30帧），为了不让用户感受明显卡顿现象.
3、采用NV12 (YUV420)输出格式计算。（YUV420为4个Y共用一个U和V，Y分量为全采样，即1字节，U分量和V分量只有Y分量的四分之一，即U分量和V分量的大小均为1/4字节，也就是说一张1像素的YUV420图像大小为：(3/2)=1.5字节。）
计算结果： 1280 * 720 * 1.5 * 16 * 60 = 1296 M</p> <p>作者：lyking
链接：https://www.jianshu.com/p/15c12c3deb8f
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p> <h3 id="一秒钟采集的原生yuv420数据-在分辨率为1280x720时-大概为12807201-5-30帧-40mb-通过设置码率-对原生数据进行采样编码处理"><a href="#一秒钟采集的原生yuv420数据-在分辨率为1280x720时-大概为12807201-5-30帧-40mb-通过设置码率-对原生数据进行采样编码处理" class="header-anchor">#</a> 一秒钟采集的原生YUV420数据，在分辨率为1280x720时，大概为1280<em>720</em>1.5*30帧=40MB，通过设置码率，对原生数据进行采样编码处理</h3> <h2 id="h264硬编码"><a href="#h264硬编码" class="header-anchor">#</a> H264硬编码</h2> <p>https://www.jianshu.com/p/15c12c3deb8f。 H264采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成I帧的算法，帧间压缩是生成B帧和P帧的算法。H264原始麻溜是由一个接一个的NALU(Nal Unit)组成。NALU = 开始码+NAL类型+视频数据。开始码必须是&quot;00 00 00 01&quot;或&quot;00 00 01&quot;。  NAL类型：主要用到的有类型1、5、7、8。1表示非IDR图像中不采用数据划分得片段。5表示IDR图像的片段，。7表示序列参数集(SPS)。8表示图像参数集(PPS)。</p> <h3 id="通过vtcompressionsessioncreate创建编码器"><a href="#通过vtcompressionsessioncreate创建编码器" class="header-anchor">#</a> 通过VTCompressionSessionCreate创建编码器</h3> <p>allocator：内存分配器，填NULL为默认分配器
width、height：视频帧像素的宽高，如果编码器不支持这个宽高的话可能会改变
codecType：编码类型，枚举
encoderSpecification：指定特定的编码器，填NULL的话由VideoToolBox自动选择
sourceImageBufferAttributes：源像素缓冲区的属性，如果这个参数有值的话，VideoToolBox会创建一个缓冲池，不需要缓冲池可以设置为NULL
compressedDataAllocator：压缩后数据的内存分配器，填NULL使用默认分配器
outputCallback：视频编码后输出数据回调函数
outputCallbackRefCon：回调函数中的自定义指针，我们通常传self，在回调函数中就可以拿到当前类的方法和属性了
compressionSessionOut：编码器句柄，传入编码器的指针</p> <p>作者：lyking
链接：https://www.jianshu.com/p/15c12c3deb8f
来源：简书
简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p> <ul><li><p>通过VTSessionSetProperty设置编码器属性</p> <ul><li><p>设置完属性调用VTCompressionSessionPrepareToEncodeFrames准备编码</p> <ul><li><p>输入采集到的视频数据，调用VTCompressionSessionEncodeFrame进行编码</p> <ul><li><p>获取到编码后的数据并进行处理</p> <ul><li><p>调用VTCompressionSessionCompleteFrames停止编码器</p> <ul><li>调用VTCompressionSessionInvalidate销毁编码器</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul> <h2 id="yuv"><a href="#yuv" class="header-anchor">#</a> YUV</h2> <p>YUV，亦称YCrCb，分为三个分量，Y表示明亮度，也就是灰度值；而“U”和“V”表示的则是色度。作用是描述影像色彩及饱和度，用于指定像素的颜色。</p> <h3 id="planar"><a href="#planar" class="header-anchor">#</a> planar</h3> <p>平面格式，分为平面和双平面。先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。使用三个数组分开存放YUV三个分量，就像是一个三维平面一样。</p> <h3 id="packed"><a href="#packed" class="header-anchor">#</a> packed</h3> <p>每个像素点的Y、U、V是连续交错存储的。将YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个宏像素（macro-pixel）</p> <h3 id="种类"><a href="#种类" class="header-anchor">#</a> 种类</h3> <p>有一种表示法可用来描述 U 和 V 与 Y 的采样频率比例，这个表示法称为 A:B:C 表示法</p> <ul><li><p>YUV444</p> <ul><li>4:4:4，YUV三个信道抽样率相同，因此在生成的图像里，每个像素三个分量信息完整，经过8比特量化后，未经压缩占用3字节。</li></ul></li> <li><p>YUV422</p> <ul><li>当出现4个YUV数据(一个YUV代表一个像素点)时，每存放4个Y时，只存储2个U以及2个V</li></ul></li> <li><p>YUV420</p> <ul><li>每存放4个Y时，只存放2个U，不存放V，下一行再存放4个Y时，不存放U，只存放2个V，也就是隔行存储，占用空间跟YUV411一样</li></ul></li> <li><p>YUV411</p> <ul><li>4:1:1比较常用，意义为每个像素点保存一个8bit的亮度值也就是Y值。每2*2个像素点保存一个Cr和Cb的值。</li></ul></li> <li><p>YUV422P</p> <p>属于YUV422，它是一种Plane模式，即平面模式，先存所有的Y，再存所有的U，最后存所有的V</p></li> <li><p>YV12和YU12</p> <p>属于YUV420，只不过它是一种Plane模式，即平面模式，它不是YUV交替存储的，而是先存所有的Y，再存所有的U，最后存所有的V，在同一个平面内</p></li> <li><p>NV12、NV21</p> <p>双平面模式，即Y和UV分为两个Plane，但是UV为交错存储，而不是分为三个plane。</p></li></ul> <h2 id="色彩组成"><a href="#色彩组成" class="header-anchor">#</a> 色彩组成</h2> <h3 id="亮度y"><a href="#亮度y" class="header-anchor">#</a> 亮度Y</h3> <h3 id="色调-cr"><a href="#色调-cr" class="header-anchor">#</a> 色调(Cr)</h3> <p>大致意思是属于哪种颜色，反映了输入信号红色部分 与RGB信号亮度值之间的差异</p> <h3 id="饱和度-cb"><a href="#饱和度-cb" class="header-anchor">#</a> 饱和度(Cb)</h3> <p>大致意思是颜色深度，Cb反映的是蓝色部分与RGB信号亮度值之间的差异</p> <p><em>XMind - Trial Version</em></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/iOS笔记/音视频开发.html" class="prev">
        音视频开发
      </a></span> <span class="next"><a href="/iOS笔记/App启动优化.html">
        App启动优化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9de76d75.js" defer></script><script src="/assets/js/2.98ea7a63.js" defer></script><script src="/assets/js/68.c6d12518.js" defer></script>
  </body>
</html>
