<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构与算法分析 | 文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.9de76d75.js" as="script"><link rel="preload" href="/assets/js/2.98ea7a63.js" as="script"><link rel="preload" href="/assets/js/66.aac422ac.js" as="script"><link rel="prefetch" href="/assets/js/10.fa8eed47.js"><link rel="prefetch" href="/assets/js/11.f98f25e0.js"><link rel="prefetch" href="/assets/js/12.1ab9b5a3.js"><link rel="prefetch" href="/assets/js/13.75251b00.js"><link rel="prefetch" href="/assets/js/14.b5068189.js"><link rel="prefetch" href="/assets/js/15.33abd7e1.js"><link rel="prefetch" href="/assets/js/16.34ed8053.js"><link rel="prefetch" href="/assets/js/17.b3d52ea3.js"><link rel="prefetch" href="/assets/js/18.cbe71205.js"><link rel="prefetch" href="/assets/js/19.c632cb86.js"><link rel="prefetch" href="/assets/js/20.90d9a221.js"><link rel="prefetch" href="/assets/js/21.15cb7700.js"><link rel="prefetch" href="/assets/js/22.62ea968a.js"><link rel="prefetch" href="/assets/js/23.b743fdd5.js"><link rel="prefetch" href="/assets/js/24.5d157647.js"><link rel="prefetch" href="/assets/js/25.1935fba3.js"><link rel="prefetch" href="/assets/js/26.fd22f8ee.js"><link rel="prefetch" href="/assets/js/27.f47adfe7.js"><link rel="prefetch" href="/assets/js/28.d9f5719d.js"><link rel="prefetch" href="/assets/js/29.82cbf665.js"><link rel="prefetch" href="/assets/js/3.b96f613e.js"><link rel="prefetch" href="/assets/js/30.9f901f01.js"><link rel="prefetch" href="/assets/js/31.d9e2f61c.js"><link rel="prefetch" href="/assets/js/32.b14052e9.js"><link rel="prefetch" href="/assets/js/33.1b2e5efd.js"><link rel="prefetch" href="/assets/js/34.4bf7f44f.js"><link rel="prefetch" href="/assets/js/35.98d5fd2b.js"><link rel="prefetch" href="/assets/js/36.cdaf1c2f.js"><link rel="prefetch" href="/assets/js/37.a67bdb9a.js"><link rel="prefetch" href="/assets/js/38.5d856b83.js"><link rel="prefetch" href="/assets/js/39.27169c95.js"><link rel="prefetch" href="/assets/js/4.268c621c.js"><link rel="prefetch" href="/assets/js/40.8763c647.js"><link rel="prefetch" href="/assets/js/41.cd839f43.js"><link rel="prefetch" href="/assets/js/42.a97bf97a.js"><link rel="prefetch" href="/assets/js/43.fd126bb1.js"><link rel="prefetch" href="/assets/js/44.50e2b10d.js"><link rel="prefetch" href="/assets/js/45.0c29263b.js"><link rel="prefetch" href="/assets/js/46.fdee27aa.js"><link rel="prefetch" href="/assets/js/47.c7c7e966.js"><link rel="prefetch" href="/assets/js/48.80bc6f0a.js"><link rel="prefetch" href="/assets/js/49.d457b0ac.js"><link rel="prefetch" href="/assets/js/5.f577ebb9.js"><link rel="prefetch" href="/assets/js/50.cea3b0e6.js"><link rel="prefetch" href="/assets/js/51.eaab3e31.js"><link rel="prefetch" href="/assets/js/52.010a2dfb.js"><link rel="prefetch" href="/assets/js/53.3622f7b6.js"><link rel="prefetch" href="/assets/js/54.817aba2b.js"><link rel="prefetch" href="/assets/js/55.c3984ff9.js"><link rel="prefetch" href="/assets/js/56.6f20785e.js"><link rel="prefetch" href="/assets/js/57.07c7f6fc.js"><link rel="prefetch" href="/assets/js/58.4ec50d24.js"><link rel="prefetch" href="/assets/js/59.626b42b0.js"><link rel="prefetch" href="/assets/js/6.b9249342.js"><link rel="prefetch" href="/assets/js/60.ba2af5c7.js"><link rel="prefetch" href="/assets/js/61.6e22c298.js"><link rel="prefetch" href="/assets/js/62.df85ea27.js"><link rel="prefetch" href="/assets/js/63.cd3c1f6a.js"><link rel="prefetch" href="/assets/js/64.d0f75a86.js"><link rel="prefetch" href="/assets/js/65.12e0c392.js"><link rel="prefetch" href="/assets/js/67.3ff890c6.js"><link rel="prefetch" href="/assets/js/68.c6d12518.js"><link rel="prefetch" href="/assets/js/69.455e0c09.js"><link rel="prefetch" href="/assets/js/7.375eddd0.js"><link rel="prefetch" href="/assets/js/70.73d975e7.js"><link rel="prefetch" href="/assets/js/71.66528e07.js"><link rel="prefetch" href="/assets/js/72.a608a326.js"><link rel="prefetch" href="/assets/js/73.b8ed0811.js"><link rel="prefetch" href="/assets/js/74.68f4db5d.js"><link rel="prefetch" href="/assets/js/75.85059bdc.js"><link rel="prefetch" href="/assets/js/8.a04b9d9b.js"><link rel="prefetch" href="/assets/js/9.04a00c43.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>iOS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>iOS笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iOS笔记/工具.html" class="sidebar-link">工具</a></li><li><a href="/iOS笔记/计算机网络.html" class="sidebar-link">计算机网络</a></li><li><a href="/iOS笔记/架构.html" class="sidebar-link">架构</a></li><li><a href="/iOS笔记/视频播放器设计（基于FFmpeg）.html" class="sidebar-link">视频播放器设计（基于FFmpeg）</a></li><li><a href="/iOS笔记/视频常识.html" class="sidebar-link">视频常识</a></li><li><a href="/iOS笔记/数据结构与算法分析.html" class="active sidebar-link">数据结构与算法分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#抽象数据类型-adt" class="sidebar-link">抽象数据类型(ADT)</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#递归" class="sidebar-link">递归</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#数学定义" class="sidebar-link">数学定义</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#分治" class="sidebar-link">分治</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#对数时间" class="sidebar-link">对数时间</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#对分查找-折半查找" class="sidebar-link">对分查找(折半查找)</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#欧几里得算法-辗转相除法" class="sidebar-link">欧几里得算法(辗转相除法)</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#排序" class="sidebar-link">排序</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#树adt" class="sidebar-link">树ADT</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#散列表-哈希表-adt" class="sidebar-link">散列表(哈希表)ADT</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#排序-2" class="sidebar-link">排序</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#图论" class="sidebar-link">图论</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/数据结构与算法分析.html#算法设计" class="sidebar-link">算法设计</a></li></ul></li><li><a href="/iOS笔记/算法.html" class="sidebar-link">算法</a></li><li><a href="/iOS笔记/音频常识.html" class="sidebar-link">音频常识</a></li><li><a href="/iOS笔记/音视频开发.html" class="sidebar-link">音视频开发</a></li><li><a href="/iOS笔记/直播.html" class="sidebar-link">直播</a></li><li><a href="/iOS笔记/App启动优化.html" class="sidebar-link">App启动优化</a></li><li><a href="/iOS笔记/Audio.html" class="sidebar-link">Audio</a></li><li><a href="/iOS笔记/AudioToolbox.html" class="sidebar-link">AudioToolbox</a></li><li><a href="/iOS笔记/AVFoundation.html" class="sidebar-link">AVFoundation</a></li><li><a href="/iOS笔记/C.html#.html" class="sidebar-link">C</a></li><li><a href="/iOS笔记/C.html#.html" class="sidebar-link">C#</a></li><li><a href="/iOS笔记/C++.html" class="sidebar-link">C++</a></li><li><a href="/iOS笔记/CoreAudio.html" class="sidebar-link">CoreAudio</a></li><li><a href="/iOS笔记/CoreVideo.html" class="sidebar-link">CoreVideo</a></li><li><a href="/iOS笔记/FFmpeg.html" class="sidebar-link">FFmpeg</a></li><li><a href="/iOS笔记/Flutter.html" class="sidebar-link">Flutter</a></li><li><a href="/iOS笔记/GPUImage.html" class="sidebar-link">GPUImage</a></li><li><a href="/iOS笔记/ijkPlayer.html" class="sidebar-link">ijkPlayer</a></li><li><a href="/iOS笔记/iOS细节.html" class="sidebar-link">iOS细节</a></li><li><a href="/iOS笔记/iOS性能优化.html" class="sidebar-link">iOS性能优化</a></li><li><a href="/iOS笔记/LFLiveKit.html" class="sidebar-link">LFLiveKit</a></li><li><a href="/iOS笔记/Metal.html" class="sidebar-link">Metal</a></li><li><a href="/iOS笔记/Objective-C.html" class="sidebar-link">Objective-C</a></li><li><a href="/iOS笔记/OpenGL相关概念.html" class="sidebar-link">OpenGL相关概念</a></li><li><a href="/iOS笔记/pthread.html" class="sidebar-link">pthread</a></li><li><a href="/iOS笔记/ReactNative.html" class="sidebar-link">React Native</a></li><li><a href="/iOS笔记/RunLoop.html" class="sidebar-link">RunLoop</a></li><li><a href="/iOS笔记/UI视图.html" class="sidebar-link">UI视图</a></li><li><a href="/iOS笔记/VideoToolbox.html" class="sidebar-link">VideoToolbox</a></li><li><a href="/iOS笔记/WebAssembly.html" class="sidebar-link">WebAssembly</a></li><li><a href="/iOS笔记/WebRTC.html" class="sidebar-link">WebRTC</a></li><li><a href="/iOS笔记/第三方.html" class="sidebar-link">第三方</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数据结构与算法分析"><a href="#数据结构与算法分析" class="header-anchor">#</a> 数据结构与算法分析</h1> <h2 id="抽象数据类型-adt"><a href="#抽象数据类型-adt" class="header-anchor">#</a> 抽象数据类型(ADT)</h2> <p>是一些操作的集合，有点类似于泛型类，也是一些操作的几何</p> <h3 id="表adt"><a href="#表adt" class="header-anchor">#</a> 表ADT</h3> <p>A(i+1)后继A(i)，A(i-1)前驱A(i)</p> <ul><li><p>表的实现</p> <ul><li><p>1.数组</p> <ul><li><p>缺点</p> <ul><li>插入和删除的运行时间是O(N)，而且表的大小还必须事先已知</li></ul></li></ul></li> <li><p>2.链表</p> <ul><li><p>表头(哑节点)解决的问题</p> <ul><li>删除表的第一个元素时，不改变表的起始端，从而防止误操作使表丢失。</li></ul></li></ul></li> <li><p>3.双链表</p> <ul><li>简化了删除操作，因为你不再被迫使用一个指向前驱元的指针来访问一个关键字</li></ul></li> <li><p>4.循环链表</p></li></ul></li></ul> <h3 id="栈adt"><a href="#栈adt" class="header-anchor">#</a> 栈ADT</h3> <ul><li><p>栈的实现</p> <ul><li><p>链表</p> <ul><li>push和pop操作最大的开销是开辟内存和释放内存，如果需要提高效率，可以将push和pop的元素放入新栈当中</li></ul></li> <li><p>数组</p> <ul><li>缺点是需要提前知道栈的大小</li></ul></li></ul></li> <li><p>栈的应用</p> <ul><li><p>平衡括号</p></li> <li><p>后缀求值法</p> <p>对操作数进行入栈出栈操作</p> <ul><li><p>计算器的实现，例如：4.99<em>1.06+5.99+6.99</em>1.06 =</p> <ul><li><p>先得到后缀表达式4.99 1.06 * 5.99 + 6.99 1.06 * +</p> <ul><li>然后依次push数据入栈，在遇到运算符时该运算符就作用于从该栈弹出的两个数上，将所得结果推入栈中</li></ul></li></ul></li></ul></li> <li><p>将中缀表达式转换为后缀表达式</p> <p>对操作符进行入栈出栈操作</p> <ul><li><p>1.将数据依次写入输出</p></li> <li><p>2.将符号进行入栈出栈操作</p> <ul><li>1.当需要入栈的运算符号优先级比栈顶元素优先级高时进行入栈操作</li> <li>2.当需要入栈的符号优先级比栈顶元素优先级低或者相等时，弹出栈顶元素，写入输出，一直弹出，直到入栈元素比栈顶元素优先级高时，停止弹出，将需要入栈的符号压入栈中</li> <li>3.当遇到左括号时，压入栈中，对括号后面需要入栈的符号进行第2步操作，当遇到右括号时，将栈中左括号顶部的元素全部弹出到输出当中，注意：对括号只是弹出，不需要输出操作</li></ul></li></ul></li> <li><p>函数调用</p> <ul><li>函数的调用类似于入栈出栈，所以当调用例程太多时，可能会发生栈溢出，从而崩溃。典型的就比如递归调用没有退出条件、再比如递归打印上万条链表数据都可能发生栈溢出。</li></ul></li></ul></li></ul> <h3 id="队列adt"><a href="#队列adt" class="header-anchor">#</a> 队列ADT</h3> <ul><li><p>队列的实现</p> <ul><li>链表</li> <li>数组</li></ul></li></ul> <h3 id="优先队列-堆"><a href="#优先队列-堆" class="header-anchor">#</a> 优先队列(堆)</h3> <p>堆就是父节点的值比子节点的值小的二叉树，其中根节点的值最小。
二叉堆是一颗完全二叉树，是平衡的。
左式堆不一定是完全二叉堆，也不一定是平衡的。
左式堆的每个节点如果有右儿子那就必须有左儿子，当然这不是左式堆的定义，这只是左式堆的一个特性，因为左式堆跟NPL有关，左儿子的NPL&gt;=右儿子的NPL。</p> <ul><li><p>实现</p> <ul><li><p>简单实现</p> <ul><li><p>链表</p> <ul><li>在表头以O(1)进行insert，出队以O(N)进行删除最小元DeleteMin</li></ul></li> <li><p>二叉查找树</p> <ul><li>入队平均运行时间和出队平均运行时间均为O(logN)。使用二叉查找树实现优先队列可能有些过分，因为二叉查找树支持许多优先队列并不需要的操作(浪费)。</li></ul></li></ul></li> <li><p>二叉堆(完全二叉树)</p> <p>即完全二叉树，我们这里讨论根节点是最小元的情况。而且我们设置堆的序号0位置为一个很小的值。二叉堆是平衡的。二叉堆是一种特殊的左式堆，因为它满足左式堆的性质条件</p> <ul><li><p>性质</p> <ul><li><p>结构性</p> <ul><li>完全二叉树放入数组中(数组第一个元素存储头结点，我们把一个很小的值放在位置0处)，不难看出对于数组任意位置i的元素，其左儿子在位置2i上，右儿子在位置2i+1上。它的父亲节点则在位置i/2上。所以不需要指针遍历完全二叉树很方便</li></ul></li> <li><p>堆序性</p> <ul><li><p>是操作被快速执行的性质就是堆序性</p> <ul><li><p>最小堆</p> <ul><li>对于堆中每个节点X，X的父亲中的关键字小于或等于X中的关键字，在这里我们假设关键字是整数，实际可能关键字可能是任意复杂的</li></ul></li> <li><p>最大堆</p> <ul><li>对于堆中每个节点X，X的父亲中的关键字大于或等于X中的关键字，在这里我们假设关键字是整数，实际可能关键字可能是任意复杂的</li></ul></li></ul></li></ul></li></ul></li> <li><p>插入</p> <ul><li><p>上滤策略</p> <ul><li><p>我们总是在完全二叉树的最外层空穴位置插入新节点</p> <ul><li>1.如果插入后并不破坏堆序性，那么插入完成。</li> <li>2.否则，我们把该空穴的父节点下移，如果在父节点处插入后仍然不满足堆序性，那么我们继续把祖父节点下移，一直找到可以插入的合适位置为止</li></ul></li> <li><p>如果欲插入的元素是新的最小元，从而一直上滤到根处，那么这种插入的时间高达O(logN)</p></li></ul></li> <li><p>最坏时间复杂度</p> <ul><li>O(logN)</li></ul></li> <li><p>平均来看时间复杂度为常数</p></li></ul></li> <li><p>删除</p> <ul><li><p>下滤策略</p> <ul><li><p>我们总是删除堆中最小的元，删除不难，从根节点删除即可，删除之后我们要填充根节点这个空穴，显然删除完成后，需要将最后一片叶子填充到合适位置</p> <ul><li>1.我们比较左右儿子以及树的最后一片叶子，谁小用谁来填充空穴</li> <li>2.如果最后一片叶子填充到空穴当中了，那么循环结束</li> <li>3.如果左右儿子较小的值填充到了空穴，那么儿子的位置就产生了空穴。</li> <li>4.重复该过程，空穴的位置一直下移，直到我们找到可以填充最后一片叶子的位置为止</li></ul></li></ul></li> <li><p>时间复杂度</p> <ul><li>O(logN)</li></ul></li></ul></li> <li><p>降低关键字的值</p> <ul><li>通过上滤来调整堆，调整后，系统管理程序能够使它们的程序以最高的优先级来运行</li></ul></li> <li><p>增加关键字的值</p> <ul><li>通过下滤来调整堆，调整后，许多调度程序自动地降低正在过多地消耗CPU时间的进程的优先级。</li></ul></li> <li><p>构建堆</p> <p>N/2节点位置开始其实就是倒数第二层位置开始，因为叶子节点没有子节点，所以需要从倒数第二层开始遍历</p> <ul><li><p>过程</p> <ul><li>1.先将数据输入到二叉树当中</li> <li>2.然后从N/2开始节点遍历到1的位置，比较每个节点和它的孩子的大小</li> <li>3.如果该节点比孩子值大，那么就下滤该节点</li> <li>4.如果下滤过后发现该节点还是比孩子大，那么久再次下滤该节点</li> <li>5.然后继续遍历N/2-1,N/2-2,N/2-3......1</li></ul></li> <li><p>时间复杂度</p> <ul><li>1.最坏情况是除叶子节点外，每个节点都下滤到树叶位置，所以下滤的总次数为节点的高度之和</li> <li>2.不难证明一颗理想二叉树的高度和为：(2^(h+1)-1)-(h+1)</li> <li>3.一颗完全二叉树的节点数N在2^h到2^(h+1)之间</li> <li>4.所以下滤的总次数和N是线性关系</li> <li>5.所以构建堆的时间复杂度为O(N)</li></ul></li></ul></li></ul></li> <li><p>d-堆</p> <p>d个儿子的堆，也是平衡的</p> <ul><li>insert时间复杂度O：以d为底，N的对数</li> <li>DeleteMin时间复杂度O：d乘以以d为底，N的对数</li> <li>例如2-堆、3-堆、4-堆.......</li></ul></li> <li><p>左式堆</p> <p>不是平衡的，但是也有堆序性，就是二叉堆的不平衡推广</p> <ul><li><p>零路径长度NPL</p> <ul><li>定义为从任一节点X到一个没有两个儿子的节点Y的最短路径的长。所以可以得到叶子节点和只有一个儿子的节点的Npl均为0，空节点的Npl为-1</li></ul></li> <li><p>性质</p> <ul><li>任一节点的零路径长比它的诸儿子节点的零路径长的最小值多1，其实不难理解，因为父节点比子节点高度高1，所以可以通过取得所有子节点的NPL中的最小值来求父节点NPL</li> <li>对于堆中的每一个节点X，左儿子的零路径长至少与右儿子的零路径长一样大。即左儿子NPL&gt;=右儿子NPL</li></ul></li> <li><p>定理</p> <ul><li><p>如果一个节点有右儿子，那么必须就有左儿子</p> <ul><li>因为如果有右儿子而没有左儿子，那么左儿子的NPL=-1，右儿子NPL最少为0，不符合左式堆的定义</li></ul></li> <li><p>在右路径上有r个节点的左式树必然至少有2^r-1个节点。</p> <ul><li>这一点也非常好理解，因为如果右路径上有r个节点，那么左式树的深度最少为r-1(1是根节点)，根据有右儿子就必然会有左儿子原则，所以树从0到r-1的深度是一颗理想二叉树，理想二叉树共有2^r-1个节点。所以左式树最少有2^r-1个节点</li></ul></li> <li><p>根据上述定理，也可以得到N个节点的左式树有一条右路径最多含有log(N+1)个节点</p></li></ul></li> <li><p>右路径</p> <ul><li>就是节点的右儿子的右儿子的右儿子的右儿子的右儿子组成的路径….就是一只往右儿子下去。</li></ul></li> <li><p>合并</p> <ul><li><p>递归实现</p> <ul><li><p>对于两个左式堆H1和H2，如果H1的根节点值&lt;H2的根节点值，那么我们将H1的右子堆和H2进行合并，然后将合并后的结果当做H1的右子堆，形成的新堆不一定是左式的，但是根节点的左子堆和右子堆他们分别是左式的，如果右子堆的NPL&gt;左子堆的NPL，那么我们交换左右子堆，否则不交换，最后得到合并后的左式堆H3（注意：我们最后需要更新根节点的NPL）。</p> <ul><li>H1的左子堆的任何节点NPL不需要更新</li> <li>H1的右子堆的任何节点NPL需要更新</li> <li>H1的根节点NPL需要更新</li> <li>H2的任何节点NPL需要更新</li></ul></li> <li><p>那小根堆H1的右子堆怎么跟大根堆H2合并呢？我们同样将H1的右子堆当做一个独立的堆H与H2进行合并，合并规则上述已经讲过了。不难看出左式堆的合并可以采用递归的方式进行，当合并到最后，一个堆是空堆一个堆是非空堆时，我们直接返回非空堆，将非空堆添加到小根堆的右子树，然后该交换的交换，该更新NPL的更新NPL。</p></li> <li><p>时间复杂度</p> <ul><li>执行合并的时间与右路径的长的和成正比，因为在递归调用期间对每一个被访问的节点执行的是常数工作量。</li> <li>因为每次都是取右子堆进行合并，所以递归的总次数为两个堆H1和H2的右路径之和，因为我们从定理可以知道对于N个节点的左式堆，右路径最多含有log(N+1)个节点，所以可得时间复杂度为O(log(N+N))，即O(logN)</li></ul></li></ul></li> <li><p>循环实现</p> <ul><li>1.合并两个堆的右路径建立一颗新的树，这颗新树肯定就是小根堆新的右子树了</li> <li>2.合并规则：我们以排序的顺序安排两个堆右路径上的节点，保持他们各自的左儿子不变</li> <li>3.交换那些不满足左式堆性质的左右儿子</li></ul></li></ul></li> <li><p>删除DeleteMin</p> <ul><li>为了执行DeleteMin，我们只需要除掉根得到两个堆，然后再将这两个堆合并即可，因为合并的时间复杂度为O(logN)，所以删除的时间复杂度也为O(logN)</li></ul></li> <li><p>插入</p> <ul><li>插入操作可以看做一个单节点堆和一个多节点堆的合并操作</li></ul></li></ul></li> <li><p>斜堆</p> <p>和左式堆的不同之处在于：不保留零路径长信息以及不做结构限制。左式堆是斜堆的特殊情形</p> <ul><li><p>每次操作的摊还时间复杂度</p> <ul><li>O(logN)</li></ul></li> <li><p>每次操作的最坏时间复杂度</p> <ul><li>O(N)</li></ul></li> <li><p>合并</p> <ul><li><p>递归实现</p> <ul><li>合并流程跟左式堆一样，只是斜堆的合并不需要判断左右子堆NPL的值来判断是否需要交换，斜堆在每次合并完之后直接进行交换左右子堆，合并的次数仍然是右路径的长度和。</li> <li>在斜堆的合并定义里面会说除了右路径上所有节点的最大者不交换它们的左右儿子外，交换是无条件的。其实我们无需把它当做不交换的特殊情况，因为两个堆一起的所有右路径的最大者肯定没有右孩子，并且是右路径的终点，当然不会拿它的右子堆和其他堆去合并，只会用它来跟其它子堆合并，就没有交换它的左右孩子一说了。所以我们只需要每次合并之后交换左右孩子即可，无需特殊处理。</li></ul></li> <li><p>循环实现</p> <ul><li>1.像左式堆一样合并右路径</li> <li>2.除右路径最后的节点外，交换右路径上每个节点的左儿子和右儿子</li></ul></li></ul></li> <li><p>斜堆相比左式堆而言合并效率更高，因为不需要附加的空间来保留路径长度，也不需要测试确定何时交换儿子</p></li></ul></li> <li><p>二项队列</p> <ul><li><p>每次操作最坏运行时间O(logN)</p></li> <li><p>插入操作平均花费常数时间</p></li> <li><p>高度为0的二项树是一颗单节点树，高度为k的二项树B(k)是通过将一颗二项树B(k-1)附接到二项树B(k-1)的根节点上去的树。所以不难看出B(k)和B(k-1)的节点数是等比数列2^k</p></li> <li><p>对于每颗二项树，其每个深度d处所在的层的节点数恰好是二项系数C(k, d)=A(k, d)/d!=k!/(k-d)!/d!</p></li> <li><p>二项队列其实就是森林，我们将二项队列的大小(节点数)分解为2^a、2^b、2^c......等等的和，分解后的项是唯一确定的且他们的幂指数是不同的，每一个项都代表一颗二项树，2^x就是每颗二项树的节点数，其中x为树的高度，且每颗二项树都是堆序树毋庸置疑。那么分解后的项数是多少呢？森林的总节点数为N，假设我们分解得到2^0、2^1、2^2......2^n这些全部的项(其中n代表项数-1)，那么根据等比数列求和公式，我们可以得到n = log(N+1)-1，所以项数位最多为log(N+1)，即最多有logN颗不同的树</p></li> <li><p>二项队列的最小元在每颗树的根节点上，而队列最多有logN颗不同的树，所以最小元可以在O(logN)时间内找到。</p></li> <li><p>合并</p> <ul><li>将高度相同的二项树进行合并，即将大根树当做小根树的子树，每棵树的合并花费常数时间，总共有logN颗树需要合并，所以最坏情形下花费O(logN)</li></ul></li> <li><p>插入</p> <ul><li>插入其实就是特殊的合并，即只需创建一颗单节点树并执行一次合并即可</li> <li>最坏情形运行时间O(logN)</li> <li>如果往空的二项队列中进行N次insert，将花费的最坏情形时间为O(N)</li></ul></li> <li><p>删除DeleteMin</p> <ul><li><p>1.找到要操作的二项树，将其从原二项队列H1中拿出作为一个单独的二项队列H2</p></li> <li><p>2.删除(DeleteMin)H2的根节点，此时H2分解为多个二项树，但仍然是一个二项队列</p></li> <li><p>3.合并H1和H2队列</p></li> <li><p>时间复杂度分析</p> <ul><li>1.查找最小元花费O(logN)</li> <li>2.合并两个队列又是花费O(logN)</li> <li>3.查找和合并是分步进行的，所以时间复杂度不是相乘，即整个DeleteMin操作花费时间O(logN)</li></ul></li></ul></li> <li><p>实现</p> <ul><li>二项树的每一个节点将包含数据、第一个儿子以及右兄弟。二项树中的诸儿子以递减次序排列。递减次序排列意思是：将根节点的指针指向子树最多的儿子，然后该儿子再以子树数量递减的顺序指向其它儿子，这么做是因为我们每次合并时都是将一颗树A拼接到另外一颗树A’的儿子上(即通过根节点直接指向树A，再将A的兄弟指针指向A‘的儿子)，而A就是A’的子树中最大的树，所以我们将根节点指向子树最多的儿子。</li></ul></li></ul></li></ul></li> <li><p>应用</p> <ul><li><p>查找整型数组当中第k小的数</p> <ul><li><p>方法一</p> <ul><li><p>1.将数组构建堆</p> <ul><li>时间复杂度为O(N)</li></ul></li> <li><p>2.每次删除根节点</p> <ul><li>因为删除根节点后需要重新调整堆，其时间复杂度为O(logN)</li></ul></li> <li><p>3.删除k次</p> <ul><li>所以删除操作的时间复杂度为O(klogN)</li></ul></li> <li><p>4.如果k恰好是数组的中位数(即第N/2的位置)，那么其运行时间则为θ(NlogN)，比普通排序查找的时间复杂度O(N^2)要低</p></li> <li><p>5.如果k等于N，那么我们会一直删除堆中的最小的元素，直到最后一个元素，我们把删除的最小元素做下记录，就得到了一个排完序的数列，我们把它叫做堆排序，堆排序时间复杂度为O(NlogN)</p></li></ul></li> <li><p>方法二</p> <ul><li>我们并不构建N个节点的堆，我们只构建k个节点的堆，每次将剩余的元素N-k与堆的根节点进行比较，每次比较后我们都会调整堆，调整的时间复杂度为O(logN)，所以总的时间复杂度为O(k + (N-k)logk) = O(Nlogk)。则中位数的时间复杂度为O(NlogN)</li></ul></li></ul></li></ul></li> <li><p>堆的缺点</p> <ul><li>不能Find</li></ul></li></ul> <h2 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h2> <p>当一个函数用它自己来定义时称为递归</p> <h3 id="基本法则"><a href="#基本法则" class="header-anchor">#</a> 基本法则</h3> <ul><li><p>基准情形</p> <ul><li>你必须总要有某些基准的情形，它们不用递归就能求解</li></ul></li> <li><p>不断推进</p> <ul><li>对于那些需要递归求解的情形，递归调用必须总能朝着产生基准情形的方向推进。</li></ul></li> <li><p>设计法则</p> <ul><li>假设所有的递归调用都能运行</li></ul></li> <li><p>合成效益法则</p> <ul><li>在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作</li></ul></li></ul> <h2 id="数学定义"><a href="#数学定义" class="header-anchor">#</a> 数学定义</h2> <h3 id="o"><a href="#o" class="header-anchor">#</a> O</h3> <ul><li><p>T(N)=O(p(N))</p> <ul><li>T(N)的增长率小于等于p(N)</li></ul></li></ul> <h3 id="o-2"><a href="#o-2" class="header-anchor">#</a> o</h3> <ul><li><p>T(N)=o(p(N))</p> <ul><li>T(N)的增长率小于p(N)</li></ul></li></ul> <h3 id="ω"><a href="#ω" class="header-anchor">#</a> Ω</h3> <ul><li><p>T(N)=Ω(p(N))</p> <ul><li>T(N)的增长率大于等于p(N)</li></ul></li></ul> <h3 id="θ"><a href="#θ" class="header-anchor">#</a> θ</h3> <ul><li><p>T(N)=θ(p(N))</p> <ul><li>T(N)的增长率等于p(N)</li></ul></li></ul> <h2 id="分治"><a href="#分治" class="header-anchor">#</a> 分治</h2> <h3 id="_1-把问题分成两个大致相等的子问题-然后递归地对它们求解-这是-分-部分"><a href="#_1-把问题分成两个大致相等的子问题-然后递归地对它们求解-这是-分-部分" class="header-anchor">#</a> 1.把问题分成两个大致相等的子问题，然后递归地对它们求解，这是”分“部分</h3> <h3 id="_2-治-阶段将两个子问题的解合并到一起并可能-再做些少量的附加工作-最后得到整个问题的解。"><a href="#_2-治-阶段将两个子问题的解合并到一起并可能-再做些少量的附加工作-最后得到整个问题的解。" class="header-anchor">#</a> 2.”治“阶段将两个子问题的解合并到一起并可能 再做些少量的附加工作，最后得到整个问题的解。</h3> <h2 id="对数时间"><a href="#对数时间" class="header-anchor">#</a> 对数时间</h2> <h3 id="如果一个算法用常数时间-o-1-将问题的大小削减为其一部分-通常是1-2-那么该算法就是o-logn-。另一方面-如果使用常数时间只是把问题减少一个常数-如将问题减少1-那么这种算法就是o-n-的。"><a href="#如果一个算法用常数时间-o-1-将问题的大小削减为其一部分-通常是1-2-那么该算法就是o-logn-。另一方面-如果使用常数时间只是把问题减少一个常数-如将问题减少1-那么这种算法就是o-n-的。" class="header-anchor">#</a> 如果一个算法用常数时间（O(1)）将问题的大小削减为其一部分（通常是1/2），那么该算法就是O(logN)。另一方面，如果使用常数时间只是把问题减少一个常数(如将问题减少1)，那么这种算法就是O(N)的。</h3> <h2 id="对分查找-折半查找"><a href="#对分查找-折半查找" class="header-anchor">#</a> 对分查找(折半查找)</h2> <h3 id="从已排序的数组中查找数据-可用对分查找"><a href="#从已排序的数组中查找数据-可用对分查找" class="header-anchor">#</a> 从已排序的数组中查找数据，可用对分查找</h3> <h2 id="欧几里得算法-辗转相除法"><a href="#欧几里得算法-辗转相除法" class="header-anchor">#</a> 欧几里得算法(辗转相除法)</h2> <h3 id="gcd-a-b-gcd-b-a-b"><a href="#gcd-a-b-gcd-b-a-b" class="header-anchor">#</a> gcd(a, b) = gcd(b, a % b)</h3> <ul><li>O(logN)</li></ul> <h3 id="两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数"><a href="#两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数" class="header-anchor">#</a> 两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数</h3> <h2 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h2> <h3 id="基数排序"><a href="#基数排序" class="header-anchor">#</a> 基数排序</h3> <h3 id="桶排序"><a href="#桶排序" class="header-anchor">#</a> 桶排序</h3> <h2 id="树adt"><a href="#树adt" class="header-anchor">#</a> 树ADT</h2> <p>对于大量的输入数据，链表的线性访问时间太慢，不宜使用</p> <h3 id="根节点"><a href="#根节点" class="header-anchor">#</a> 根节点</h3> <h3 id="树叶"><a href="#树叶" class="header-anchor">#</a> 树叶</h3> <h3 id="兄弟"><a href="#兄弟" class="header-anchor">#</a> 兄弟</h3> <p>具有相同父亲的节点</p> <h3 id="边"><a href="#边" class="header-anchor">#</a> 边</h3> <p>边的条数为从父亲节点到某个子节点的路径长度</p> <h3 id="深度"><a href="#深度" class="header-anchor">#</a> 深度</h3> <p>到根节点唯一路径的长度，因此根的深度为0</p> <h3 id="高度"><a href="#高度" class="header-anchor">#</a> 高度</h3> <p>是从该节点到一片树叶的最长路径的长，因此所有树叶的高都是0，一棵树的高度等于它的根的高度。</p> <h3 id="内部路径长度"><a href="#内部路径长度" class="header-anchor">#</a> 内部路径长度</h3> <p>所有节点的深度的和</p> <ul><li><p>内部路径长度分析</p> <ul><li><p>对于N个节点的树，树由一颗i个节点左子树和一颗N-i-1个节点右子树、以及根节点组成。当去掉根节点时，左子树和右子树的每个节点的深度都要减1，所以左子树和右子树总的内部路径长度会减(N-1)，得到内部路径长度表达式：D(N) = D(i)+D(N-i-1) + N -1</p></li> <li><p>如果子树的大小都等可能地出现（即左右子树数量相当），那么D(N) = 2D((N-1)/2)+N-1</p></li> <li><p>平均值D(N) = O(NlogN)</p> <ul><li>因此任意节点的期望深度为O(logN)</li></ul></li></ul></li></ul> <h3 id="树的实现"><a href="#树的实现" class="header-anchor">#</a> 树的实现</h3> <ul><li><p>如果将每个儿子节点的指针都存放在父节点当中，势必会造成存储空间的浪费，因为每个节点的的子节点数量是不确定的。解决办法是：将每个节点的所有儿子都放在树节点的链表中。</p> <ul><li>typedef struct TreeNode *PtrToNode;
struct TreeNode
{
ElementType Element;//存放值
PtrToNode FirstChild;//存放第一个子节点
PtrToNode NextSibling;//存放下一个兄弟节点
}</li></ul></li></ul> <h3 id="树的遍历"><a href="#树的遍历" class="header-anchor">#</a> 树的遍历</h3> <ul><li><p>先序遍历</p> <p>先遍历父节点(根节点)，再遍历左孩子、然后遍历右孩子。路径是从根节点一直向左孩子延伸，到达树叶后再从树叶的兄弟节点向根节点延伸。</p> <ul><li>打印文件路径</li></ul></li> <li><p>后序遍历</p> <ul><li>计算每个文件夹的大小</li></ul></li> <li><p>中序遍历</p></li></ul> <h3 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h3> <p>每个节点都不能有多余两个的儿子。因为一颗二叉树最多有两个儿子，所以我们可以用指针直接指向它们，树节点的声明类似于双向链表，所以链表上的许多法则也可以应用到树上</p> <ul><li><p>二叉查找树</p> <p>树中的每个节点X，它的左子树中的值或者左子树的子树的值小于X的值，它的右子树的值或者右子树的子树的值大于X的值</p> <ul><li><p>特性</p> <ul><li>最多2^(n+1)-1个节点，其中n为树的深度</li> <li>深度的平均值是O(logN)，其中N为节点个数</li></ul></li> <li><p>节点插入</p> <p>插入只会在叶子节点上插入</p> <ul><li>1.如果节点根节点为null，那么我们就创建要插入的节点</li> <li>2.如果要插入的节点的值比根节点小，那么就在左子树上进行插入(递归调用)</li> <li>3.如果要插入的节点的值比根节点大，那么就在右子树上进行插入(递归调用)</li> <li>4.最后返回根节点的指针</li></ul></li> <li><p>节点删除</p> <ul><li>1.如果节点是一片树叶，那么它可以被立即删除</li> <li>2.如果要删除的节点X只有一个孩子Y，那么就将原来指向节点X的父节点中的指针指向孩子Y</li> <li>3.如果要删除的节点X有左孩子Y和右孩子Z，那么我们就将节点X的值替换成为X右子树序列中最小的节点W的值（最小值不可能有左孩子），然后将节点W删除，因为W最多只有一个孩子节点，所以我们在删除W时可以依照步骤2删除</li></ul></li> <li><p>平衡二叉查找树</p> <p>平衡二叉搜索树，叶子节点高度差不超过1</p> <ul><li><p>AVL树</p> <p>带有平衡条件的二叉查找树，深度为O(logN)，所以它的每个节点的左子树和右子树的高度最多差1</p> <ul><li><p>对于高度为h的AVL树，我们可以求出最少需要的节点数：S(h) = S(h-1)+S(h-2)+1，意思是左子树的最少节点数+右子树最少节点数+根节点数量，其中左子树和右子树高度相差1时最少，所以一个是S(h-1)，另一个是S(h-2)，我们可以看到S(h)函数和斐波拉契数列密切相关，根据这个斐波拉契数量，我们可以推得另外一个公式：即N个节点最多的高度</p> <ul><li>例如高度为9的AVL树，最少需要143个节点才能组成，最多肯定就是2^(h+1)-1了</li></ul></li> <li><p>对于N个节点的AVL树，我们可以求出高度最多为1.44log(N+2)-1.328</p></li> <li><p>当对AVL树进行插入操作时，总会破坏树的平衡条件，所以我们可以通过对树进行旋转来恢复平衡。在插入以后，只有那些从插入点到根节点的路径上的节点的平衡可能被改变，因为只有这些节点的子树可能发生变化。</p></li> <li><p>旋转</p> <p>当我们插入一个节点后，顺次从插入节点的位置向根节点查找第一个失去平衡的节点α，失去平衡的节子树高度会差2，所以我们可以可以分为4种情况：</p> <ul><li>1.对α的左儿子的左子树进行一次插入</li> <li>2.对α的右儿子的右子树进行一次插入</li> <li>3.对α的左儿子的右子树进行一次插入</li> <li>4.对α的右儿子的左子树进行一次插入</li></ul></li> <li><p>每次操作时间复杂度O(logN)</p></li></ul></li> <li><p>Treap</p></li> <li><p>节点大小平衡树</p></li></ul></li> <li><p>伸展树</p> <p>当一个节点X被访问后，它就要经过一系列旋转被放到根上。相当于不需要保证平衡的AVL树</p> <ul><li><p>展开（即旋转）</p> <ul><li><p>1.如果X的父节点是树根，那么只要旋转X和树根</p></li> <li><p>2.如果X的父节点不是树根，那么就存在祖父节点</p> <ul><li><p>如果为之字形(zig-zag)：类似于AVL树的内部情况（即左-右或右-左）</p> <ul><li>我们进行一次AVL那样的双旋转</li></ul></li> <li><p>如果为一字形(zig-zig)：类似于AVL树的外边情况(即左-左或右-右)</p> <ul><li>我们进行两次AVL那样的单旋转</li></ul></li></ul></li> <li><p>3.旋转至X为根节点时即结束</p></li></ul></li> <li><p>每次操作摊还时间复杂度O(logN)</p></li></ul></li> <li><p>红黑树</p> <ul><li><p>性质</p> <ul><li>1.每一个节点或者是红色或者是黑色的</li> <li>2.根是黑色的</li> <li>3.如果一个节点是红色的，那么它的子节点必须是黑色的(也就是说黑色节点可以连续，红色节点不能连续)</li> <li>4.从一个节点到一个NULL指针的每一条路径必须包含相同数目的黑色节点</li></ul></li> <li><p>高度最多是2log(N+1)</p></li> <li><p>插入规则</p> <ul><li><p>1.通常在树叶位置插入</p></li> <li><p>2.如果把插入的项设置为黑色肯定不行，因为这就违反了第4条，到null指针的每条路径必须有相同的黑色节点数，所以只能插入红色节点</p></li> <li><p>3.如果在插入时，父节点是黑节点，那么插入没问题，如果父节点是红节点，那么就不能直接插入，因为红节点的子节点必须是黑色的，在这种情况下我们必须调整该树以确保满足条件，基本操作就是改变颜色和旋转</p></li> <li><p>4.父节点是红节点的情况</p> <ul><li><p>如果这个父节点的兄弟节点是黑的(我们约定NULL节点都是黑色的)，那么我们进行一字或者之字旋转</p> <ul><li>将新形成的子树的根节点涂成黑色，将被替换后的节点涂成红色，以保证路径上黑节点数量不变</li></ul></li> <li><p>2.如果这个父节点的兄弟节点是红色的，那么我们不进行更改颜色，只进行旋转操作，旋转完后，将根节点的红色上滤</p></li></ul></li></ul></li></ul></li></ul></li> <li><p>表达式树</p> <p>一颗二叉树的叶子节点是数值，而根节点全是操作运算符</p> <ul><li><p>遍历表达式树</p> <ul><li><p>通过先序遍历可以得到前缀表达式</p> <p>不太常用</p></li> <li><p>通过后续遍历可以得到后缀表达式</p></li> <li><p>通过中序遍历可以得到中缀表达式</p></li></ul></li> <li><p>构造一颗表达式树</p> <ul><li><p>构造过程</p> <ul><li>1.我们一次一个符号地读入表达式</li> <li>2.如果符号时操作数，那么我们就建立一个单节点树并将一个指向它的指针推入栈中</li> <li>3.如果符号时操作符，那么我们就从栈中弹出指向两颗树的那两个指针并形成一颗新的树，该树的根就是操作符，它的左右儿子分别是弹出的那两个指针</li> <li>4.然后将指向这颗新树的指针压入栈中</li></ul></li> <li><p>例如将后缀表达式ab+cde+**构造成为一颗表达式树</p> <ul><li>1.a和b是操作数，因此我们创建两颗单节点树并将指向他们的指针压入栈中</li> <li>2.接着读取到+号，因此将这两颗单节点树弹出，和+号操作符一起构造成为一颗三节点树，其中操作符为根节点，然后将指向根节点的指针压入栈中</li> <li>3.然后将cde压入栈中</li> <li>4.读取到+号，此时从栈顶弹出两个指针，和+号构造成为一颗二叉树(根节点为+号操作符)，然后将根节点指针压入栈中</li> <li>5.读取到*号，又从栈顶弹出两个指针，构造二叉树，将根节点指针压入栈中</li> <li>6.读取到*号，又从栈顶弹出两个指针，构造二叉树，将根节点指针压入栈中</li></ul></li></ul></li></ul></li> <li><p>完全二叉树</p> <p>高度为h的二叉树，除了高度为h的层没被填满之外，其它的层都被填满了，而且高度为h的层元素是从左到右填入的，这样的树称为完全二叉树，所以完全二叉树是平衡的。完全二叉树也叫做堆。不难看出，完全二叉树是逐层填充数据。</p> <ul><li>因为完全二叉树很有规律，所以它可以用一个数组表示，而不需要指针</li></ul></li></ul> <h3 id="多分树"><a href="#多分树" class="header-anchor">#</a> 多分树</h3> <ul><li><p>平衡多分查找树</p> <ul><li><p>B-树</p> <p>对于M阶B-树。
1.根节点的儿子数在2到M之间。
2.其他节点的儿子数在M/2到M之间。
3.叶子节点的深度相同
4.值都存储在叶子节点上
5.父节点会存储指向每个儿子的指针
5.根节点和中间节点只会存储除第一颗子树外每颗子树的最小值，注意是每颗子树的最小值，而不是每个儿子的最小值，这是有区别的。</p> <ul><li>从树根往下查找，通过对比每个节点中的值，来判断通向哪个分支，对于每个节点中的查找，采用折半查找法，因为B-树是已排序的树</li></ul></li> <li><p>B+树</p></li></ul></li></ul> <h2 id="散列表-哈希表-adt"><a href="#散列表-哈希表-adt" class="header-anchor">#</a> 散列表(哈希表)ADT</h2> <p>每个关键字被映射到从0到tableSize-1这个范围中的某个数，并且被放到适当的单元中，这个映射就叫做散列函数。</p> <p>哈希表的长度有限，而关键字的数目是无限的，所以需要寻找一个散列函数，该函数要在单元之间均匀分配关键字</p> <p>散列表以常数平均时间执行插入、删除和查找操作</p> <h3 id="整数关键字"><a href="#整数关键字" class="header-anchor">#</a> 整数关键字</h3> <ul><li>散列函数通常是Key mod TableSize</li></ul> <h3 id="字符串关键字"><a href="#字符串关键字" class="header-anchor">#</a> 字符串关键字</h3> <ul><li>散列函数可以是字符串的ASCII码值加起来，然后mod TableSize</li></ul> <h3 id="哈希冲突解决方法"><a href="#哈希冲突解决方法" class="header-anchor">#</a> 哈希冲突解决方法</h3> <p>如果当一个元素被插入处另一个元素已经存在（即哈希值相同），那么久产生一个冲突，这个冲突需要消除</p> <ul><li><p>分离链接法</p> <ul><li><p>将散列值相同的元素保留到一个表中，为方便起见，这些表都有表头。当然我们不仅可以使用链表来解决哈希冲突，还可以使用二叉查找树甚至另外一个哈希表均可胜任</p> <ul><li>所以执行一次查找所需的工作是计算散列函数值的常数时间加上遍历表所用的时间</li></ul></li> <li><p>通常法则是让λ≈1</p></li></ul></li> <li><p>开放定址法</p> <ul><li><p>如果有冲突发生，那么就要尝试选择另外的单元，如果一直到散列表尾都没有空单元，我们会从表头再开始选择，直到找出空的单元为止。那么如何去尝试选择另外的单元呢？这里有两种方法：</p> <ul><li><p>线性探测法</p> <p>即当发生冲突时，逐个探测每个单元，直到找到空单元为止。</p> <ul><li>缺点是占据的单元会形成一些区块，称为一次聚集，于是，散列到区块中的任何关键字都需要多次试选单元才能够解决冲突，然后该关键字才被添加到相应的区块中。</li> <li>如果λ&gt;0.5，那么线性探测就不是一个好的办法，因为需要探测的次数会随指数增长</li></ul></li> <li><p>平方探测法</p> <p>平方探测是消除线性探测中一次聚集问题的冲突解决方法。平方探测就是冲突函数为二次函数的探测方法。因为线性探测法是逐个探测每个单元然后填充，这会造成单元聚集，而平方探测不是线性的，所以不会逐个去探测每个单元，而是跳过某些单元去探测，如果线性探测函数是F(i)=i，那么平方探测函数则为F(i) = i^2。含义为：当进行第一次探测时，我们跨过1个元素进行探测，当进行第二次探测时，我们跨过4个元素进行探测，以此类推。</p> <ul><li>缺点：如果表的大小不是素数，那么就可能会发生探测不到空单元，因为平方数可能每次都定位到相同的一些单元</li> <li>缺点2：虽然平方探测排除了一次聚集，但是散列到同一位置上的那些元素将探测相同的备选单元，这叫做二次聚集。</li> <li>如果表的大小是素数，那么当表至少有一半空单元时，总能够插入一个新元素</li></ul></li> <li><p>双散列</p> <p>当发生冲突时，我们采用其他的哈希函数来进行探测，而不是线性探测或者是平方探测，这样的灵活性很高。通常一种流行的冲突函数时F(i) = i * hash(X)。这个公式的意思是将一个哈希函数运用到探测当中去，每探测一次，函数就跳过hash(X)的步长</p></li></ul></li> <li><p>装填因子λ应该低于0.5</p></li> <li><p>标准的删除操作不能实施，因为相应的单元可能已经引起过冲突，冲突元素被存在了别处，如果删除了当前元素，那么进行find查找时无法查找到冲突元素，因此开放定址法需要懒惰删除（即只是标记为删除状态，并不是从内存当中删除）</p></li></ul></li></ul> <h3 id="再散列"><a href="#再散列" class="header-anchor">#</a> 再散列</h3> <p>当我们以开放定址法向散列表中插入元素时，如果新插入元素后发现表中元素的数量已经超过了一定量值（例如超过了表长的70%），那么我们就将表扩大一倍，并以扩大后的第一个素数为表的长度，然后再次通过新的散列函数进行全部重新插值</p> <ul><li><p>实现策略</p> <ul><li><p>一种做法是只要表满到一半就再散列</p></li> <li><p>另一种极端的方法是只有当插入失败时才再散列</p></li> <li><p>第三种方法即途中策略</p> <p>当表到达某一个装填因子时进行再散列。由于随着装填因子的增加，表的性能的确有下降，因此以好的截止手段实现的第三种策略，可能是最好的策略。</p></li></ul></li></ul> <h3 id="可扩散列"><a href="#可扩散列" class="header-anchor">#</a> 可扩散列</h3> <h3 id="装填因子λ"><a href="#装填因子λ" class="header-anchor">#</a> 装填因子λ</h3> <p>散列表中元素个数与散列表大小的比值</p> <h3 id="编译器使用散列表跟踪源代码中声明的变量。这种数据结构叫做符号表"><a href="#编译器使用散列表跟踪源代码中声明的变量。这种数据结构叫做符号表" class="header-anchor">#</a> 编译器使用散列表跟踪源代码中声明的变量。这种数据结构叫做符号表</h3> <h2 id="排序-2"><a href="#排序-2" class="header-anchor">#</a> 排序</h2> <h3 id="内部排序"><a href="#内部排序" class="header-anchor">#</a> 内部排序</h3> <p>在内存中进行</p> <ul><li><p>不需要额外存储空间</p> <ul><li><p>插入排序</p> <p>从数组位置P开始取值，如果取得的值比前面已排序P-1位置的值小，那么将P-1位置的值往后移动，如果还比P-2位置的值小，那么继续移动P-2，直到找到一个合适，然后将位置P的值插入进去。接着取P+1、P+2.......N-1位置的值，依次插入前面的</p> <ul><li>时间复杂度O(N^2)</li> <li>外层循环临界值：for (i = 1; i &lt; N; i++)，表示从第一个数开始取值来插入</li> <li>内循环临界值：for (j = i; j &gt; 0 &amp;&amp; *(a+j-1) &gt; value; j--)，表示倒序遍历已排序的子数组，value比子数组中的数小时，就将每一个当前值往后移，直到找到合适的位置，退出内循环。</li></ul></li> <li><p>希尔排序</p> <p>希尔排序通过 比较相聚一定间隔的元素来工作；各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。由于这个原因，希尔排序有时也叫做缩小增量排序。</p> <ul><li>希尔排序对于每一趟排序，是将后面的数通过插入排序的方式插入到各个独立的子数组当中。不拿看出插入排序是希尔排序的特例，只是插入排序的插值增量是1</li> <li>外层循环：for (increment = N/2; increment&gt;0; increment/=2)，表示从N/2的增量开始，逐渐减小增量进行遍历</li> <li>中间循环：for (i=increment; i &lt; N; i++)，表示从增量开始的位置从后面进行取值</li> <li>内层循环：for (j = i; j-increment&gt;=0 &amp;&amp; value &lt; A[j-increment] ; j-=increment)，表示当value小于已排序的子数组时，我们将子数组往后移，以便给新元素腾出位置</li> <li>最坏情形时间复杂度θ(N^2)</li> <li>对于Hibbard增量2^(k)-1，最坏情形时间复杂度为θ(N^1.5)</li> <li>对于Sedgewick增量，最坏时间复杂度O(N^4/3)</li></ul></li> <li><p>堆排序</p> <ul><li>时间复杂度O(NlogN)</li> <li>一般的堆排序需要额外的存储空间，当然我们也可以采用小技巧，将在DeleteMin时，将该元素存放到堆的末尾位置，在最后一次DeleteMin之后，该数组将以递减的顺序包含所有元素，如果需要得到递增的顺序，那么我们使用大根堆即可</li></ul></li> <li><p>快速排序</p> <ul><li><p>平均时间复杂度O(NlogN)</p></li> <li><p>最坏时间复杂度O(n^2)</p></li> <li><p>过程</p> <ul><li><p>1.从数组中选择一个枢纽元</p> <ul><li><p>选择技巧</p> <ul><li>选择数组左边中间右边三个数中的一个(三个数的中间大小的值)作为枢纽元，并将枢纽元交换到数组最后</li></ul></li></ul></li> <li><p>2.将数组分割为两部分，左边部分比枢纽元小，右边部分比枢纽元大</p> <ul><li>首尾两个指针i和j，分别向中间遍历，当左边指针遇到比枢纽元大的元素时停止，当右边指针遇到比枢纽元小的元素时停止，然后交换两个指针所指向的值，继续遍历，直到左右指向相遇，则一次循环结束，然后将枢纽元交换到i最后指向的位置，此时i左边的元素是小元素，i右边的元素是大元素。</li></ul></li> <li><p>3.采用递归的方式。将i左边的元素当做一个数组，将i右边的元素当做一个数组，进行递归调用</p></li> <li><p>4.对于很小的数组(N&lt;=20)，快速排序不如插入排序好，所以在递归到小数组时，我们可以切换成插入排序，使用这种策略实际上可以节省大约15%的运行时间，通常是在N=10时进行切换排序算法</p></li></ul></li></ul></li> <li><p>快速选择</p> <ul><li>利用快速排序的思想，进行查找第k个最小元素</li></ul></li></ul></li> <li><p>需要额外存储空间</p> <ul><li><p>归并排序</p> <ul><li><p>最坏时间复杂度O(NlogN)</p></li> <li><p>采用递归的思想，将原数组拆解成两个大小相等的数组，一直拆分下去，最后单个元素的数组肯定是有序的，然后将它们合并到一个数组当中，归并排序其实就是分治的策略</p></li> <li><p>缺点</p> <ul><li>需要线性额外存储空间</li> <li>需要将数据拷贝到临时数组，然后还要再拷贝回来，其结果严重放慢了排序的速度</li></ul></li></ul></li> <li><p>桶排序</p> <ul><li>将每个元素装到对应的桶内，然后再遍历桶数组，取出不为空的桶</li></ul></li></ul></li></ul> <h3 id="外部排序"><a href="#外部排序" class="header-anchor">#</a> 外部排序</h3> <p>在磁盘进行</p> <h2 id="图论"><a href="#图论" class="header-anchor">#</a> 图论</h2> <h3 id="图g-v-e"><a href="#图g-v-e" class="header-anchor">#</a> 图G = (V, E)</h3> <ul><li>由顶点和边组成</li> <li>边是点对(v, w)</li> <li>有序点对的图是有向图</li> <li>路径是顶点序列</li> <li>从一个顶点到它自身可以看成一条路径</li> <li>从一个顶点到自身的边，叫做一个环，我们不讨论环的情况</li> <li>如果路径上的所有顶点互异，那么称为简单路径</li> <li>首尾顶点相同且长度至少为1的路径称为圈，如果是简单路径，那么称为简单圈，对于无向图(u,v)和(v,u)是同一条边，所以不是圈</li> <li>有向无圈图称为DAG</li> <li>在一个无向图中从每一个顶点到每个其他顶点都存在一条路径，则称该无向图是连通的。这种图示强连通的。</li> <li>如果一个有向图不是强连通的，但是去掉方向后是连通的，那么该有向图称为弱连通的。</li> <li>每一对顶点间都存在一条边的图称为完全图</li></ul> <h3 id="表示方法"><a href="#表示方法" class="header-anchor">#</a> 表示方法</h3> <ul><li>邻接矩阵(二维数组)</li> <li>邻接表</li></ul> <h3 id="拓扑排序"><a href="#拓扑排序" class="header-anchor">#</a> 拓扑排序</h3> <p>对有向无圈图的顶点的一种排序，它使得如果存在一条从vi到vj的路径，那么在排序中vj出现在vi的后面</p> <ul><li><p>算法</p> <ul><li>先找出任意一个没有入边(只有出边，即只有指向其它顶点的顶点)，然后显示出该顶点，并将它和它的边一起从图中删除。依次对图中中其余部分应用同样的方法处理</li></ul></li></ul> <h3 id="最短路径算法"><a href="#最短路径算法" class="header-anchor">#</a> 最短路径算法</h3> <ul><li><p>赋权路径长</p></li> <li><p>无权路径长</p></li> <li><p>无权最短路径算法</p> <ul><li><p>广度优先搜索</p> <p>该方法按层处理顶点：距开始点最近的那些顶点首先被赋值，而最远的那些顶点最后被赋值。这很像对树的层序遍历</p> <ul><li>1.选取某个顶点s作为输入参数</li> <li>2.从s出发的所有顶点(v1和v6)距离s为1,所以到v1和v6最短路径长为1</li> <li>3.从v1和v6出发的所有顶点(v2和v4)距离2</li> <li>依次类推，依次找出所有顶点的最短路径</li></ul></li></ul></li> <li><p>有权算法</p> <ul><li><p>Dijkstra算法</p> <ul><li>Dijkstra算法像无权最短路径算法一样，按阶段进行。在每个阶段，Dijkstra算法选择一个顶点v，它在所有未知顶点中具有最小的dv，同时算法声明从s到v的最短路径是已知的。阶段的其余部分由dw值的更新工作组成。</li></ul></li></ul></li> <li><p>松弛时间</p> <ul><li>表示对应动作可以被延迟而不推迟整体的完成时间量</li></ul></li> <li><p>关键路径</p> <ul><li>至少存在一条完全由零松弛边组成的路径称为关键路径</li></ul></li></ul> <h3 id="最小生成树"><a href="#最小生成树" class="header-anchor">#</a> 最小生成树</h3> <ul><li><p>一个无向图G的最小生成树就是由该图的那些连接G的所有顶点的边 构成的树，且其总价值最低。</p></li> <li><p>构建最小生成树</p> <ul><li><p>Prim算法</p> <p>在每一步，都把一个节点当做根并往上加边，每一步把到每个节点的最小边添加到树中</p></li> <li><p>Kruskal算法</p> <p>连续地按照最小的权选择边，然后按照权值进行合并操作</p></li></ul></li></ul> <h3 id="深度优先搜索"><a href="#深度优先搜索" class="header-anchor">#</a> 深度优先搜索</h3> <ul><li>我们从某个顶点v开始处理v，然后递归地遍历所有与v邻接的顶点</li></ul> <h3 id="欧拉回路"><a href="#欧拉回路" class="header-anchor">#</a> 欧拉回路</h3> <ul><li>在图中找出一条路径，使得该路径对图的每条边恰好访问一次</li> <li>对于起点终点相同的欧拉回路，其每个顶点的度(即边的条数)必须是偶数</li> <li>如果恰好有两个顶点的度是奇数，那么当我们从一个奇数度的顶点出发，最后终止在另一个奇数的顶点时，仍然有可能得到一个欧拉环游</li> <li>如果奇数度的顶点多余两个，那么欧拉环游是不可能存在的</li> <li>所有顶点的度均为偶数的任何连通图必然有欧拉回路，我们还可以以线性时间找出这样一条回路</li></ul> <h2 id="算法设计"><a href="#算法设计" class="header-anchor">#</a> 算法设计</h2> <h3 id="贪婪算法"><a href="#贪婪算法" class="header-anchor">#</a> 贪婪算法</h3> <ul><li><p>Dijkstra算法</p></li> <li><p>Prim算法</p></li> <li><p>Kruskal算法</p></li> <li><p>哈夫曼编码</p> <ul><li><p>性质</p> <ul><li>是一颗满树</li> <li>字符存放在树叶上</li> <li>出现频率高的字符离根节点最近</li></ul></li> <li><p>哈夫曼算法</p> <ul><li>假设字符个数为C</li> <li>算法对一个由树组成的森林进行。一棵树的权等于它的树叶的频率的和。任意选取最小权的两颗树T1和T2，并任意形成以T1和T2为子树的新树，将这样的过程进行C-1次。</li></ul></li></ul></li></ul> <h3 id="分治-2"><a href="#分治-2" class="header-anchor">#</a> 分治</h3> <ul><li>分：递归解决较小的问题</li> <li>治：从子问题的解构建原问题的解</li></ul> <h3 id="动态规划"><a href="#动态规划" class="header-anchor">#</a> 动态规划</h3> <ul><li>如果编译器的递归模拟算法要是能够保留一个预先算出的值的表而对已经结果的子问题不再进行递归调用，那么算法将是高效的，动态规划也就是记录前值，一步步算出现在的值，而不是采用递归的方式进行循环调用</li></ul> <h3 id="回溯"><a href="#回溯" class="header-anchor">#</a> 回溯</h3> <ul><li>对可能的解进行尝试，如果尝试失败，就退回到算法开始处</li></ul> <p><em>XMind - Trial Version</em></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/iOS笔记/视频常识.html" class="prev">
        视频常识
      </a></span> <span class="next"><a href="/iOS笔记/算法.html">
        算法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9de76d75.js" defer></script><script src="/assets/js/2.98ea7a63.js" defer></script><script src="/assets/js/66.aac422ac.js" defer></script>
  </body>
</html>
