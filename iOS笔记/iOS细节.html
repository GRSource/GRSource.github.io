<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>iOS细节 | 文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.9de76d75.js" as="script"><link rel="preload" href="/assets/js/2.98ea7a63.js" as="script"><link rel="preload" href="/assets/js/62.df85ea27.js" as="script"><link rel="prefetch" href="/assets/js/10.fa8eed47.js"><link rel="prefetch" href="/assets/js/11.f98f25e0.js"><link rel="prefetch" href="/assets/js/12.1ab9b5a3.js"><link rel="prefetch" href="/assets/js/13.75251b00.js"><link rel="prefetch" href="/assets/js/14.b5068189.js"><link rel="prefetch" href="/assets/js/15.33abd7e1.js"><link rel="prefetch" href="/assets/js/16.34ed8053.js"><link rel="prefetch" href="/assets/js/17.b3d52ea3.js"><link rel="prefetch" href="/assets/js/18.cbe71205.js"><link rel="prefetch" href="/assets/js/19.c632cb86.js"><link rel="prefetch" href="/assets/js/20.90d9a221.js"><link rel="prefetch" href="/assets/js/21.15cb7700.js"><link rel="prefetch" href="/assets/js/22.62ea968a.js"><link rel="prefetch" href="/assets/js/23.b743fdd5.js"><link rel="prefetch" href="/assets/js/24.5d157647.js"><link rel="prefetch" href="/assets/js/25.1935fba3.js"><link rel="prefetch" href="/assets/js/26.fd22f8ee.js"><link rel="prefetch" href="/assets/js/27.f47adfe7.js"><link rel="prefetch" href="/assets/js/28.d9f5719d.js"><link rel="prefetch" href="/assets/js/29.82cbf665.js"><link rel="prefetch" href="/assets/js/3.b96f613e.js"><link rel="prefetch" href="/assets/js/30.9f901f01.js"><link rel="prefetch" href="/assets/js/31.d9e2f61c.js"><link rel="prefetch" href="/assets/js/32.b14052e9.js"><link rel="prefetch" href="/assets/js/33.1b2e5efd.js"><link rel="prefetch" href="/assets/js/34.4bf7f44f.js"><link rel="prefetch" href="/assets/js/35.98d5fd2b.js"><link rel="prefetch" href="/assets/js/36.cdaf1c2f.js"><link rel="prefetch" href="/assets/js/37.a67bdb9a.js"><link rel="prefetch" href="/assets/js/38.5d856b83.js"><link rel="prefetch" href="/assets/js/39.27169c95.js"><link rel="prefetch" href="/assets/js/4.268c621c.js"><link rel="prefetch" href="/assets/js/40.8763c647.js"><link rel="prefetch" href="/assets/js/41.cd839f43.js"><link rel="prefetch" href="/assets/js/42.a97bf97a.js"><link rel="prefetch" href="/assets/js/43.fd126bb1.js"><link rel="prefetch" href="/assets/js/44.50e2b10d.js"><link rel="prefetch" href="/assets/js/45.0c29263b.js"><link rel="prefetch" href="/assets/js/46.fdee27aa.js"><link rel="prefetch" href="/assets/js/47.c7c7e966.js"><link rel="prefetch" href="/assets/js/48.80bc6f0a.js"><link rel="prefetch" href="/assets/js/49.d457b0ac.js"><link rel="prefetch" href="/assets/js/5.f577ebb9.js"><link rel="prefetch" href="/assets/js/50.cea3b0e6.js"><link rel="prefetch" href="/assets/js/51.eaab3e31.js"><link rel="prefetch" href="/assets/js/52.010a2dfb.js"><link rel="prefetch" href="/assets/js/53.3622f7b6.js"><link rel="prefetch" href="/assets/js/54.817aba2b.js"><link rel="prefetch" href="/assets/js/55.c3984ff9.js"><link rel="prefetch" href="/assets/js/56.6f20785e.js"><link rel="prefetch" href="/assets/js/57.07c7f6fc.js"><link rel="prefetch" href="/assets/js/58.4ec50d24.js"><link rel="prefetch" href="/assets/js/59.626b42b0.js"><link rel="prefetch" href="/assets/js/6.b9249342.js"><link rel="prefetch" href="/assets/js/60.ba2af5c7.js"><link rel="prefetch" href="/assets/js/61.6e22c298.js"><link rel="prefetch" href="/assets/js/63.cd3c1f6a.js"><link rel="prefetch" href="/assets/js/64.d0f75a86.js"><link rel="prefetch" href="/assets/js/65.12e0c392.js"><link rel="prefetch" href="/assets/js/66.aac422ac.js"><link rel="prefetch" href="/assets/js/67.3ff890c6.js"><link rel="prefetch" href="/assets/js/68.c6d12518.js"><link rel="prefetch" href="/assets/js/69.455e0c09.js"><link rel="prefetch" href="/assets/js/7.375eddd0.js"><link rel="prefetch" href="/assets/js/70.73d975e7.js"><link rel="prefetch" href="/assets/js/71.66528e07.js"><link rel="prefetch" href="/assets/js/72.a608a326.js"><link rel="prefetch" href="/assets/js/73.b8ed0811.js"><link rel="prefetch" href="/assets/js/74.68f4db5d.js"><link rel="prefetch" href="/assets/js/75.85059bdc.js"><link rel="prefetch" href="/assets/js/8.a04b9d9b.js"><link rel="prefetch" href="/assets/js/9.04a00c43.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>iOS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>iOS笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iOS笔记/工具.html" class="sidebar-link">工具</a></li><li><a href="/iOS笔记/计算机网络.html" class="sidebar-link">计算机网络</a></li><li><a href="/iOS笔记/架构.html" class="sidebar-link">架构</a></li><li><a href="/iOS笔记/视频播放器设计（基于FFmpeg）.html" class="sidebar-link">视频播放器设计（基于FFmpeg）</a></li><li><a href="/iOS笔记/视频常识.html" class="sidebar-link">视频常识</a></li><li><a href="/iOS笔记/数据结构与算法分析.html" class="sidebar-link">数据结构与算法分析</a></li><li><a href="/iOS笔记/算法.html" class="sidebar-link">算法</a></li><li><a href="/iOS笔记/音频常识.html" class="sidebar-link">音频常识</a></li><li><a href="/iOS笔记/音视频开发.html" class="sidebar-link">音视频开发</a></li><li><a href="/iOS笔记/直播.html" class="sidebar-link">直播</a></li><li><a href="/iOS笔记/App启动优化.html" class="sidebar-link">App启动优化</a></li><li><a href="/iOS笔记/Audio.html" class="sidebar-link">Audio</a></li><li><a href="/iOS笔记/AudioToolbox.html" class="sidebar-link">AudioToolbox</a></li><li><a href="/iOS笔记/AVFoundation.html" class="sidebar-link">AVFoundation</a></li><li><a href="/iOS笔记/C.html#.html" class="sidebar-link">C</a></li><li><a href="/iOS笔记/C.html#.html" class="sidebar-link">C#</a></li><li><a href="/iOS笔记/C++.html" class="sidebar-link">C++</a></li><li><a href="/iOS笔记/CoreAudio.html" class="sidebar-link">CoreAudio</a></li><li><a href="/iOS笔记/CoreVideo.html" class="sidebar-link">CoreVideo</a></li><li><a href="/iOS笔记/FFmpeg.html" class="sidebar-link">FFmpeg</a></li><li><a href="/iOS笔记/Flutter.html" class="sidebar-link">Flutter</a></li><li><a href="/iOS笔记/GPUImage.html" class="sidebar-link">GPUImage</a></li><li><a href="/iOS笔记/ijkPlayer.html" class="sidebar-link">ijkPlayer</a></li><li><a href="/iOS笔记/iOS细节.html" class="active sidebar-link">iOS细节</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#self和super的区别" class="sidebar-link">self和super的区别</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#category" class="sidebar-link">Category</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#返回类型" class="sidebar-link">返回类型</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#extension" class="sidebar-link">Extension</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#self-alloc-init-和-myobject-alloc-init-区别" class="sidebar-link">[[self alloc] init]和[[MyObject alloc]init]区别</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#properties" class="sidebar-link">properties</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#关键字" class="sidebar-link">关键字</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#block理解" class="sidebar-link">block理解</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#变量和常量" class="sidebar-link">变量和常量</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#常见的crash" class="sidebar-link">常见的crash</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#多线程" class="sidebar-link">多线程</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#锁" class="sidebar-link">锁</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#swift指针" class="sidebar-link">Swift指针</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#urlsession" class="sidebar-link">URLSession</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#runloop" class="sidebar-link">RunLoop</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#对象" class="sidebar-link">对象</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#autoreleasepool" class="sidebar-link">autoreleasePool</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#对象释放时机" class="sidebar-link">对象释放时机</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#ui响应链" class="sidebar-link">UI响应链</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#组件化" class="sidebar-link">组件化</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#oc消息转发" class="sidebar-link">OC消息转发</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#设计模式" class="sidebar-link">设计模式</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#第三方库" class="sidebar-link">第三方库</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#load和initialize" class="sidebar-link">load和initialize</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#组件化-2" class="sidebar-link">组件化</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#内存管理" class="sidebar-link">内存管理</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#客户端整体架构" class="sidebar-link">客户端整体架构</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#野指针" class="sidebar-link">野指针</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#oom判定" class="sidebar-link">OOM判定</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#防止crash" class="sidebar-link">防止crash</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#ns-enum和ns-options" class="sidebar-link">NSENUM和NSOPTIONS</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#ns-designated-initializer" class="sidebar-link">NSDESIGNATEDINITIALIZER</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#堆和栈" class="sidebar-link">堆和栈</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#new调用流程" class="sidebar-link">new调用流程</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#object-getclass-id-obj-调用流程" class="sidebar-link">object_getClass(id obj)调用流程</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#objc-init初始化流程" class="sidebar-link">objcinit初始化流程</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#method-t结构" class="sidebar-link">method_t结构</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#category-t结构-运行时确定" class="sidebar-link">category_t结构(运行时确定)</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#class-ro-t结构-与宿主类相关-编译时确定-只读" class="sidebar-link">classrot结构(与宿主类相关，编译时确定，只读)</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#class-rw-t结构-运行时确定" class="sidebar-link">classrwt结构(运行时确定)</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#class-data-bits-t结构-8字节" class="sidebar-link">classdatabits_t结构(8字节)</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#cache-t结构-16字节" class="sidebar-link">Cache_t结构(16字节)</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#objc-class-class-40字节" class="sidebar-link">objc_class/Class(40字节)</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#objc-object" class="sidebar-link">objc_object</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#union-isa-t" class="sidebar-link">union isa_t</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#init调用流程" class="sidebar-link">init调用流程</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#alloc调用流程" class="sidebar-link">alloc调用流程</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#alloc对比" class="sidebar-link">alloc对比</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#nsstring的子类" class="sidebar-link">NSString的子类</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#nsnumber子类" class="sidebar-link">NSNumber子类</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#nszone" class="sidebar-link">NSZone</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#size" class="sidebar-link">size</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#id-2" class="sidebar-link">id</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#对象objc-object、类对象objc-class、元类对象objc-class的区别" class="sidebar-link">对象objcobject、类对象objcclass、元类对象objc_class的区别</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#内存管理方案" class="sidebar-link">内存管理方案</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#kvo" class="sidebar-link">KVO</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/iOS细节.html#synthesize" class="sidebar-link">@synthesize</a></li></ul></li><li><a href="/iOS笔记/iOS性能优化.html" class="sidebar-link">iOS性能优化</a></li><li><a href="/iOS笔记/LFLiveKit.html" class="sidebar-link">LFLiveKit</a></li><li><a href="/iOS笔记/Metal.html" class="sidebar-link">Metal</a></li><li><a href="/iOS笔记/Objective-C.html" class="sidebar-link">Objective-C</a></li><li><a href="/iOS笔记/OpenGL相关概念.html" class="sidebar-link">OpenGL相关概念</a></li><li><a href="/iOS笔记/pthread.html" class="sidebar-link">pthread</a></li><li><a href="/iOS笔记/ReactNative.html" class="sidebar-link">React Native</a></li><li><a href="/iOS笔记/RunLoop.html" class="sidebar-link">RunLoop</a></li><li><a href="/iOS笔记/UI视图.html" class="sidebar-link">UI视图</a></li><li><a href="/iOS笔记/VideoToolbox.html" class="sidebar-link">VideoToolbox</a></li><li><a href="/iOS笔记/WebAssembly.html" class="sidebar-link">WebAssembly</a></li><li><a href="/iOS笔记/WebRTC.html" class="sidebar-link">WebRTC</a></li><li><a href="/iOS笔记/第三方.html" class="sidebar-link">第三方</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="ios细节"><a href="#ios细节" class="header-anchor">#</a> iOS细节</h1> <h2 id="self和super的区别"><a href="#self和super的区别" class="header-anchor">#</a> self和super的区别</h2> <h3 id="self是对象指针"><a href="#self是对象指针" class="header-anchor">#</a> self是对象指针</h3> <h3 id="super是结构体"><a href="#super是结构体" class="header-anchor">#</a> super是结构体</h3> <ul><li><p>struct objc_super</p> <ul><li><p>id receiver;</p> <ul><li>消息接收者为self</li></ul></li> <li><p>Class super_class</p> <ul><li>父类对象指针</li></ul></li></ul></li> <li><p>表示从父类开始查找方法，但是消息的接收者仍然是self</p></li></ul> <h3 id="我们到父类中打印self-发现当前类的self和父类的self的地址是相同的-因为当前类self本来就是一层一层通过父类传递下来的-最终创建者是oc底层代码calloc开辟的内存空间"><a href="#我们到父类中打印self-发现当前类的self和父类的self的地址是相同的-因为当前类self本来就是一层一层通过父类传递下来的-最终创建者是oc底层代码calloc开辟的内存空间" class="header-anchor">#</a> 我们到父类中打印self，发现当前类的self和父类的self的地址是相同的，因为当前类self本来就是一层一层通过父类传递下来的，最终创建者是OC底层代码calloc开辟的内存空间</h3> <ul><li><p>self创建流程</p> <ul><li>通过class_ro_t取得实例大小</li> <li>通过calloc开辟内存空间</li> <li>初始化isa指针</li></ul></li></ul> <h3 id="self-class-和-super-class-结果都是当前类名"><a href="#self-class-和-super-class-结果都是当前类名" class="header-anchor">#</a> [self class]和[super class]结果都是当前类名</h3> <ul><li>因为self和<code>super</code>对象地址(对象地址里面存了isa指针、自定义的基本数据类型、其他自定义的对象指针)相同，所以等价于[self class]和[<code>self</code> class]，都是通过相同的isa指针到类对象当中查找对于的“class”方法(先查找缓存、然后查找class_rw_t，然后通过superclass指针到父类中查找)，依次查找父类直到NSObject。</li></ul> <h2 id="category"><a href="#category" class="header-anchor">#</a> Category</h2> <h3 id="分类可以添加"><a href="#分类可以添加" class="header-anchor">#</a> 分类可以添加</h3> <ul><li>protocol</li> <li>property(settter/getter)</li> <li>function</li></ul> <h3 id="运行时附加到宿主类"><a href="#运行时附加到宿主类" class="header-anchor">#</a> 运行时附加到宿主类</h3> <h2 id="返回类型"><a href="#返回类型" class="header-anchor">#</a> 返回类型</h2> <h3 id="id"><a href="#id" class="header-anchor">#</a> id</h3> <ul><li>表示任意类型</li></ul> <h3 id="instancetype"><a href="#instancetype" class="header-anchor">#</a> instancetype</h3> <ul><li><p>建议使用instancetype作为alloc和init的返回值而不要使用id作为返回值，因为instancetype会做类型判断，而id不会做类型判断，在使用id调用方法时可能是任意的，因为其他类可能包含同名方法。</p></li> <li><p>提高OC代码的类型安全性</p></li> <li><p>仅用于返回值的类型</p> <ul><li><p>返回值的类型为何用instancetype而不用id?</p> <ul><li>instancetype表示返回的是与当前类相关的对象，编译器会做类型检查，类型更安全</li></ul></li> <li><p>返回值的类型为何用instancetype而不用具体的类名，具体的类名不是类型更安全吗？</p> <ul><li>如果在子类中调用该方法或者子类重写了该方法，那么该方法返回的类型是父类的实例，而不是具体的子类实例</li></ul></li></ul></li></ul> <h2 id="extension"><a href="#extension" class="header-anchor">#</a> Extension</h2> <h3 id="编译时附加到宿主类"><a href="#编译时附加到宿主类" class="header-anchor">#</a> 编译时附加到宿主类</h3> <h3 id="扩展可以添加"><a href="#扩展可以添加" class="header-anchor">#</a> 扩展可以添加</h3> <ul><li>protocol</li> <li>property</li> <li>function</li></ul> <h2 id="self-alloc-init-和-myobject-alloc-init-区别"><a href="#self-alloc-init-和-myobject-alloc-init-区别" class="header-anchor">#</a> [[self alloc] init]和[[MyObject alloc]init]区别</h2> <h3 id="如果在子类的init中调用父类的init方法-如果父类中使用-self-class-时-编译器可以确定初始化类型为子类-那么可以调用子类的方法"><a href="#如果在子类的init中调用父类的init方法-如果父类中使用-self-class-时-编译器可以确定初始化类型为子类-那么可以调用子类的方法" class="header-anchor">#</a> 如果在子类的init中调用父类的init方法，如果父类中使用[self class]时，编译器可以确定初始化类型为子类，那么可以调用子类的方法</h3> <h3 id="如果父类中使用具体的类名进行的初始化-那么在调用父类的初始化方法时-会初始化成父类对象-调用子类方法时会发生崩溃"><a href="#如果父类中使用具体的类名进行的初始化-那么在调用父类的初始化方法时-会初始化成父类对象-调用子类方法时会发生崩溃" class="header-anchor">#</a> 如果父类中使用具体的类名进行的初始化，那么在调用父类的初始化方法时，会初始化成父类对象，调用子类方法时会发生崩溃</h3> <h3 id="通常单例返回值是instancetype-而内部初始化使用-self-alloc-使用-self-alloc-可以保证在子类当中进行初始化时返回的仍然是子类对象"><a href="#通常单例返回值是instancetype-而内部初始化使用-self-alloc-使用-self-alloc-可以保证在子类当中进行初始化时返回的仍然是子类对象" class="header-anchor">#</a> 通常单例返回值是instancetype，而内部初始化使用[self alloc]，使用[self alloc]可以保证在子类当中进行初始化时返回的仍然是子类对象</h3> <h2 id="properties"><a href="#properties" class="header-anchor">#</a> properties</h2> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <ul><li>自动生成getter和setter</li> <li>直观的确定附加信息</li></ul> <h2 id="关键字"><a href="#关键字" class="header-anchor">#</a> 关键字</h2> <h3 id="读写权限"><a href="#读写权限" class="header-anchor">#</a> 读写权限</h3> <ul><li>readwrite(默认)</li> <li>readonly</li></ul> <h3 id="原子性"><a href="#原子性" class="header-anchor">#</a> 原子性</h3> <ul><li><p>atomic(默认)</p> <ul><li><p>只是setter/getter线程安全，意思是只保证了数据的完整性，不至于崩溃，但是无法保证多个线程读写的线程安全，如果在多个线程进行读写操作，那么结果是不确定的。</p> <ul><li>dispatch_async(queue1, ^{
for (int i = 0; i &lt; 10000; i++) {
self.intSource++;
}
NSLog(@&quot;++%d&quot;, self.intSource);
});</li></ul></li></ul> <p>dispatch_async(queue2, ^{
for (int i = 0; i &lt; 10000; i++) {
self.intSource++;
}
NSLog(@&quot;--%d&quot;, self.intSource);
});</p></li> <li><p>nonatomic</p></li></ul> <h3 id="引用计数"><a href="#引用计数" class="header-anchor">#</a> 引用计数</h3> <ul><li><p>strong</p> <ul><li>引用计数+1，iOS默认是strong类型，所有的赋值操作默认都是strong</li></ul></li> <li><p>assign</p> <ul><li>即可修饰基本数据类型，也可修饰对象</li> <li>不改变引用计数，但是在原对象释放后，assign对象不会释放</li></ul></li> <li><p>weak/__weak</p> <ul><li>只能修饰对象</li> <li>不改变原对象的引用计数，在原对象释放后，weak变量会被自动置为nil。weak对象本身引用计数会+1，原对象引用计数不变</li> <li>对weak变量进行strong操作后，如果原对象被释放，那么weak变量置为nil，但是strong变量仍然存在，因为weak置为nil后，strong变量的引用计数只是从2变为1，有时候我们需要在block当中对weak变量进行strong，是因为多线程情况下，如果原对象被释放，如果想要block中的weak仍然存在，只能进行strong操作，对于单线程则没必要</li></ul></li> <li><p>copy</p> <ul><li>对于不可变的对象进行copy操作是浅拷贝，只是增加了引用计数，和strong没区别</li> <li>对于可变对象进行copy操作是深拷贝，copy之后是两个不同的对象</li></ul></li> <li><p>mutableCopy</p> <ul><li>操作均是深拷贝，拷贝之后是不同的对象</li></ul></li></ul> <h3 id="block"><a href="#block" class="header-anchor">#</a> __block</h3> <ul><li><p>对被截获变量进行赋值操作需要使用__block</p></li> <li><p>使用</p> <ul><li>局部基本变量或者对象</li></ul></li> <li><p>__block修饰的变量变成了对象</p></li> <li><p>会增加原对象的引用计数+1，自己的引用计数也会+1</p></li> <li><p>__block结构体内部会有一个__forwarding指针，__forwarding存在的意义是让任何使用了__block变量的block都能通过__forwarding指针访问__block变量</p></li></ul> <h3 id="nil"><a href="#nil" class="header-anchor">#</a> nil</h3> <ul><li>将对象置为nil实际上只是将原对象引用计数-1</li> <li>向nil对象发送消息不会crash，但是向一个dealloc之后的对象发送消息会crash，这就是为什么weak修饰的变量，在原对象释放后runtime要自动置为nil的原因</li></ul> <h3 id="unsafe-unretained-unowned"><a href="#unsafe-unretained-unowned" class="header-anchor">#</a> __unsafe_unretained/unowned</h3> <ul><li>不会增加原对象的引用计数，但是依旧会增加自身的引用计数，和weak一样</li> <li>和__weak不同的是，__unsafe_unretained不会使用弱引用表管理，所以需要进行手动置为nil，否则会造成内存泄漏，因为此时__unsafe_unretained指向一个已经释放的对象</li></ul> <h3 id="property-nonatomic-copy-people-obj22"><a href="#property-nonatomic-copy-people-obj22" class="header-anchor">#</a> @property (nonatomic, copy) People *obj22;</h3> <ul><li>property中的copy应该默认实现了NSCopying协议，协议内容只是引用计数+1，所以不会crash</li> <li>如果是我们自己调用[obj copy]，则必须实现NSCopying协议，否则会crash，数组、字典、字符串默认都实现了NSCopying和NSMutableCopying</li></ul> <h2 id="block理解"><a href="#block理解" class="header-anchor">#</a> block理解</h2> <h3 id="通过block源码-我们可以发现-对于局部变量-block会将其当做参数传入block结构体"><a href="#通过block源码-我们可以发现-对于局部变量-block会将其当做参数传入block结构体" class="header-anchor">#</a> 通过block源码，我们可以发现，对于局部变量，block会将其当做参数传入block结构体</h3> <ul><li>如果局部变量是基本数据类型，在block初始化之后改变其值时，我们在block内部无法获取最新值，因为基本数据类型在block初始化期间已经确定</li> <li>如果局部变量时指针类型，在block之后改变其指向的值时，block内部可以获取到新的值，因为block传入的参数是指针</li></ul> <h3 id="如果是静态局部变量-block会将它的指针当做参数传入block结构体"><a href="#如果是静态局部变量-block会将它的指针当做参数传入block结构体" class="header-anchor">#</a> 如果是静态局部变量，block会将它的指针当做参数传入block结构体</h3> <ul><li>所以我们在block初始化之后改变其值时，block获取的到值是改变后的值</li></ul> <h3 id="如果是全局变量或者静态全局变量-block不会将它当做参数传入block-而是会直接使用-因为是全局的"><a href="#如果是全局变量或者静态全局变量-block不会将它当做参数传入block-而是会直接使用-因为是全局的" class="header-anchor">#</a> 如果是全局变量或者静态全局变量，block不会将它当做参数传入block，而是会直接使用，因为是全局的</h3> <ul><li>不管全局变量是基本数据类型还是指针类型，我们都可以在block初始化之后改变它的值，而使block内部取值发生变量</li></ul> <h3 id="外部变量"><a href="#外部变量" class="header-anchor">#</a> 外部变量</h3> <ul><li><p>外部变量使用__block修饰</p> <ul><li>在block内部操作外部变量不会增加外部变量的引用计数，原因在于外部变量会存储于__block结构体的__forwarding指针内，后续传递到block结构体内部的是__block结构体，而不是外部变量本身。所以不会增加它的引用计数，如果在内部进行赋值，则会增加引用计数</li></ul></li> <li><p>外部变量不使用__block修饰</p> <ul><li>在block内部操作外部变量，会增加2次外部变量的引用计数(weak变量除外)，原因在于外部对象会以指针形式作为参数传入结构体block_impl_0的构造函数，这是第一次引用计数+1，然后在构造函数内会将外部变量指针存储到结构体当中，这是第二次引用计数+1</li></ul></li></ul> <h3 id="impl-isa-nsconcretestackblock"><a href="#impl-isa-nsconcretestackblock" class="header-anchor">#</a> impl.isa = &amp;_NSConcreteStackBlock;</h3> <ul><li><p>栈block</p> <ul><li>__block int a = 10;</li></ul></li></ul> <h3 id="impl-isa-nsconcretestackblock-2"><a href="#impl-isa-nsconcretestackblock-2" class="header-anchor">#</a> impl.isa = &amp;_NSConcreteStackBlock;</h3> <ul><li>堆block</li></ul> <h3 id="impl-isa-nsconcretestackblock-3"><a href="#impl-isa-nsconcretestackblock-3" class="header-anchor">#</a> impl.isa = &amp;_NSConcreteStackBlock;</h3> <ul><li>全局block</li></ul> <h3 id="如果block中使用了成员变量-那么会将self指针当做参数传递给block结构体-此时block结构体引用了self。如果再将block当做self的成员变量-那么self又引用了block-会形成循环引用"><a href="#如果block中使用了成员变量-那么会将self指针当做参数传递给block结构体-此时block结构体引用了self。如果再将block当做self的成员变量-那么self又引用了block-会形成循环引用" class="header-anchor">#</a> 如果block中使用了成员变量，那么会将self指针当做参数传递给block结构体，此时block结构体引用了self。如果再将block当做self的成员变量，那么self又引用了block，会形成循环引用</h3> <h3 id="单线程中使用-unsafe-unretained-unowned-weak效果是一样的"><a href="#单线程中使用-unsafe-unretained-unowned-weak效果是一样的" class="header-anchor">#</a> 单线程中使用__unsafe_unretained/unowned/__weak效果是一样的</h3> <h2 id="变量和常量"><a href="#变量和常量" class="header-anchor">#</a> 变量和常量</h2> <h3 id="static和auto变量"><a href="#static和auto变量" class="header-anchor">#</a> static和auto变量</h3> <ul><li>不难看出，二者都是变量，所以可以赋值多次</li> <li>但是static只会初始化一次(即只会在第一次定义时有效，多次定义无效)，但是static是可以多次赋值的，意思就是static int a = 10;只会调用一次，但是可以对a进行多次赋值。</li></ul> <h3 id="const常量"><a href="#const常量" class="header-anchor">#</a> const常量</h3> <ul><li>只能赋值一次</li></ul> <h2 id="常见的crash"><a href="#常见的crash" class="header-anchor">#</a> 常见的crash</h2> <h3 id="_1-向dealloc对象发送消息"><a href="#_1-向dealloc对象发送消息" class="header-anchor">#</a> 1.向dealloc对象发送消息</h3> <h3 id="_2-调用一个没有实现的方法"><a href="#_2-调用一个没有实现的方法" class="header-anchor">#</a> 2.调用一个没有实现的方法</h3> <h3 id="_3-向数组或者字典插入nil"><a href="#_3-向数组或者字典插入nil" class="header-anchor">#</a> 3.向数组或者字典插入nil</h3> <h2 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h2> <h3 id="gcd"><a href="#gcd" class="header-anchor">#</a> GCD</h3> <ul><li><p>并发队列</p> <p>提交到队列中的任务可以并发执行</p> <ul><li>dispatch_get_global_queue</li> <li>dispatch_queue_create(&quot;com.apple.root.default-qos&quot;, DISPATCH_QUEUE_CONCURRENT);</li></ul></li> <li><p>串行队列</p> <ul><li>dispatch_get_main_queue</li> <li>dispatch_queue_create(&quot;com.apple.root.default-qos&quot;, DISPATCH_QUEUE_SERIAL);</li></ul></li> <li><p>sync</p> <ul><li><p>不开启新线程</p> <ul><li>交出当前任务的时间片交给串行队列或者并行队列，如果是串行队列，这串行执行任务，如果是并行队列，则每个任务使用一定的CPU时间片同时执行。</li> <li>例如dispatch_sync(dispatch_queue_create(&quot;com.apple&quot;, NULL), ^{</li></ul></li></ul> <p>});</p> <div class="language- extra-class"><pre><code>  	- 首先调用者交出当前线程的时间片，然后交给串行队列串行执行

  - dispatch_sync(dispatch_queue_create(&quot;com.apple&quot;, DISPATCH_QUEUE_CONCURRENT), ^{
</code></pre></div><p>});</p> <div class="language- extra-class"><pre><code>  	- 首先调用者交出当前线程的时间片，然后交给并发队列并发执行
</code></pre></div></li> <li><p>async</p> <ul><li><p>如果是并发队列，则会开启新线程，执行顺序不确定，例如</p> <ul><li><div class="language- extra-class"><pre><code>dispatch_async(dispatch_get_global_queue(0, 0), ^{
</code></pre></div></li></ul></li></ul> <p>});</p> <div class="language- extra-class"><pre><code>  	- 开启新线程，不会交出主线程的时间片，并且并发的在子线程中执行任务
</code></pre></div><ul><li><p>如果是我们自己创建串行队列，也会开启新线程，串行执行scope任务，例如</p> <ul><li>dispatch_queue_t queue_serial = dispatch_queue_create(&quot;com.apple.root.default-qos&quot;, NULL);
dispatch_async(queue_serial, ^{</li></ul></li></ul> <p>});</p> <div class="language- extra-class"><pre><code>  	- 开启新线程，不会交出主线程时间片，并且在子线程中串行的执行任务
</code></pre></div><ul><li><p>如果是主队列，则不会开启新线程，例如</p> <ul><li>dispatch_async(dispatch_get_main_queue(), ^{</li></ul></li></ul> <p>});</p> <div class="language- extra-class"><pre><code>  	- 不会开启新线程，将任务交到主线程中串行执行
</code></pre></div></li> <li><p>队列和线程是两个概念，线程总是被动开启</p></li> <li><p>dispatch_barrier_async</p> <ul><li><p>特性</p> <ul><li>之前添加的任务执行完成后才会执行dispatch_barrier_async的任务，然后执行dispatch_barrier_async之后的任务，dispatch_barrier_async就是一个任务执行的分界线</li> <li>通常dispatch_barrier_async都是添加自己创建的并发队列</li> <li>如果添加串行队列，那么就会在新线程中串行执行任务，相当于dispatch_sync</li> <li>如果添加全局并发队列是不可取的，因为苹果会在全局队列中添加自己的任务</li></ul></li> <li><p>通常用于数据库的多读单写操作</p></li></ul></li> <li><p>dispatch_barrier_sync同步执行</p></li> <li><p>dispatch_group_async(只有异步)</p> <ul><li>dispatch_group_async(group, concurrent_queue, ^{</li></ul> <p>});</p> <div class="language- extra-class"><pre><code>  - 将任务添加到异步队列中并发执行
</code></pre></div><ul><li>dispatch_group_notify(group, dispatch_get_main_queue(), ^{</li></ul> <p>});</p> <div class="language- extra-class"><pre><code>  - 等待上面任务执行完后再执行当前任务
  - dispatch_group_notify也是异步的
</code></pre></div></li> <li><p>取消gcd</p> <ul><li>dispatch_block_cancel(block)</li> <li>外部变量</li></ul></li> <li><p>挂起</p> <ul><li>dispatch_suspend(queue)</li></ul></li> <li><p>恢复</p> <ul><li>dispatch_resume(queue)</li></ul></li> <li><p>缺点</p> <ul><li>线程爆炸</li> <li>死锁</li> <li>优先级反转</li></ul></li></ul> <h3 id="nsoperation"><a href="#nsoperation" class="header-anchor">#</a> NSOperation</h3> <ul><li><p>优点</p> <ul><li><p>可以添加任务依赖</p></li> <li><p>可以控制任务状态</p> <ul><li>isReady</li> <li>isExcuting</li> <li>isFinished</li> <li>isCancelled</li></ul></li> <li><p>可以设置最大并发量</p></li></ul></li> <li><p>重写main方法</p> <ul><li>底层控制变更任务执行完成状态，以及任务退出</li></ul></li> <li><p>重写start方法</p> <ul><li>自行控制任务状态</li></ul></li></ul> <h3 id="nsthread"><a href="#nsthread" class="header-anchor">#</a> NSThread</h3> <h3 id="同步"><a href="#同步" class="header-anchor">#</a> 同步</h3> <ul><li><p>原子操作</p></li> <li><p>锁</p></li> <li><p>条件</p></li> <li><p>selector</p></li> <li><p>缺点</p> <ul><li><p>优先级反转</p> <ul><li><p>低中高三个线程依次执行，在低优先级的线程释放同步资源前，中高线程需要等待，在低优先级的线程释放同步资源后，高优先级的任务还需要等待中优先级的任务执行完才能拿到资源，这就是优先级反转</p></li> <li><p>解决办法</p> <ul><li><p>优先级继承</p> <ul><li>将低优先级的任务提升到高优先级的水平，让其先执行完释放同步资源后再恢复其优先级，此时高优先级的任务可以获得同步资源继续执行</li></ul></li> <li><p>优先级天花板</p> <ul><li>将访问共享资源的线程提升到最高优先级，同时却会带来一个问题，会阻塞高优先级的任务</li></ul></li></ul></li></ul></li> <li><p>死锁</p></li> <li><p>性能问题</p></li> <li><p>线程饥饿</p> <ul><li>线程一直被高优先级的线程抢占锁和时间片</li></ul></li></ul></li></ul> <h3 id="通信"><a href="#通信" class="header-anchor">#</a> 通信</h3> <ul><li>source</li> <li>selector</li> <li>变量</li> <li>条件变量</li> <li>socket</li> <li>共享内存</li></ul> <h3 id="优点-2"><a href="#优点-2" class="header-anchor">#</a> 优点</h3> <ul><li>共享内存</li> <li>相比进程更加轻量级</li></ul> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <ul><li>资源竞争</li> <li>线程上下文切换开销</li></ul> <h2 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h2> <h3 id="自旋锁"><a href="#自旋锁" class="header-anchor">#</a> 自旋锁</h3> <p>自旋锁加锁的时候，等待锁的线程处于忙等状态，并且占用着CPU的资源</p> <ul><li><p>当预计线程等待锁的时间很短，或者加锁的代码（临界区）经常被调用，但竞争情况很少发生，再或者CPU资源不紧张，拥有多核处理器的时候使用自旋锁比较合适。</p></li> <li><p>OSSpinLock   --  deprecated: 10.0</p> <ul><li>非线程安全，因为有潜在的优先级反转问题</li></ul></li> <li><p>os_unfair_lock</p></li></ul> <h3 id="互斥锁"><a href="#互斥锁" class="header-anchor">#</a> 互斥锁</h3> <p>互斥锁加锁的时候，等待锁的线程处于休眠状态，不会占用CPU资源</p> <ul><li>NSLock</li> <li>@synchronized</li></ul> <h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="header-anchor">#</a> dispatch_semaphore</h3> <h3 id="nscondition"><a href="#nscondition" class="header-anchor">#</a> NSCondition</h3> <h3 id="nsconditionlock"><a href="#nsconditionlock" class="header-anchor">#</a> NSConditionLock</h3> <h3 id="nsrecursivelock"><a href="#nsrecursivelock" class="header-anchor">#</a> NSRecursiveLock</h3> <h3 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h3> <ul><li>常规和 while 循环加锁使用 pthread_mutex。</li> <li>队列（dispatch_get_global_queue）并发线程数控制，使用 dispatch_semaphore。</li></ul> <h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="header-anchor">#</a> 死锁的必要条件</h3> <ul><li>互斥</li> <li>不剥夺</li> <li>循环等待</li> <li>请求且保持</li></ul> <h3 id="预防死锁"><a href="#预防死锁" class="header-anchor">#</a> 预防死锁</h3> <ul><li><p>破坏不剥夺条件</p> <ul><li>在线程拿到资源后，如果再还需要再去申请新的资源无法申请到，那么就释放所有资源</li></ul></li> <li><p>破坏请求且保持</p> <ul><li>一次性申请所有资源</li></ul></li> <li><p>破坏循环等待条件</p> <ul><li>对资源进行排号，若线程获得序号高的资源想要再获取序号低的资源，就需要先释放序号高的资源</li></ul></li></ul> <h3 id="解锁"><a href="#解锁" class="header-anchor">#</a> 解锁</h3> <ul><li><p>抢占资源</p> <ul><li>从一个或多个线程中抢占足够数量的资源，分配给死锁线程</li></ul></li> <li><p>终止线程</p> <ul><li>将一个或多个死锁线程终止</li></ul></li></ul> <h2 id="swift指针"><a href="#swift指针" class="header-anchor">#</a> Swift指针</h2> <h3 id="unsafepointer类似于const-pointee"><a href="#unsafepointer类似于const-pointee" class="header-anchor">#</a> UnsafePointer<Pointee>类似于const Pointee *</Pointee></h3> <h3 id="unsafemutablepointer类似于pointee"><a href="#unsafemutablepointer类似于pointee" class="header-anchor">#</a> UnsafeMutablePointer<Pointee>类似于Pointee *</Pointee></h3> <h3 id="unsaferawpointer类似于const-void"><a href="#unsaferawpointer类似于const-void" class="header-anchor">#</a> UnsafeRawPointer类似于const void *</h3> <h3 id="unsafemutablerawpointer类似于void"><a href="#unsafemutablerawpointer类似于void" class="header-anchor">#</a> UnsafeMutableRawPointer类似于void *</h3> <h2 id="urlsession"><a href="#urlsession" class="header-anchor">#</a> URLSession</h2> <h3 id="大文件下载-存cache文件夹"><a href="#大文件下载-存cache文件夹" class="header-anchor">#</a> 大文件下载，存cache文件夹</h3> <ul><li>URLSessionDownloadTask</li></ul> <h3 id="小文件下载-存内存"><a href="#小文件下载-存内存" class="header-anchor">#</a> 小文件下载，存内存</h3> <ul><li>URLSessionDataTask</li></ul> <h2 id="runloop"><a href="#runloop" class="header-anchor">#</a> RunLoop</h2> <h3 id="内核态"><a href="#内核态" class="header-anchor">#</a> 内核态</h3> <ul><li>I/O指令、清内存、设置时钟</li> <li>中断、异常、陷入</li> <li>线程管理</li> <li>系统调用</li> <li>用户内存地址的转换(逻辑---&gt;物理映射)</li></ul> <h3 id="source0"><a href="#source0" class="header-anchor">#</a> source0</h3> <ul><li>UIEvent(触摸、滑动)、performSelector等等，需要手动触发</li></ul> <h3 id="source1"><a href="#source1" class="header-anchor">#</a> source1</h3> <ul><li>处理系统内核的mach_msg事件</li></ul> <h3 id="runloop状态"><a href="#runloop状态" class="header-anchor">#</a> RunLoop状态</h3> <ul><li><p>kCFRunLoopEntry</p> <ul><li>准备启动RunLoop</li></ul></li> <li><p>kCFRunLoopBeforeTimers</p> <ul><li>将要处理Timer</li></ul></li> <li><p>kCFRunLoopBeforeSources</p> <ul><li>将要处理Sources</li></ul></li> <li><p>KCFRunLoopBeforeWaiting</p> <ul><li><p>将要进入休眠</p> <ul><li>释放autorelease对象</li> <li>图像的绘制</li></ul></li></ul></li> <li><p>KCFRunLoopAfterWaiting</p> <ul><li>将要唤醒</li></ul></li> <li><p>KCFRunLoopExit</p> <ul><li>RunLoop将要退出</li></ul></li></ul> <h3 id="多个model"><a href="#多个model" class="header-anchor">#</a> 多个model</h3> <ul><li><p>Source(输入源)</p> <ul><li>I/O事件</li></ul></li> <li><p>Timer(定时源)</p> <ul><li>performSelector</li></ul></li> <li><p>Observer</p></li></ul> <h3 id="一个线程"><a href="#一个线程" class="header-anchor">#</a> 一个线程</h3> <h3 id="退出机制"><a href="#退出机制" class="header-anchor">#</a> 退出机制</h3> <ul><li><p>移除input sources或者timer</p> <ul><li>并不能保证退出，系统可能会添加输入源</li></ul></li> <li><p>设置超时时间或者添加一个定时源</p></li> <li><p>强制退出线程</p> <ul><li>并不能让RunLoop，还可能会造成内存泄漏</li></ul></li> <li><p>CFRunLoopStop</p> <ul><li>系统会重复调用runMode:beforeDate:所以也不能退出RunLoop</li></ul></li></ul> <h2 id="对象"><a href="#对象" class="header-anchor">#</a> 对象</h2> <h3 id="用户创建的对象"><a href="#用户创建的对象" class="header-anchor">#</a> 用户创建的对象</h3> <ul><li>alloc</li> <li>new</li> <li>copy</li> <li>mutableCopy</li></ul> <h3 id="系统创建的对象"><a href="#系统创建的对象" class="header-anchor">#</a> 系统创建的对象</h3> <ul><li><p>[NSArray array]/[NSMutableArray array]</p> <ul><li><ul><li><p>(id) array {//系统内部的MRC实现
return [[[NSMutableArray alloc] init] autorelease];
}</p> <ul><li>在MRC下，我们在return一个对象时，通常要使用autorelease进行释放，如果我们要保留array返回的对象不进行释放，那么需要retain操作，显然这种情况下即调用autorelease又调用retain有点多余，所以在ARC下系统为我们做了优化</li></ul></li></ul></li> <li><ul><li><p>(id) array {//系统内部的ARC实现
NSMutableArray *arr = [[NSMutableArray alloc] init];
objc_autoreleaseReturnValue(arr);
}</p> <ul><li><p>在ARC下，对象的赋值操作默认是strong(保留)，如果在array当中直接调用autorelease，那么在赋值时又要调用retain，非常多余，所以有了objc_autoreleaseReturnValue，这个函数的作用是如果返回值被强引用，即需要retain，那么不调用autorelease，而是设置全局数据结构中的标志位，如果返回值被弱引用(即不需要retain)，那么将调用autorelease，在一个事件循环后释放。</p> <ul><li>向后兼容</li></ul></li> <li><p>如果恰好返回值被弱引用(即返回值包含autorelease)，此时我们如果再需要进行强引用会直接retain吗？显然直接retain会影响效率，系统会去检测标志位，若标志位已经置位，则直接返回对象，否则进行retain操作</p></li></ul></li></ul></li></ul></li> <li><p>[NSDictionary dict]/[NSMutableDictionary dict]</p></li> <li><p>...</p></li></ul> <h2 id="autoreleasepool"><a href="#autoreleasepool" class="header-anchor">#</a> autoreleasePool</h2> <h3 id="哪些对象会被注册到autoreleasepool"><a href="#哪些对象会被注册到autoreleasepool" class="header-anchor">#</a> 哪些对象会被注册到autoreleasePool？</h3> <ul><li><p>系统创建的对象</p></li> <li><p>__autoreleasing对象</p></li> <li><p>访问附有__weak修饰符的变量时，实际上必定要访问注册到Autoreleasepool的对象，即会自动加入Autoreleasepool</p> <ul><li><p>如何理解？</p> <ul><li><p>其实__weak变量的底层就是autorelease，所以也会被加入到autoreleasePool，这里可以引申出一个细节问题，在block中使用weakSelf时，如果需要延长self的使用寿命是否需要strongSelf？如果是同一个线程那么不需要strongSelf也能保证block中的weakSelf执行完毕，如果是多线程那么必须要在block中strongSelf才能保证block中的self执行完毕，分析一下</p> <ul><li><p>block单线程执行</p> <ul><li>如果是单线程执行block，那么必然在初始化weakSelf时，self是没有被释放的，不然也没有在block中调用的意义，我们知道weak变量是通过autorelease进行释放的，所以如果是单线程，那么在block执行完之前，runloop不会进入休眠，此时weakSelf也不会被释放，所以可以保证block中的weakSelf不为nil</li></ul></li> <li><p>block多线程执行</p> <ul><li>多线程执行block时，如果原对象被释放，恰好runloop即将进入休眠时，weakSelf可能已经为nil，如果要保证block中self不为nil，则必须在block初始化(即block内部调用strong)时进行一次strong操作</li></ul></li></ul></li></ul></li></ul></li> <li><p>id指针会默认附加__autoreleasing</p> <ul><li>经过验证这句话是错的，后续再验证</li></ul></li> <li><p>指向对象的指针(即双指针id *, NSError **)也会默认附加__autoreleasing</p> <ul><li>未验证</li></ul></li></ul> <h3 id="每一个-autoreleasepool-都会在左花括号时创建autoreleasepoolpush-并在右花括号时调用autoreleasepoolpop进行释放-主线程的autoreleasepool总是在创建和销毁-这是因为runloop的存在"><a href="#每一个-autoreleasepool-都会在左花括号时创建autoreleasepoolpush-并在右花括号时调用autoreleasepoolpop进行释放-主线程的autoreleasepool总是在创建和销毁-这是因为runloop的存在" class="header-anchor">#</a> 每一个@autoreleasePool{}都会在左花括号时创建autoreleasePoolPush，并在右花括号时调用autoreleasePoolPop进行释放，主线程的autoreleasePool总是在创建和销毁，这是因为runloop的存在</h3> <h3 id="主线程和gcd"><a href="#主线程和gcd" class="header-anchor">#</a> 主线程和GCD</h3> <ul><li>主线程会注册两个observer，第一个observer监视runloop的entry(entry只会调用一次)，用来创建第一个自动释放池，并将其优先级设置为最高。第二个observer监视BeforeWaiting(即将进入休眠)，此时释放旧池创建新池(第二个observer第一次释放的旧池是第一个observer创建的)，并将第二个observer的优先级设置为最低以保证释放尺子发生在其他所有回调之后，往后依次重复该行为。</li></ul> <h3 id="nsoperation-2"><a href="#nsoperation-2" class="header-anchor">#</a> NSOperation</h3> <ul><li>NSOperation的start方法中已经创建了autoreleasePool，如果重写start方法则需要创建自己的autoreleasePool</li></ul> <h3 id="nsthread-2"><a href="#nsthread-2" class="header-anchor">#</a> NSThread</h3> <ul><li>会在init当中创建autoreleasePool</li></ul> <h3 id="每一个autoreleasepool是由autoreleasepoolpage组成的双向链表-通过autorelease操作将对象插入到链表当中-在pop时对其中的所有对象进行一次release操作"><a href="#每一个autoreleasepool是由autoreleasepoolpage组成的双向链表-通过autorelease操作将对象插入到链表当中-在pop时对其中的所有对象进行一次release操作" class="header-anchor">#</a> 每一个autoreleasePool是由AutoreleasePoolPage组成的双向链表，通过autorelease操作将对象插入到链表当中，在pop时对其中的所有对象进行一次release操作</h3> <h3 id="如果没有其他事件阻止runloop进入休眠-那么在viewwillappear时runloop还未进入休眠-此时autorelease对象还未被释放-在viewdidappear时runloop即将进入休眠-此时autorelease对象在调用viewdidappear前已经被系统的observer释放"><a href="#如果没有其他事件阻止runloop进入休眠-那么在viewwillappear时runloop还未进入休眠-此时autorelease对象还未被释放-在viewdidappear时runloop即将进入休眠-此时autorelease对象在调用viewdidappear前已经被系统的observer释放" class="header-anchor">#</a> 如果没有其他事件阻止runloop进入休眠，那么在viewWillAppear时runloop还未进入休眠，此时autorelease对象还未被释放，在viewDidAppear时runloop即将进入休眠，此时autorelease对象在调用viewDidAppear前已经被系统的observer释放</h3> <h3 id="main函数的autoreleasepool和主线程的autoreleasepool是否是同一个"><a href="#main函数的autoreleasepool和主线程的autoreleasepool是否是同一个" class="header-anchor">#</a> main函数的autoreleasepool和主线程的autoreleasepool是否是同一个？</h3> <ul><li>应该不是，main函数的autoreleasepool应该是对系统资源的释放，而主线程的autoreleasepool是动态创建和销毁的</li></ul> <h3 id="如果子线程没有创建runloop-那么autorelease对象何时释放"><a href="#如果子线程没有创建runloop-那么autorelease对象何时释放" class="header-anchor">#</a> 如果子线程没有创建runloop，那么autorelease对象何时释放？</h3> <ul><li>这句话本身就是错误的，autoreleasePool的释放和runloop没有任何关系，只是我们可以监听runloop的状态来调用drain方法</li></ul> <h3 id="主线程的autoreleasepool是每次执行事件循环时-系统监听并自动释放-子线程如果创建autoreleasepool-系统也会自动创建监听吗"><a href="#主线程的autoreleasepool是每次执行事件循环时-系统监听并自动释放-子线程如果创建autoreleasepool-系统也会自动创建监听吗" class="header-anchor">#</a> 主线程的autoreleasepool是每次执行事件循环时，系统监听并自动释放，子线程如果创建autoreleasepool，系统也会自动创建监听吗？</h3> <ul><li>子线程不会监听，因为子线程的runloop本身就不会自动开启，都是每次drain时释放</li></ul> <h3 id="autoreleasepool为何能降低for循环的内存峰值"><a href="#autoreleasepool为何能降低for循环的内存峰值" class="header-anchor">#</a> autoreleasePool为何能降低for循环的内存峰值？</h3> <ul><li>如果在for循环当中使用非用户创建的对象或者__autoreleasing对象，那么这些对象将在runloop即将进入休眠时才释放，这会造成内存瞬时峰值，所以想要降低峰值，我们可以在for循环当中使用@autoreleasePool，以便在每次循环时就释放对象，而不需要等待runloop休眠时才释放</li></ul> <h3 id="底层"><a href="#底层" class="header-anchor">#</a> 底层</h3> <ul><li><p>1.objc_autoreleasePoolPush()</p> <ul><li><p>AutoreleasePoolPage::push();</p> <ul><li>返回哨兵对象</li></ul></li></ul></li> <li><p>2.atautoreleasepoolobj;</p> <ul><li>哨兵对象</li></ul></li> <li><p>3.objc_autoreleasePoolPop()</p> <ul><li><p>AutoreleasePoolPage::pop(ctxt);</p> <ul><li>根据哨兵对象，将哨兵对象之后的所有page内的autorelease对象全部release</li></ul></li></ul></li> <li><p>AutoreleasePoolPage</p> <ul><li><p>每页空间为4096字节</p> <ul><li>每页最多存储(4096-56)/8 = 505个对象，第一页因为有哨兵对象(即atautoreleasepoolobj对象)，所以第一页只能存储504个对象</li></ul></li> <li><p>next</p> <ul><li>指向下次新添加的autorelease对象的位置(即指向还未存储的位置)</li></ul></li> <li><p>parent</p> <ul><li>指向上一页</li></ul></li> <li><p>child</p> <ul><li>指向下一页</li></ul></li> <li><p>每个page自身占用56个字节</p></li></ul></li> <li><p>autoreleasePool</p> <ul><li><p>AutoreleasePoolPage</p> <ul><li>只有第一个page有哨兵指针</li></ul></li> <li><p>AutoreleasePoolPage</p></li> <li><p>AutoreleasePoolPage</p></li> <li><p>...</p></li></ul></li></ul> <h2 id="对象释放时机"><a href="#对象释放时机" class="header-anchor">#</a> 对象释放时机</h2> <h3 id="局部变量"><a href="#局部变量" class="header-anchor">#</a> 局部变量</h3> <ul><li><p>自己创建的对象</p> <ul><li>作用域结束即释放</li></ul></li> <li><p>系统创建的对象</p> <ul><li>在下一个事件循环时释放(autorelease)</li></ul></li> <li><p>自己创建的__autoreleasing对象</p> <ul><li>在下一个事件循环时释放(autorelease)</li></ul></li></ul> <h3 id="成员变量"><a href="#成员变量" class="header-anchor">#</a> 成员变量</h3> <ul><li>dealloc时释放</li></ul> <h3 id="malloc对象"><a href="#malloc对象" class="header-anchor">#</a> malloc对象</h3> <ul><li>需要调用free释放</li></ul> <h2 id="ui响应链"><a href="#ui响应链" class="header-anchor">#</a> UI响应链</h2> <h3 id="事件传递"><a href="#事件传递" class="header-anchor">#</a> 事件传递</h3> <ul><li><ul><li>(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
if (self.hidden || !self.userInteractionEnabled || self.alpha &lt; 0.01 || ![self pointInside:point withEvent:event]) {
return nil;
} else {
for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
UIView *hitView = [subview hitTest:[subview convertPoint:point fromView:self] withEvent:event];
if (hitView) {
return hitView;
}
}
}
return self;
}//系统内部实现机制</li></ul></li> <li><p>(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {
return YES;
}</p> <ul><li>hitTest用来查找在点击范围内最上层的view，查找到view之后就要判断是否能响应点击事件，如果查找到的view不能响应该事件，那么就会交给nextResponder进行响应，一层一层传递，直到AppDelegate，如果最后无人能响应事件，那么丢弃该事件</li></ul></li> <li><p>通过逐层遍历子视图找到范围内的view(UIView/UIWindow)</p></li></ul> <h3 id="事件响应"><a href="#事件响应" class="header-anchor">#</a> 事件响应</h3> <ul><li><p>事件响应对象可以是AppDelegate/UIApplication/UIWindow/UIViewController/UIView</p></li> <li><p>在view或者UIViewController被添加到其他对象当中时，会自动指定nextResponder指针</p></li> <li><p>找到View后，如果当前view不能处理事件，就通过nextResponder指针向父view或者父VC传递，注意self.view的nextResponder是VC，而VC的nextResponder是self.view的superview，直到找到一个能响应事件的对象为止，找到能响应事件的对象后，就将事件交给该对象处理。</p></li> <li><p>默认情况下普通的UIView都不能响应事件，系统内部只是将事件交给下一响应者，对于UIButton，就不是直接交给下一响应者了，而是实现其内部方法，因为Button能响应事件。</p> <ul><li><ul><li>(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
[[self nextResponder] touchesBegan:touches withEvent:event];
}//这是系统内部实现机制，系统会直接调用这个方法，注意这不是代理方法，是给系统调用的</li></ul></li></ul></li></ul> <h2 id="组件化"><a href="#组件化" class="header-anchor">#</a> 组件化</h2> <h3 id="url-block方式"><a href="#url-block方式" class="header-anchor">#</a> url-block方式</h3> <ul><li><p>1.即启动时注册组件，将url和block对应，保存到内存当中</p></li> <li><p>2.调用时，通过url查找对应的block进行调用</p></li> <li><p>缺点</p> <ul><li>组件多了可能会有内存问题</li> <li>url无法传递非常规参数，例如UIImage、NSData</li></ul></li></ul> <h3 id="protocol-class方式"><a href="#protocol-class方式" class="header-anchor">#</a> protocol-class方式</h3> <ul><li>1.启动时注册类和协议，将类和协议一一对应保存到内存当中</li> <li>2.调用时，根据协议查找对应的类和方法，实际上此方法和url-block类似，只是不同的封装而已，和url-block不同的是，这种方式可以自由传递各种类型的参数</li></ul> <h3 id="target-action方式"><a href="#target-action方式" class="header-anchor">#</a> target-action方式</h3> <ul><li>0.假如A组件需要调用B组件</li> <li>1.通过中间件的单例进行调用封装B组件的category(中间件的category)中的方法</li> <li>2.类名以及方法名写在category当中</li> <li>3.中间件拿到类名和方法名后进行动态调用</li> <li>4.对于一些频繁的调用，我们可以存到中间件的单例当中以便下次继续调用</li></ul> <h2 id="oc消息转发"><a href="#oc消息转发" class="header-anchor">#</a> OC消息转发</h2> <h3 id="resolveinstancemethod"><a href="#resolveinstancemethod" class="header-anchor">#</a> resolveInstanceMethod</h3> <ul><li><p>返回值为YES</p> <ul><li>打印成功的信息</li></ul></li> <li><p>返回值为NO</p> <ul><li>打印失败的信息</li></ul></li> <li><p>无论我们设置返回值为YES还是NO均可以，只会影响打印结果，不会有任何异常，而且无论设置YES还是NO，系统都会再次查找缓存，当缓存中有时，停止消息转发，当缓存中没有该方法时，进行下一步。所以我们可以在resolveInstanceMethod当中动态添加方法的实现，系统查找到动态方法后，会停止消息转发</p></li></ul> <h3 id="forwardingtargetforselector"><a href="#forwardingtargetforselector" class="header-anchor">#</a> forwardingTargetForSelector</h3> <ul><li>设置接收消息的对象，如果为nil，则去获取方法签名</li></ul> <h3 id="methodsignatureforselector"><a href="#methodsignatureforselector" class="header-anchor">#</a> methodSignatureForSelector</h3> <ul><li>设置方法签名</li></ul> <h3 id="forwardinvocation-nsinvocation-aninvocation"><a href="#forwardinvocation-nsinvocation-aninvocation" class="header-anchor">#</a> forwardInvocation:(NSInvocation *)anInvocation</h3> <ul><li>调用anInvocation的invoke</li></ul> <h3 id="doesnotrecognizeselector"><a href="#doesnotrecognizeselector" class="header-anchor">#</a> doesNotRecognizeSelector</h3> <ul><li>未找到方法的实现，程序崩溃</li></ul> <h2 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h2> <h3 id="单例模式"><a href="#单例模式" class="header-anchor">#</a> 单例模式</h3> <h3 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> 工厂模式</h3> <ul><li>NSArray</li></ul> <h3 id="适配器模式"><a href="#适配器模式" class="header-anchor">#</a> 适配器模式</h3> <ul><li>例如[super viewdidLoad]</li></ul> <h3 id="桥接模式"><a href="#桥接模式" class="header-anchor">#</a> 桥接模式</h3> <ul><li>子类重写父类方法，父类不需要实现</li></ul> <h3 id="外观模式"><a href="#外观模式" class="header-anchor">#</a> 外观模式</h3> <ul><li>统一的访问接口</li></ul> <h3 id="中介者"><a href="#中介者" class="header-anchor">#</a> 中介者</h3> <ul><li>组件化</li></ul> <h3 id="观察者"><a href="#观察者" class="header-anchor">#</a> 观察者</h3> <h3 id="迭代器"><a href="#迭代器" class="header-anchor">#</a> 迭代器</h3> <h3 id="装饰模式"><a href="#装饰模式" class="header-anchor">#</a> 装饰模式</h3> <ul><li>Category</li></ul> <h3 id="责任链"><a href="#责任链" class="header-anchor">#</a> 责任链</h3> <ul><li>UI响应链</li></ul> <h3 id="模板方法"><a href="#模板方法" class="header-anchor">#</a> 模板方法</h3> <ul><li>drawRect</li></ul> <h3 id="策略模式"><a href="#策略模式" class="header-anchor">#</a> 策略模式</h3> <ul><li>例如验证UITextField是邮箱还是密码，将算法封装</li></ul> <h3 id="命令模式"><a href="#命令模式" class="header-anchor">#</a> 命令模式</h3> <ul><li>NSInvocation</li></ul> <h3 id="代理"><a href="#代理" class="header-anchor">#</a> 代理</h3> <h2 id="第三方库"><a href="#第三方库" class="header-anchor">#</a> 第三方库</h2> <h3 id="afnetworking"><a href="#afnetworking" class="header-anchor">#</a> AFNetworking</h3> <ul><li><p>模块</p> <ul><li>会话</li> <li>网络监听模块</li> <li>网络安全模块</li> <li>请求序列化</li> <li>响应序列化</li> <li>UIKit集成模块</li></ul></li></ul> <h2 id="load和initialize"><a href="#load和initialize" class="header-anchor">#</a> load和initialize</h2> <h3 id="load"><a href="#load" class="header-anchor">#</a> load</h3> <ul><li><p>在runtime加载类或者分类时调用</p></li> <li><p>每个类的load有且只会调用一次</p></li> <li><p>先调用父类的load、再调用子类的load、最后调用分类的load</p></li> <li><p>不会被子类或者分类覆盖，必执行</p></li> <li><p>使用</p> <ul><li>hook</li> <li>组件化通信</li></ul></li></ul> <h3 id="initialize"><a href="#initialize" class="header-anchor">#</a> initialize</h3> <ul><li>在类第一次接收到消息时调用(任何消息)</li> <li>在子类没有覆写initialize时，父类的initialize可能会调用多次</li> <li>基于objc_msgSend，分类会覆盖原类的initialize，但不会覆盖原类的父类的initialize</li> <li>可以被分类覆盖</li></ul> <h2 id="组件化-2"><a href="#组件化-2" class="header-anchor">#</a> 组件化</h2> <h3 id="方案"><a href="#方案" class="header-anchor">#</a> 方案</h3> <ul><li><p>项目的业务线超过2条以上，需要独立拆分</p></li> <li><p>项目人员太多，防止对同一块代码修改</p></li> <li><p>url-block</p> <ul><li><p>启动时注册组件提供的服务</p></li> <li><p>通过url进行通信</p></li> <li><p>步骤</p> <ul><li>app启动时register服务url-block</li> <li>通过openURL执行block</li></ul></li> <li><p>缺点</p> <ul><li><p>依赖中间件</p> <ul><li>如果组件越多，那么中间件就越复杂</li></ul></li> <li><p>内存需要维护映射表</p></li> <li><p>组件分散注册</p></li> <li><p>参数传递限制</p></li></ul></li></ul></li> <li><p>protocol-class</p> <ul><li>启动时将protocol-class注册到单例当中</li> <li>openprotocol时，可以对注册协议的组件发送消息，实现各种类型数据的传递</li> <li>缺点和url-block类似，不过可以发送更多类型的数据</li></ul></li> <li><p>url-controller</p> <ul><li><p>启动时对每个组件创建一个单例类型的connector，注册到总线单例当中</p></li> <li><p>通过openurl传递url和参数，去总线当中查找connector，找到connctor后，动态生成相应的页面，传递参数，发送消息</p></li> <li><p>优点</p> <ul><li>可以解决url-block占用内存的问题</li> <li>解决了参数传递的问题</li></ul></li> <li><p>缺点</p> <ul><li>组件会依赖connector，所以依旧会有依赖中间件的问题</li></ul></li></ul></li> <li><p>target-action</p> <ul><li><p>首先组件将需要对外暴露的功能进行一层封装，就是target，所以不会对组件有入侵</p></li> <li><p>调用者通常只需要依赖中间件，而中间件又是通过runtime来调用组件服务，所以使得两个组件间进行了解耦。</p></li> <li><p>虽然调用者依赖中间件，但是代码不是侵入式的，我们可以对中间件采用装饰者设计模式为调用者提供服务</p></li> <li><p>缺点</p> <ul><li>代码量比较大</li> <li>基于通用性以及高内聚的原则，可能还要去model化</li></ul></li></ul></li></ul> <h3 id="实施"><a href="#实施" class="header-anchor">#</a> 实施</h3> <ul><li><p>壳工程</p></li> <li><p>第三方库以及公共库组件</p> <ul><li><p>公共组件</p> <ul><li>埋点组件</li> <li>工具组件</li> <li>性能监控组件</li> <li>定位组件</li> <li>图片处理组件</li> <li>UIKit封装及扩展组件</li> <li>业务生命周期及通信组件</li></ul></li> <li><p>网络组件</p> <ul><li>基于AFNetworking进行封装，提供json转model、缓存功能</li> <li>DNS加速组件</li></ul></li> <li><p>持久化组件</p> <ul><li>FMDB进行封装组件</li></ul></li> <li><p>第三方业务组件</p> <ul><li>分享组件</li> <li>推送组件</li></ul></li></ul></li> <li><p>独立业务组件</p> <ul><li>User组件，保存用户信息，登录，登出状态</li> <li>各种业务组件</li></ul></li></ul> <h2 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h2> <h3 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h3> <ul><li>指针通常在栈内存</li></ul> <h3 id="堆"><a href="#堆" class="header-anchor">#</a> 堆</h3> <ul><li><p>方式</p> <ul><li><p>arc</p></li> <li><p>mrc</p> <ul><li>release操作实际上就是将指针内的引用计数-1，当引用计数为0时，释放对象</li></ul></li> <li><p>autoreleasepool</p> <ul><li><p>autorelease操作不会改变引用计数，是将对象加入autoreleasePool，在pool释放时进行release操作</p> <ul><li>instancetype</li></ul></li></ul></li></ul></li> <li><p>实例</p> <ul><li>NSTaggedPointerString</li> <li>NSCFString</li></ul></li> <li><p>对象通常在堆内存创建</p> <ul><li>如果有指针指向堆内存对象，那么指针当中的某些标记位会标记引用计数，如果引用计数为0，那么对象会被释放，但是指针不一定会置为nil，通常可以手动置为nil，也可以等待栈的返回(即超出作用域)</li></ul></li></ul> <h3 id="全局-静态存储区"><a href="#全局-静态存储区" class="header-anchor">#</a> 全局/静态存储区</h3> <ul><li>static指针/static基本类型的数据</li></ul> <h3 id="常量区"><a href="#常量区" class="header-anchor">#</a> 常量区</h3> <ul><li>NSCFConstantString</li></ul> <h3 id="代码区"><a href="#代码区" class="header-anchor">#</a> 代码区</h3> <h2 id="客户端整体架构"><a href="#客户端整体架构" class="header-anchor">#</a> 客户端整体架构</h2> <h3 id="独立于app的通用层"><a href="#独立于app的通用层" class="header-anchor">#</a> 独立于App的通用层</h3> <ul><li>页面的时长统计</li> <li>崩溃统计</li> <li>网络等第三方库</li></ul> <h3 id="通用业务层"><a href="#通用业务层" class="header-anchor">#</a> 通用业务层</h3> <ul><li>公司通用的业务组件，比如某种按钮、某些界面的封装</li></ul> <h3 id="中间层"><a href="#中间层" class="header-anchor">#</a> 中间层</h3> <ul><li>协调和解耦的作用</li></ul> <h3 id="业务层"><a href="#业务层" class="header-anchor">#</a> 业务层</h3> <ul><li>业务A、B、C等等</li></ul> <h2 id="野指针"><a href="#野指针" class="header-anchor">#</a> 野指针</h2> <p>指针指向的对象被释放，但是指针未置为nil</p> <h3 id="产生原因"><a href="#产生原因" class="header-anchor">#</a> 产生原因</h3> <ul><li><p>assign/__unsafe_unretained</p> <ul><li>assign指针不会增加对象的引用计数，但是在原对象引用计数为0被释放后，该指针依旧指向对象的内存地址，当再通过assign指针访问对象的属性或者方法时，可能会崩溃，也可能不会崩溃，崩溃是因为对象的内存释放后，该块内存地址被其他对象覆写，通过指针访问不到相应的属性或者方法。不会崩溃是因为如果内存没被覆写，依旧可以通过assign指针进行访问</li></ul></li> <li><p>访问被释放的block</p></li> <li><p>向已经释放的对象发送消息可能崩溃，也可能不崩溃，如果被释放的对象所占用的内存还未被其他对象覆写，那么可能不会发生崩溃，即使被其他对象覆写，如果其他对象也有同样的方法，也可能不会崩溃，而且会得不到自己想要的值，这种不安全的访问，我们怎么才能通过调试去发现呢？系统为我们提供了工具进行调试</p></li></ul> <h3 id="定位"><a href="#定位" class="header-anchor">#</a> 定位</h3> <ul><li><p>用户层</p> <ul><li><p>采集用户的辅助信息</p> <ul><li>采集设备信息，用户行为等等以便重现问题</li></ul></li></ul></li> <li><p>调试层</p> <ul><li><p>Zombie Object</p> <ul><li>打开僵尸对象调试以后，被释放的对象内存不会被覆写，但是我们也无法成功调用该内存的方法，因为僵尸对象会直接抛异常。</li></ul></li> <li><p>Malloc Scribble</p> <ul><li>对已经释放的内存进行数据填充，从而保证野指针访问是必然崩溃的</li></ul></li></ul></li></ul> <h2 id="oom判定"><a href="#oom判定" class="header-anchor">#</a> OOM判定</h2> <h3 id="排除法"><a href="#排除法" class="header-anchor">#</a> 排除法</h3> <ul><li>是否是debug</li> <li>是否是普通的crash</li> <li>是否是主动退出</li> <li>是否调用了exit</li> <li>是否是watchDog杀死</li></ul> <h3 id="为何使用排除法"><a href="#为何使用排除法" class="header-anchor">#</a> 为何使用排除法？</h3> <ul><li>因为当发生OOM时，memory warning方法可能未调用，因为恰好此时主线程在忙于其他事情，导致可能没经历过memory warning就发生OOM</li></ul> <h2 id="防止crash"><a href="#防止crash" class="header-anchor">#</a> 防止crash</h2> <h3 id="signal"><a href="#signal" class="header-anchor">#</a> Signal</h3> <ul><li><p>案例</p> <ul><li>野指针</li> <li>释放不存在的内存空间</li></ul></li> <li><p>防止crash</p> <ul><li>捕获信号后进行忽略</li></ul></li> <li><p>抓取</p> <ul><li>捕获后获取线程调用栈，上传服务器</li></ul></li></ul> <h3 id="nsexception"><a href="#nsexception" class="header-anchor">#</a> NSException</h3> <p>应用级异常，它是未被捕获的Objective-C异常，导致程序向自身发送了SIGABRT信号而崩溃，对于未捕获的Objective-C异常，是可以通过try catch来捕获的，或者通过NSSetUncaughtExceptionHandler()机制来捕获。</p> <ul><li><p>案例</p> <ul><li><p>unrecognized selector sent to instance</p> <ul><li>采用消息转发</li></ul></li> <li><p>KVC的key为nil</p> <ul><li>对setValue:forKey:进行拦截</li></ul></li> <li><p>未移除KVO</p></li> <li><p>NSArray/NSMutableArray</p> <ul><li>初始化或插入nil</li></ul></li> <li><p>NSNotificationCenter</p> <ul><li>未移除通知中心本身不会crash，但是如果对象被释放了，接收到通知可能会崩溃</li></ul></li></ul></li> <li><p>防止crash</p> <ul><li>trycatch</li> <li>NSSetUncaughtExceptionHandler</li></ul></li> <li><p>抓取</p> <ul><li>直接上传</li></ul></li></ul> <h3 id="oom"><a href="#oom" class="header-anchor">#</a> OOM</h3> <ul><li>排除法</li></ul> <h3 id="watchdog杀死"><a href="#watchdog杀死" class="header-anchor">#</a> watchDog杀死</h3> <ul><li>监控runloop的状态</li></ul> <h2 id="ns-enum和ns-options"><a href="#ns-enum和ns-options" class="header-anchor">#</a> NS_ENUM和NS_OPTIONS</h2> <h3 id="推荐使用这两个宏来定义枚举-而不是使用c类型的枚举-优点是简洁、类型直观"><a href="#推荐使用这两个宏来定义枚举-而不是使用c类型的枚举-优点是简洁、类型直观" class="header-anchor">#</a> 推荐使用这两个宏来定义枚举，而不是使用C类型的枚举，优点是简洁、类型直观</h3> <h2 id="ns-designated-initializer"><a href="#ns-designated-initializer" class="header-anchor">#</a> NS_DESIGNATED_INITIALIZER</h2> <h3 id="如果类的某个初始化方法指定了ns-designated-initializer-那么其他初始化方法不能调用父类进行初始化-必须调用当前类指定的初始化方法进行初始化"><a href="#如果类的某个初始化方法指定了ns-designated-initializer-那么其他初始化方法不能调用父类进行初始化-必须调用当前类指定的初始化方法进行初始化" class="header-anchor">#</a> 如果类的某个初始化方法指定了NS_DESIGNATED_INITIALIZER，那么其他初始化方法不能调用父类进行初始化，必须调用当前类指定的初始化方法进行初始化</h3> <ul><li>designated 初始化方法是提供所有的参数</li> <li>secondary 初始化方法是一个或多个参数</li></ul> <h2 id="堆和栈"><a href="#堆和栈" class="header-anchor">#</a> 堆和栈</h2> <h3 id="栈内存高地址向下增长"><a href="#栈内存高地址向下增长" class="header-anchor">#</a> 栈内存高地址向下增长</h3> <h3 id="堆内存低地址向上增长"><a href="#堆内存低地址向上增长" class="header-anchor">#</a> 堆内存低地址向上增长</h3> <h2 id="new调用流程"><a href="#new调用流程" class="header-anchor">#</a> new调用流程</h2> <h3 id="_1-callalloc"><a href="#_1-callalloc" class="header-anchor">#</a> 1.callAlloc</h3> <p>内部调用alloc</p> <ul><li>alloc</li></ul> <h3 id="_2-init"><a href="#_2-init" class="header-anchor">#</a> 2.init</h3> <h2 id="object-getclass-id-obj-调用流程"><a href="#object-getclass-id-obj-调用流程" class="header-anchor">#</a> object_getClass(id obj)调用流程</h2> <p>获取类对象的指针</p> <h3 id="obj-getisa"><a href="#obj-getisa" class="header-anchor">#</a> obj-&gt;getIsa();</h3> <p>这里的获取到的isa实际上是类对象指针</p> <ul><li><p>objc_object::ISA(bool authenticated)</p> <ul><li><p>isa_t::getDecodedClass(bool authenticated)</p> <ul><li><p>isa_t::getClass(bool authenticated)</p> <ul><li><p>bits &amp;= ISA_MASK;</p> <ul><li>bits当中存放的是真正的64位二进制，其中包含了内存管理信息和类对象地址等等</li> <li>其中ISA_MASK是0x0000000ffffffff8ULL(掩码)，通过与运算之后可以取得33位真正的类对象地址，即shiftcls</li></ul></li> <li><p>与之相对应的是setClass，它们都是union isa_t当中的方法，不难看出setClass是将类对象地址存放到bits当中</p></li></ul></li></ul></li></ul></li></ul> <h2 id="objc-init初始化流程"><a href="#objc-init初始化流程" class="header-anchor">#</a> _objc_init初始化流程</h2> <h3 id="_1-初始化一系列"><a href="#_1-初始化一系列" class="header-anchor">#</a> 1.初始化一系列</h3> <ul><li>environ_init();
tls_init();
static_init();
runtime_init();
exception_init();
#if <strong>OBJC2</strong>
cache_t::init();
#endif<br>
_imp_implementationWithBlock_init();</li></ul> <h3 id="_2-map-images"><a href="#_2-map-images" class="header-anchor">#</a> 2.map_images</h3> <ul><li>将类信息加入到class_rw_t</li></ul> <h3 id="_3-load-images"><a href="#_3-load-images" class="header-anchor">#</a> 3.load_images</h3> <ul><li>1.将category信息加入到class_rw_t</li> <li>2.调用+load方法</li></ul> <h3 id="_4-unmap-image"><a href="#_4-unmap-image" class="header-anchor">#</a> 4.unmap_image</h3> <ul><li>释放一些资源</li></ul> <h2 id="method-t结构"><a href="#method-t结构" class="header-anchor">#</a> method_t结构</h2> <h3 id="static-const-uint32-t-smallmethodlistflag-0x80000000"><a href="#static-const-uint32-t-smallmethodlistflag-0x80000000" class="header-anchor">#</a> static const uint32_t smallMethodListFlag = 0x80000000;</h3> <h3 id="struct-big"><a href="#struct-big" class="header-anchor">#</a> struct big {</h3> <div class="language- extra-class"><pre><code>    SEL name;
    const char *types;
    MethodListIMP imp;
};
</code></pre></div><ul><li>可见方法的名称、方法类型、方法的实现都存放在method_t的big当中</li></ul> <h2 id="category-t结构-运行时确定"><a href="#category-t结构-运行时确定" class="header-anchor">#</a> category_t结构(运行时确定)</h2> <h3 id="char-name"><a href="#char-name" class="header-anchor">#</a> char *name;</h3> <ul><li>分类名称</li></ul> <h3 id="classref-t-cls"><a href="#classref-t-cls" class="header-anchor">#</a> classref_t cls;</h3> <ul><li>类对象，即isa指针</li></ul> <h3 id="wrappedptr-method-list-t-ptrauthstrip-instancemethods"><a href="#wrappedptr-method-list-t-ptrauthstrip-instancemethods" class="header-anchor">#</a> WrappedPtr&lt;method_list_t, PtrauthStrip&gt; instanceMethods;</h3> <ul><li>实例方法列表</li></ul> <h3 id="wrappedptr-method-list-t-ptrauthstrip-classmethods"><a href="#wrappedptr-method-list-t-ptrauthstrip-classmethods" class="header-anchor">#</a> WrappedPtr&lt;method_list_t, PtrauthStrip&gt; classMethods;</h3> <ul><li>类方法列表</li></ul> <h3 id="struct-protocol-list-t-protocols"><a href="#struct-protocol-list-t-protocols" class="header-anchor">#</a> struct protocol_list_t *protocols;</h3> <ul><li>协议列表</li></ul> <h3 id="struct-property-list-t-instanceproperties"><a href="#struct-property-list-t-instanceproperties" class="header-anchor">#</a> struct property_list_t *instanceProperties;</h3> <ul><li>实例属性的列表</li></ul> <h3 id="struct-property-list-t-classproperties"><a href="#struct-property-list-t-classproperties" class="header-anchor">#</a> struct property_list_t *_classProperties;</h3> <ul><li>类属性的列表</li></ul> <h2 id="class-ro-t结构-与宿主类相关-编译时确定-只读"><a href="#class-ro-t结构-与宿主类相关-编译时确定-只读" class="header-anchor">#</a> class_ro_t结构(与宿主类相关，编译时确定，只读)</h2> <h3 id="实例"><a href="#实例" class="header-anchor">#</a> 实例</h3> <ul><li><p>uint32_t flags;</p></li> <li><p>uint32_t instanceStart;</p></li> <li><p>uint32_t instanceSize;</p></li> <li><p>uint32_t reserved;</p></li> <li><p>union {
const uint8_t * ivarLayout;
Class nonMetaclass;
};</p></li> <li><p>explicit_atomic&lt;const char *&gt; name;</p></li> <li><p>void *baseMethodList;</p> <ul><li>方法列表(不包括category中的方法)</li></ul></li> <li><p>protocol_list_t * baseProtocols;</p> <ul><li>协议列表(不包括category中的协议)</li></ul></li> <li><p>const ivar_list_t * ivars;</p> <ul><li>变量列表</li></ul></li> <li><p>const uint8_t * weakIvarLayout;</p></li> <li><p>property_list_t *baseProperties;</p> <ul><li>属性列表(不包括category中的属性)</li></ul></li></ul> <h2 id="class-rw-t结构-运行时确定"><a href="#class-rw-t结构-运行时确定" class="header-anchor">#</a> class_rw_t结构(运行时确定)</h2> <h3 id="实例-2"><a href="#实例-2" class="header-anchor">#</a> 实例</h3> <ul><li>uint32_t flags;</li> <li>uint16_t witness;</li> <li>explicit_atomic&lt;uintptr_t&gt; ro_or_rw_ext;</li> <li>Class firstSubclass;</li> <li>Class nextSiblingClass;</li></ul> <h3 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h3> <ul><li><p>method_array_t methods();</p> <ul><li>方法列表</li></ul></li> <li><p>property_array_t properties();</p> <ul><li>属性列表</li></ul></li> <li><p>protocol_array_t protocols();</p> <ul><li>协议列表</li></ul></li> <li><p>class_ro_t *ro();</p> <ul><li>调用ro()函数得到class_ro_t，实际其相关信息存储在ro_or_rw_ext当中</li></ul></li></ul> <h3 id="运行时会将class-ro-t中的方法、属性、协议添加到class-rw-t当中"><a href="#运行时会将class-ro-t中的方法、属性、协议添加到class-rw-t当中" class="header-anchor">#</a> 运行时会将class_ro_t中的方法、属性、协议添加到class_rw_t当中</h3> <h2 id="class-data-bits-t结构-8字节"><a href="#class-data-bits-t结构-8字节" class="header-anchor">#</a> class_data_bits_t结构(8字节)</h2> <h3 id="唯一实例"><a href="#唯一实例" class="header-anchor">#</a> 唯一实例</h3> <ul><li><p>uintptr_t bits;</p> <ul><li>前3位不清楚</li> <li>class_rw_t (44位)</li></ul></li></ul> <h3 id="方法-2"><a href="#方法-2" class="header-anchor">#</a> 方法</h3> <ul><li><p>class_rw_t* data();</p> <ul><li>实际最后是通过取中间44位得到class_rw_t</li></ul></li></ul> <h2 id="cache-t结构-16字节"><a href="#cache-t结构-16字节" class="header-anchor">#</a> Cache_t结构(16字节)</h2> <p>方法缓存，在调用函数时，先查找方法缓存，查找不到时再查找bits当中的class_rw_t，再查找不到时到父类当中查找</p> <h3 id="explicit-atomic-uintptr-t-bucketsandmaybemask"><a href="#explicit-atomic-uintptr-t-bucketsandmaybemask" class="header-anchor">#</a> explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</h3> <h3 id="union"><a href="#union" class="header-anchor">#</a> union {</h3> <div class="language- extra-class"><pre><code>    struct {
        explicit_atomic&lt;mask_t&gt;    _maybeMask;
</code></pre></div><p>#if <strong>LP64</strong>
uint16_t                   _flags;
#endif
uint16_t                   _occupied;
};
explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;
};</p> <h2 id="objc-class-class-40字节"><a href="#objc-class-class-40字节" class="header-anchor">#</a> objc_class/Class(40字节)</h2> <p>objc_class类型的结构体指针，objc_class包含isa指针，并且当中存储了创建对象或者类对象所需要的信息</p> <h3 id="objc1版本"><a href="#objc1版本" class="header-anchor">#</a> Objc1版本</h3> <ul><li><p>Class isa</p> <p>元类对象的指针</p></li> <li><p>Class super_class</p> <p>父类对象的指针</p></li> <li><p>char *name</p> <p>类名</p></li> <li><p>long instance_size</p> <p>实例的总大小</p></li> <li><p>struct objc_ivar_list *ivars</p> <p>实例变量列表</p></li> <li><p>struct objc_method_list **methodLists</p> <p>方法列表</p></li> <li><p>struct objc_cache *cache</p> <p>缓存</p></li> <li><p>struct objc_protocol_list *protocols</p> <p>遵守的协议列表</p></li></ul> <h3 id="objc2版本"><a href="#objc2版本" class="header-anchor">#</a> Objc2版本</h3> <ul><li><p>属性</p> <ul><li><p>isa_t isa;</p> <ul><li>8字节，指向元类对象的isa指针</li></ul></li> <li><p>Class super_class;</p> <ul><li>8字节，指向父类</li></ul></li> <li><p>cache_t cache;</p> <ul><li>16字节，方法缓存</li></ul></li> <li><p>class_data_bits_t bits;</p> <ul><li>8字节，我们可以通过isa指针偏移32字节得到class_data_bits_t</li></ul></li></ul></li></ul> <h2 id="objc-object"><a href="#objc-object" class="header-anchor">#</a> objc_object</h2> <p>对象</p> <h3 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h3> <ul><li>isa_t isa;</li></ul> <h3 id="方法-3"><a href="#方法-3" class="header-anchor">#</a> 方法</h3> <ul><li><p>Class getIsa();</p> <ul><li>获取类对象指针</li></ul></li> <li><p>isaBits();</p> <ul><li>获取isa的64个比特位</li></ul></li></ul> <h2 id="union-isa-t"><a href="#union-isa-t" class="header-anchor">#</a> union isa_t</h2> <h3 id="存放了64位bits"><a href="#存放了64位bits" class="header-anchor">#</a> 存放了64位bits</h3> <ul><li><p>64bits组成(从低位到高位)</p> <ul><li><p>nonpointer(1)</p> <ul><li>0表示是纯的isa指针</li> <li>1表示非纯的isa指针，里面包含内存管理信息</li></ul></li> <li><p>has_assoc(1)</p> <ul><li>是否有关联对象</li></ul></li> <li><p>has_cxx_dtor(1)</p> <ul><li>是否有析构函数</li></ul></li> <li><p>shiftcls(33)</p> <ul><li>存储类对象指针</li></ul></li> <li><p>magic(6)</p> <ul><li>判断是否真对象还是未初始化的空间</li></ul></li> <li><p>weakly_referenced(1)</p> <ul><li>是否有弱引用指针</li></ul></li> <li><p>unused(1)</p></li> <li><p>has_sidetable_rc(1)</p> <ul><li>是否有散列表引用计数</li></ul></li> <li><p>extra_rc(19)</p> <ul><li>存储引用计数</li></ul></li></ul></li></ul> <h3 id="其中33位类对象地址-其余31位为内存相关的信息"><a href="#其中33位类对象地址-其余31位为内存相关的信息" class="header-anchor">#</a> 其中33位类对象地址，其余31位为内存相关的信息</h3> <h3 id="通过setclass方法将类对象地址存到bits的shiftcls当中-通过getclass将类对象地址从bits当中取出"><a href="#通过setclass方法将类对象地址存到bits的shiftcls当中-通过getclass将类对象地址从bits当中取出" class="header-anchor">#</a> 通过setClass方法将类对象地址存到bits的shiftcls当中，通过getClass将类对象地址从bits当中取出</h3> <h2 id="init调用流程"><a href="#init调用流程" class="header-anchor">#</a> init调用流程</h2> <h3 id="objc-rootinit-self"><a href="#objc-rootinit-self" class="header-anchor">#</a> _objc_rootInit(self)</h3> <p>其中self为指向对象的指针（即objc_object指针），无任何操作，函数返回值为self</p> <h2 id="alloc调用流程"><a href="#alloc调用流程" class="header-anchor">#</a> alloc调用流程</h2> <h3 id="objc-rootalloc-self"><a href="#objc-rootalloc-self" class="header-anchor">#</a> _objc_rootAlloc(self)</h3> <p>其中self为指向类对象指针</p> <ul><li><p>callAlloc</p> <ul><li><p>allocWithZone</p> <ul><li><p>_objc_rootAllocWithZone</p> <ul><li><p>_class_createInstanceFromZone</p> <ul><li><p>instanceSize</p> <p>获取实例大小</p> <ul><li><p>size = alignedInstanceSize()</p> <p>获取对其后的字节数</p> <ul><li><p>data()-&gt;ro()-&gt;instanceSize</p> <p>获取实例大小</p> <ul><li>通过data()方法取得class_rw_t</li> <li>从ro()方法中获取class_ro_t</li> <li>从class_ro_t中取得instanceSize</li></ul></li> <li><p>(x + size_t(15)) &amp; ~size_t(15)</p> <p>将获取到的实例大小按照16字节对齐</p></li></ul></li> <li><p>if (size &lt; 16) size = 16;</p> <p>当字节小于16时，开辟16字节空间</p> <ul><li>规定对象的占用的最小内存大小：如果小于16字节，就开辟16字节</li></ul></li> <li><p>实例的大小由isa指针、基本数据类型、其他指针组成</p></li></ul></li> <li><p>calloc</p> <p>开辟内存空间</p></li> <li><p>initInstanceIsa</p> <p>初始化isa指针，将isa指针绑定到对象</p> <ul><li><p>什么是isa指针？</p> <ul><li>isa指针存储了类对象或者元类对象地址，还有其它内存管理相关的内容</li></ul></li> <li><p>什么是super_class指针？</p> <ul><li>super_class指针表明当前类对象的父类或者当前元类对象的父元类</li></ul></li> <li><p>newisa.setClass(cls, this);</p> <ul><li>将类对象绑定到对象</li></ul></li> <li><p>newisa.extra_rc = 1;</p> <ul><li>设置引用计数为1</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul> <h3 id="通过分析alloc之后的对象p-我们发现创建的新的p的地址会比之前大-而-p的地址会变小且每次增长8个字节-可以证明对象开辟在堆空间-所以它的地址是向上增长-而指针存储在栈空间-它的地址是向下增长的。"><a href="#通过分析alloc之后的对象p-我们发现创建的新的p的地址会比之前大-而-p的地址会变小且每次增长8个字节-可以证明对象开辟在堆空间-所以它的地址是向上增长-而指针存储在栈空间-它的地址是向下增长的。" class="header-anchor">#</a> 通过分析alloc之后的对象p，我们发现创建的新的p的地址会比之前大，而&amp;p的地址会变小且每次增长8个字节，可以证明对象开辟在堆空间，所以它的地址是向上增长，而指针存储在栈空间，它的地址是向下增长的。</h3> <h2 id="alloc对比"><a href="#alloc对比" class="header-anchor">#</a> alloc对比</h2> <h3 id="每次alloc生成的地址相同-init后不同"><a href="#每次alloc生成的地址相同-init后不同" class="header-anchor">#</a> 每次alloc生成的地址相同，init后不同</h3> <ul><li>[NSString alloc]</li> <li>[NSMutableString alloc]</li> <li>[NSArray alloc]</li> <li>[NSMutableArray alloc]</li> <li>[NSDictionary alloc]</li> <li>[NSMutableDictionary alloc]</li></ul> <h3 id="每次开辟的地址变大-说明开辟在堆区"><a href="#每次开辟的地址变大-说明开辟在堆区" class="header-anchor">#</a> 每次开辟的地址变大，说明开辟在堆区</h3> <ul><li>[NSObject alloc]</li></ul> <h2 id="nsstring的子类"><a href="#nsstring的子类" class="header-anchor">#</a> NSString的子类</h2> <h3 id="nscfconstantstring-常量区"><a href="#nscfconstantstring-常量区" class="header-anchor">#</a> __NSCFConstantString(常量区)</h3> <ul><li><p>创建方式</p> <ul><li>@&quot;...&quot;</li> <li>CFSTR(&quot;...&quot;)</li> <li>[NSString stringWithString:]</li></ul></li> <li><p>编译时常量</p></li> <li><p>程序结束时释放</p></li></ul> <h3 id="nstaggedpointerstring-栈区"><a href="#nstaggedpointerstring-栈区" class="header-anchor">#</a> NSTaggedPointerString(栈区)</h3> <ul><li><p>地址分析0xab1957fd0bebaf35</p> <ul><li><p>a(1010)</p> <ul><li>1表示这是一个Tagged Pointer</li> <li>010表示这是一个NSTaggedPointerString类</li></ul></li> <li><p>5(0101)</p> <ul><li>表示字符的长度</li></ul></li> <li><p>中间的56位二进制是真正的数据值</p> <ul><li>1.如果采用ascii编码(8位编码)，那么最多存储7个字符</li> <li>2.如果采用6位编码，最多存储9个字符</li> <li>3.如果采用5位编码，最多存储11个字符</li> <li>4.当字符数超过11位时，那么数据就会存储到堆区，类型为__NSCFString</li></ul></li></ul></li> <li><p>创建方式</p> <ul><li><p>[NSString stringWithFormat:]</p> <ul><li>短字符(长度小于等于11)</li></ul></li></ul></li> <li><p>本身就是存储的值，无需释放</p></li></ul> <h3 id="nscfstring-堆区"><a href="#nscfstring-堆区" class="header-anchor">#</a> __NSCFString(堆区)</h3> <ul><li><p>创建方式</p> <ul><li><p>[NSString stringWithFormat:]</p> <ul><li><p>长字符(长度大于11)</p> <ul><li><p>NSString *str =  [NSString stringWithFormat:@&quot;https://ityongzhen.github.io/&quot;];</p> <ul><li>str的引用计数为2</li></ul></li></ul></li></ul></li> <li><p>NSMutableString</p></li> <li><p>NSString *str =  [[NSString alloc] initWithFormat:@&quot;https://ityongzhen.github.io/&quot;];</p> <ul><li>str引用计数为1</li></ul></li></ul></li> <li><p>运行时NSString的子类</p></li> <li><p>出了方法作用域，在runloop结束时被autoreleasepool释放</p></li></ul> <h2 id="nsnumber子类"><a href="#nsnumber子类" class="header-anchor">#</a> NSNumber子类</h2> <h3 id="nscfnumber"><a href="#nscfnumber" class="header-anchor">#</a> __NSCFNumber</h3> <ul><li>短数据存储实际值</li> <li>长数据存储指针，长短的界限暂时还不确定</li></ul> <h2 id="nszone"><a href="#nszone" class="header-anchor">#</a> NSZone</h2> <h3 id="系统自带nszone-它使用c结构存储了对象的内存管理信息-不过在系统的zone中开辟大量内存时-开销会很大-因为系统的zone内存在使用期间已经碎片化了-此时我们可以创建自己的zone-这样开辟内存开销小-并且可以一次性释放zone内存"><a href="#系统自带nszone-它使用c结构存储了对象的内存管理信息-不过在系统的zone中开辟大量内存时-开销会很大-因为系统的zone内存在使用期间已经碎片化了-此时我们可以创建自己的zone-这样开辟内存开销小-并且可以一次性释放zone内存" class="header-anchor">#</a> 系统自带NSZone，它使用C结构存储了对象的内存管理信息，不过在系统的Zone中开辟大量内存时，开销会很大，因为系统的Zone内存在使用期间已经碎片化了，此时我们可以创建自己的Zone，这样开辟内存开销小，并且可以一次性释放Zone内存</h3> <h2 id="size"><a href="#size" class="header-anchor">#</a> size</h2> <h3 id="sizeof"><a href="#sizeof" class="header-anchor">#</a> sizeof</h3> <ul><li>获取指针的大小，通常跟操作系统有关，64位系统通常返回8字节</li></ul> <h3 id="class-getinstancesize"><a href="#class-getinstancesize" class="header-anchor">#</a> class_getInstanceSize</h3> <ul><li>获取对象至少需要的内存大小，按8字节对齐，内存最少需要8字节</li></ul> <h3 id="malloc-size"><a href="#malloc-size" class="header-anchor">#</a> malloc_size</h3> <ul><li>获取对象实际分配的内存大小，按16字节对齐，其中isa指针占8个字节，所以对象分配的内存最小为16字节</li></ul> <h2 id="id-2"><a href="#id-2" class="header-anchor">#</a> id</h2> <p>objc_object类型的结构体指针</p> <h3 id="objc-object结构体只包含一个唯一的isa指针-因为每一个对象都必须依赖一个类来创建-所以它指向类对象-类对象是objc-class类型的结构体"><a href="#objc-object结构体只包含一个唯一的isa指针-因为每一个对象都必须依赖一个类来创建-所以它指向类对象-类对象是objc-class类型的结构体" class="header-anchor">#</a> objc_object结构体只包含一个唯一的isa指针，因为每一个对象都必须依赖一个类来创建，所以它指向类对象(类对象是objc_class类型的结构体)，</h3> <h2 id="对象objc-object、类对象objc-class、元类对象objc-class的区别"><a href="#对象objc-object、类对象objc-class、元类对象objc-class的区别" class="header-anchor">#</a> 对象objc_object、类对象objc_class、元类对象objc_class的区别</h2> <h3 id="对象objc-object中只有一个isa指针-isa指针包含类对象地址和其他内存信息"><a href="#对象objc-object中只有一个isa指针-isa指针包含类对象地址和其他内存信息" class="header-anchor">#</a> 对象objc_object中只有一个isa指针(isa指针包含类对象地址和其他内存信息)</h3> <h3 id="类对象objc-class中存储了创建实例所需要的信息-类名、父类、实例大小、方法、协议等等-和一个指向元类对象的isa指针-通过这个isa指针-我们可以知道当前类是通过哪个元类对象创建来的"><a href="#类对象objc-class中存储了创建实例所需要的信息-类名、父类、实例大小、方法、协议等等-和一个指向元类对象的isa指针-通过这个isa指针-我们可以知道当前类是通过哪个元类对象创建来的" class="header-anchor">#</a> 类对象objc_class中存储了创建实例所需要的信息(类名、父类、实例大小、方法、协议等等)和一个指向元类对象的isa指针，通过这个isa指针，我们可以知道当前类是通过哪个元类对象创建来的</h3> <h3 id="元类对象objc-class中存储了创建类对象所需要的信息-类名、父元类等等-和一个指向根元类的isa指针"><a href="#元类对象objc-class中存储了创建类对象所需要的信息-类名、父元类等等-和一个指向根元类的isa指针" class="header-anchor">#</a> 元类对象objc_class中存储了创建类对象所需要的信息(类名、父元类等等)和一个指向根元类的isa指针</h3> <h2 id="内存管理方案"><a href="#内存管理方案" class="header-anchor">#</a> 内存管理方案</h2> <h3 id="taggedpointer方案"><a href="#taggedpointer方案" class="header-anchor">#</a> TaggedPointer方案</h3> <ul><li>短的NSString/NSNumber地址直接存储值</li></ul> <h3 id="nonpointer-isa方案"><a href="#nonpointer-isa方案" class="header-anchor">#</a> nonPointer_isa方案</h3> <ul><li>存储附加信息、引用计数和类对象指针</li> <li>引用计数值为extra_rc+SideTable中的计数值之和(如果has_sidetable_rc为1时)</li></ul> <h3 id="sidetable方案"><a href="#sidetable方案" class="header-anchor">#</a> SideTable方案</h3> <ul><li>当nonPointer_isa中的extra_rc超过上限时，使用SideTable管理引用计数，不过我发现extra_rc在64位机器上有19位，在32位机器上有7位，感觉已经够用了，是不是用不着散列表？</li></ul> <h3 id="weak"><a href="#weak" class="header-anchor">#</a> weak</h3> <ul><li>weak是通过弱引用表管理，每新增一个弱引用，就将弱引用指针添加到散列表当中，并将原对象的weakly_referenced置为1</li> <li>当原对象被释放时，根据原对象指针查找所属的弱引用表(即SideTable)，然后调用weak_clear_no_lock，并根据原对象的地址在SideTable中找出弱引用指针的数组，然后将弱引用的所有指针清空</li> <li>弱引用指针是指针的指针，即&amp;obj</li></ul> <h3 id="strong"><a href="#strong" class="header-anchor">#</a> strong</h3> <ul><li>strong是通过extra_rc和引用计数表一起管理，当extra_rc大于可存储上限时，使用散列表存储，并将has_sidetable_rc置为1</li></ul> <h3 id="sidetables"><a href="#sidetables" class="header-anchor">#</a> SideTables</h3> <p>通过对象指针获取所属的SideTable</p> <ul><li><p>SideTable</p> <ul><li><p>spinlock_t slock;</p></li> <li><p>RefcountMap refcnts;</p> <ul><li>引用计数表</li></ul></li> <li><p>weak_table_t weak_table;</p> <ul><li>弱引用表</li></ul></li> <li><p>如果是retain操作，则通过对象指针到refcnts当中去获取引用计数值，再执行+1操作</p></li> <li><p>如果是release操作，则通过对象指针到refcnts当中去获取引用计数值，再执行-1操作</p></li> <li><p>如果是retainCount操作，则需要将extra_rc和 sidetable中的引用计数值相加</p></li></ul></li></ul> <h3 id="dealloc操作"><a href="#dealloc操作" class="header-anchor">#</a> dealloc操作</h3> <ul><li><p>如果是taggedPointer，则无需释放操作</p></li> <li><p>如果是nonpointer，则需要额外步骤</p> <ul><li>1.如果有C++析构函数(即has_cxx_dtor为1)，则先调用析构函数</li> <li>2.如果有关联对象(即has_assoc为1)，则先移除关联对象</li> <li>3.如果有弱引用指针(即weakly_referenced为1)，则移除所有弱引用</li> <li>4.如果有散列表引用计数(即has_sidetable_rc为1)，则清除引用计数表</li> <li>5.最后调用free释放对象</li></ul></li></ul> <h2 id="kvo"><a href="#kvo" class="header-anchor">#</a> KVO</h2> <h3 id="addobserver"><a href="#addobserver" class="header-anchor">#</a> addObserver</h3> <ul><li>添加观察者时，会将isa指针指向原类的子类，系统会在对应的key的setter方法当中添加willChange和didChange方法，以便于通知观察者值的改变</li></ul> <h3 id="observevalueforkeypath"><a href="#observevalueforkeypath" class="header-anchor">#</a> observeValueForKeyPath</h3> <h2 id="synthesize"><a href="#synthesize" class="header-anchor">#</a> @synthesize</h2> <p>主要作用就是更改实例变量的名称，将之前的_testStr改成任意</p> <h3 id="synthesize-teststr-test22"><a href="#synthesize-teststr-test22" class="header-anchor">#</a> @synthesize testStr = test22;</h3> <ul><li>将属性testStr的实例变量的名称改为test22</li></ul> <h3 id="synthesize-teststr"><a href="#synthesize-teststr" class="header-anchor">#</a> @synthesize testStr;</h3> <ul><li>将属性testStr的实例变量名称改为testStr(之前为_testStr)</li></ul> <h3 id="当一个对象调用obj-test22时-默认是从getter方法中取出实例变量-例如取得test22或者teststr"><a href="#当一个对象调用obj-test22时-默认是从getter方法中取出实例变量-例如取得test22或者teststr" class="header-anchor">#</a> 当一个对象调用obj.test22时，默认是从getter方法中取出实例变量，例如取得test22或者testStr</h3> <h3 id="当一个对象调用obj-test22-123-时-默认是去设置实例变量test22或者teststr的值"><a href="#当一个对象调用obj-test22-123-时-默认是去设置实例变量test22或者teststr的值" class="header-anchor">#</a> 当一个对象调用obj.test22 = @&quot;123&quot;时，默认是去设置实例变量test22或者testStr的值</h3> <p><em>XMind - Trial Version</em></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/iOS笔记/ijkPlayer.html" class="prev">
        ijkPlayer
      </a></span> <span class="next"><a href="/iOS笔记/iOS性能优化.html">
        iOS性能优化
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9de76d75.js" defer></script><script src="/assets/js/2.98ea7a63.js" defer></script><script src="/assets/js/62.df85ea27.js" defer></script>
  </body>
</html>
