<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C | 文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.9de76d75.js" as="script"><link rel="preload" href="/assets/js/2.98ea7a63.js" as="script"><link rel="preload" href="/assets/js/45.0c29263b.js" as="script"><link rel="prefetch" href="/assets/js/10.fa8eed47.js"><link rel="prefetch" href="/assets/js/11.f98f25e0.js"><link rel="prefetch" href="/assets/js/12.1ab9b5a3.js"><link rel="prefetch" href="/assets/js/13.75251b00.js"><link rel="prefetch" href="/assets/js/14.b5068189.js"><link rel="prefetch" href="/assets/js/15.33abd7e1.js"><link rel="prefetch" href="/assets/js/16.34ed8053.js"><link rel="prefetch" href="/assets/js/17.b3d52ea3.js"><link rel="prefetch" href="/assets/js/18.cbe71205.js"><link rel="prefetch" href="/assets/js/19.c632cb86.js"><link rel="prefetch" href="/assets/js/20.90d9a221.js"><link rel="prefetch" href="/assets/js/21.15cb7700.js"><link rel="prefetch" href="/assets/js/22.62ea968a.js"><link rel="prefetch" href="/assets/js/23.b743fdd5.js"><link rel="prefetch" href="/assets/js/24.5d157647.js"><link rel="prefetch" href="/assets/js/25.1935fba3.js"><link rel="prefetch" href="/assets/js/26.fd22f8ee.js"><link rel="prefetch" href="/assets/js/27.f47adfe7.js"><link rel="prefetch" href="/assets/js/28.d9f5719d.js"><link rel="prefetch" href="/assets/js/29.82cbf665.js"><link rel="prefetch" href="/assets/js/3.b96f613e.js"><link rel="prefetch" href="/assets/js/30.9f901f01.js"><link rel="prefetch" href="/assets/js/31.d9e2f61c.js"><link rel="prefetch" href="/assets/js/32.b14052e9.js"><link rel="prefetch" href="/assets/js/33.1b2e5efd.js"><link rel="prefetch" href="/assets/js/34.4bf7f44f.js"><link rel="prefetch" href="/assets/js/35.98d5fd2b.js"><link rel="prefetch" href="/assets/js/36.cdaf1c2f.js"><link rel="prefetch" href="/assets/js/37.a67bdb9a.js"><link rel="prefetch" href="/assets/js/38.5d856b83.js"><link rel="prefetch" href="/assets/js/39.27169c95.js"><link rel="prefetch" href="/assets/js/4.268c621c.js"><link rel="prefetch" href="/assets/js/40.8763c647.js"><link rel="prefetch" href="/assets/js/41.cd839f43.js"><link rel="prefetch" href="/assets/js/42.a97bf97a.js"><link rel="prefetch" href="/assets/js/43.fd126bb1.js"><link rel="prefetch" href="/assets/js/44.50e2b10d.js"><link rel="prefetch" href="/assets/js/46.fdee27aa.js"><link rel="prefetch" href="/assets/js/47.c7c7e966.js"><link rel="prefetch" href="/assets/js/48.80bc6f0a.js"><link rel="prefetch" href="/assets/js/49.d457b0ac.js"><link rel="prefetch" href="/assets/js/5.f577ebb9.js"><link rel="prefetch" href="/assets/js/50.cea3b0e6.js"><link rel="prefetch" href="/assets/js/51.eaab3e31.js"><link rel="prefetch" href="/assets/js/52.010a2dfb.js"><link rel="prefetch" href="/assets/js/53.3622f7b6.js"><link rel="prefetch" href="/assets/js/54.817aba2b.js"><link rel="prefetch" href="/assets/js/55.c3984ff9.js"><link rel="prefetch" href="/assets/js/56.6f20785e.js"><link rel="prefetch" href="/assets/js/57.07c7f6fc.js"><link rel="prefetch" href="/assets/js/58.4ec50d24.js"><link rel="prefetch" href="/assets/js/59.626b42b0.js"><link rel="prefetch" href="/assets/js/6.b9249342.js"><link rel="prefetch" href="/assets/js/60.ba2af5c7.js"><link rel="prefetch" href="/assets/js/61.6e22c298.js"><link rel="prefetch" href="/assets/js/62.df85ea27.js"><link rel="prefetch" href="/assets/js/63.cd3c1f6a.js"><link rel="prefetch" href="/assets/js/64.d0f75a86.js"><link rel="prefetch" href="/assets/js/65.12e0c392.js"><link rel="prefetch" href="/assets/js/66.aac422ac.js"><link rel="prefetch" href="/assets/js/67.3ff890c6.js"><link rel="prefetch" href="/assets/js/68.c6d12518.js"><link rel="prefetch" href="/assets/js/69.455e0c09.js"><link rel="prefetch" href="/assets/js/7.375eddd0.js"><link rel="prefetch" href="/assets/js/70.73d975e7.js"><link rel="prefetch" href="/assets/js/71.66528e07.js"><link rel="prefetch" href="/assets/js/72.a608a326.js"><link rel="prefetch" href="/assets/js/73.b8ed0811.js"><link rel="prefetch" href="/assets/js/74.68f4db5d.js"><link rel="prefetch" href="/assets/js/75.85059bdc.js"><link rel="prefetch" href="/assets/js/8.a04b9d9b.js"><link rel="prefetch" href="/assets/js/9.04a00c43.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>iOS</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iOS知识体系/UI视图.html" class="sidebar-link">UI视图</a></li><li><a href="/iOS知识体系/Objective-C.html" class="sidebar-link">Objective-C</a></li><li><a href="/iOS知识体系/Swift.html" class="sidebar-link">Swift</a></li><li><a href="/iOS知识体系/Runtime.html" class="sidebar-link">Runtime</a></li><li><a href="/iOS知识体系/内存管理.html" class="sidebar-link">内存管理</a></li><li><a href="/iOS知识体系/Block.html" class="sidebar-link">Block</a></li><li><a href="/iOS知识体系/多线程.html" class="sidebar-link">多线程</a></li><li><a href="/iOS知识体系/线程锁.html" class="sidebar-link">线程锁</a></li><li><a href="/iOS知识体系/RunLoop.html" class="sidebar-link">RunLoop</a></li><li><a href="/iOS知识体系/动画.html" class="sidebar-link">动画</a></li><li><a href="/iOS知识体系/数据持久化.html" class="sidebar-link">数据持久化</a></li><li><a href="/iOS知识体系/加密.html" class="sidebar-link">加密</a></li><li><a href="/iOS知识体系/网络.html" class="sidebar-link">网络</a></li><li><a href="/iOS知识体系/设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/iOS知识体系/架构&amp;框架设计.html" class="sidebar-link">架构&amp;框架设计</a></li><li><a href="/iOS知识体系/第三方库.html" class="sidebar-link">第三方库</a></li><li><a href="/iOS知识体系/ReactNative.html" class="sidebar-link">React Native</a></li><li><a href="/iOS知识体系/算法.html" class="sidebar-link">算法</a></li><li><a href="/iOS知识体系/软件优化.html" class="sidebar-link">软件优化</a></li><li><a href="/iOS知识体系/Git.html" class="sidebar-link">Git</a></li><li><a href="/iOS知识体系/iOS内核.html" class="sidebar-link">iOS内核</a></li><li><a href="/iOS知识体系/视频及音频处理.html" class="sidebar-link">视频及音频处理</a></li><li><a href="/iOS知识体系/直播类软件实现方案.html" class="sidebar-link">直播类软件实现方案</a></li><li><a href="/iOS知识体系/聊天类软件实现方案.html" class="sidebar-link">聊天类软件实现方案</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>iOS笔记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="c"><a href="#c" class="header-anchor">#</a> C</h1> <h2 id="文件操作"><a href="#文件操作" class="header-anchor">#</a> 文件操作</h2> <h3 id="file-fp-fopen-文件名-使用文件的方式"><a href="#file-fp-fopen-文件名-使用文件的方式" class="header-anchor">#</a> FILE *fp = fopen(文件名, 使用文件的方式);</h3> <p>打开文件，是指为文件建立相应的信息区（用来存放有关文件的信息）和文件缓冲区（用来暂时存放输入输出的数据）</p> <ul><li><p>指定文件不存在会建立新文件，指定文件存在会删除旧文件</p> <ul><li>&quot;w&quot;只写</li> <li>&quot;wb&quot;写二进制</li> <li>&quot;w+&quot;读写</li> <li>&quot;wb+&quot;读写二进制</li></ul></li> <li><p>指定文件不存在时会出错</p> <ul><li>&quot;r&quot;只读</li> <li>&quot;r+&quot;读写</li> <li>&quot;rb&quot;读二进制</li> <li>&quot;rb+&quot;读写二进制</li> <li>&quot;a&quot;追加写</li> <li>&quot;a+&quot;追加读写</li> <li>&quot;ab&quot;追加二进制</li> <li>&quot;ab+&quot;读写二进制</li></ul></li></ul> <h3 id="int-ret-fclose-文件指针"><a href="#int-ret-fclose-文件指针" class="header-anchor">#</a> int ret = fclose(文件指针);</h3> <p>关闭是指撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，显然就无法再进行对文件的读写了</p> <h3 id="顺序读写"><a href="#顺序读写" class="header-anchor">#</a> 顺序读写</h3> <p>先写的数据存放在文件前面。
先读文件前面的数据。
每读一次就将文件位置标记向后移动一次，下次再从新位置读入。
每写一次就将文件写入位置向后移动一次，下次再从新位置写入。</p> <ul><li><p>char ch = fgetc(fp);</p> <p>读一个字符</p></li> <li><p>char ch = fputc(ch, fp);</p> <p>把字符ch写入到fp中</p></li> <li><p>char * result = fgets(char * str, int n, FILE *fp);</p> <p>从fp中读一个长度为n-1（因为最后会追加一个'\0'，所以只能读n-1）的字符串，存放到字符数组str中。返回结果为str的地址。</p></li> <li><p>int ret = fputs(str, fp);</p> <p>把str写入到文件fp中</p></li> <li><p>fprintf(文件指针，格式字符串，输出表列);</p> <p>格式化打印到磁盘</p></li> <li><p>fscanf(文件指针，格式字符串，输入表列);</p> <p>格式化输入到内存</p></li> <li><p>fread(buffer, size, count, fp);</p> <p>buffer：是一个地址，用来存放从文件读入的数据的存储区的地址。	
size：要读取的字节数。
count：要读多少个数据项（每个数据项长度为size）</p></li> <li><p>fwrite(buffer, size, count, fp);</p> <p>buffer：要把此地址开始的存储区中的数据向文件输出。
size：要写入的字节数。
count：要写多少个数据项（每个数据项长度为size）</p></li></ul> <h3 id="随机读写"><a href="#随机读写" class="header-anchor">#</a> 随机读写</h3> <p>可以对任何位置上的数据进行访问。通过移动文件位置标记的位置，可以从任何位置进行读写。</p> <ul><li><p>rewind(FILE *fp)</p> <p>使文件位置标记指向文件开头</p></li> <li><p>fseek(文件类型指针，位移量，起始点)</p> <p>起始点：SEEK_SET(0表示)，从文件开始位置计算。SEEK_CUR(1表示)，从当前位置开始计算。SEEK_END(2表示)，从文件末尾开始计算。</p></li> <li><p>ftell</p> <p>获取文件位置标记的当前位置</p></li> <li><p>ferror(fp)</p> <p>检查之前的操作是否出错</p></li> <li><p>clearerr</p> <p>使文件错误标志和文件结束标志置为0</p></li></ul> <h2 id="数组int-a-10-1-2-3"><a href="#数组int-a-10-1-2-3" class="header-anchor">#</a> 数组int a[10]={1,2,3}</h2> <h3 id="a"><a href="#a" class="header-anchor">#</a> a</h3> <p>取数组第一个元素的指针</p> <h3 id="a-i"><a href="#a-i" class="header-anchor">#</a> a+i</h3> <p>取数组第i个元素的指针</p> <h3 id="int-p1-p2-x-p1-p2"><a href="#int-p1-p2-x-p1-p2" class="header-anchor">#</a> int *p1, *p2; x = p1-p2</h3> <p>x表示p1和p2相隔几个元素</p> <h3 id="如果int-p-a-则p-i-等价于a-i-和-p-i"><a href="#如果int-p-a-则p-i-等价于a-i-和-p-i" class="header-anchor">#</a> 如果int <em>p = a,则p[i]等价于a[i]和</em>(p+i)</h3> <h3 id="p"><a href="#p" class="header-anchor">#</a> p++</h3> <p>指向下一个元素，还是指针</p> <h3 id="p-2"><a href="#p-2" class="header-anchor">#</a> *p</h3> <p>指针指向的值，结果为真实值</p> <h3 id="p-3"><a href="#p-3" class="header-anchor">#</a> *p++</h3> <p>由于++和<em>同优先级，结合方向为自由向左，因此等价于</em>(p++)，先引用p的值，实现*p运算，然后再使p自增1。</p> <h3 id="p-4"><a href="#p-4" class="header-anchor">#</a> *(++p)</h3> <h3 id="p-5"><a href="#p-5" class="header-anchor">#</a> ++(*p)</h3> <h2 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h2> <h3 id="形参类型"><a href="#形参类型" class="header-anchor">#</a> 形参类型</h3> <ul><li><p>变量</p> <ul><li>值传递，不改变实参的值</li></ul></li> <li><p>数组名</p> <ul><li>传递的数组首元素地址，指针传递，可以改变实参的值</li></ul></li></ul> <h3 id="形参数组实际上是一个指针变量-并不是真正开辟一个数组空间-所以不必指定长度大小"><a href="#形参数组实际上是一个指针变量-并不是真正开辟一个数组空间-所以不必指定长度大小" class="header-anchor">#</a> 形参数组实际上是一个指针变量，并不是真正开辟一个数组空间，所以不必指定长度大小</h3> <h2 id="多维数组int-a-3-4-三行四列"><a href="#多维数组int-a-3-4-三行四列" class="header-anchor">#</a> 多维数组int a[3][4]，三行四列</h2> <div class="language-C extra-class"><pre class="language-c"><code>
<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">}</span>

</code></pre></div><h3 id="a和a-0-虽然地址一样-但是它们所表示含义不一样-一个代表二维数组的首地址-一个代表二维数组内部一维数组的首地址"><a href="#a和a-0-虽然地址一样-但是它们所表示含义不一样-一个代表二维数组的首地址-一个代表二维数组内部一维数组的首地址" class="header-anchor">#</a> a和a[0]虽然地址一样，但是它们所表示含义不一样，一个代表二维数组的首地址，一个代表二维数组内部一维数组的首地址</h3> <h3 id="a代表a-0-a-1代表a-1-a-2代表a-2-它们都指向内部数组首元素的地址-相当于-a-x-0-地址值相同"><a href="#a代表a-0-a-1代表a-1-a-2代表a-2-它们都指向内部数组首元素的地址-相当于-a-x-0-地址值相同" class="header-anchor">#</a> a代表a[0]，a+1代表a[1]，a+2代表a[2]，它们都指向内部数组首元素的地址，相当于&amp;a[x][0]，地址值相同</h3> <h3 id="a-0-a-1-a-2-即是地址-又是内部一维数组名-所以a-0-a-1-a-2-代表一维数组首元素的地址-即-a-0-0-a-1-0-a-2-0"><a href="#a-0-a-1-a-2-即是地址-又是内部一维数组名-所以a-0-a-1-a-2-代表一维数组首元素的地址-即-a-0-0-a-1-0-a-2-0" class="header-anchor">#</a> a[0]，a[1]，a[2]即是地址，又是内部一维数组名，所以a[0]，a[1]，a[2]代表一维数组首元素的地址，即&amp;a[0][0]，&amp;a[1][0]，&amp;a[2][0]</h3> <h3 id="既然a-x-代表第x个内部一维数组首元素地址-那么a-x-y就表示内部一维数组的第y个元素的地址"><a href="#既然a-x-代表第x个内部一维数组首元素地址-那么a-x-y就表示内部一维数组的第y个元素的地址" class="header-anchor">#</a> 既然a[x]代表第x个内部一维数组首元素地址，那么a[x]+y就表示内部一维数组的第y个元素的地址</h3> <h3 id="因为在一维数组中-a-i-和-a-i-都指向第i个元素的值-在二维数组中a-i-又代表地址-所以a-i-j和-a-i-j都代表-a-i-j-都是地址"><a href="#因为在一维数组中-a-i-和-a-i-都指向第i个元素的值-在二维数组中a-i-又代表地址-所以a-i-j和-a-i-j都代表-a-i-j-都是地址" class="header-anchor">#</a> 因为在一维数组中，a[i]和*(a+i)都指向第i个元素的值，在二维数组中a[i]又代表地址，所以a[i]+j和*(a+i)+j都代表&amp;a[i][j]，都是地址</h3> <h3 id="因为a-i-j和-a-i-j都代表某个元素的地址-那么-a-i-j-和-a-i-j-都是代表指向的确切值。"><a href="#因为a-i-j和-a-i-j都代表某个元素的地址-那么-a-i-j-和-a-i-j-都是代表指向的确切值。" class="header-anchor">#</a> 因为a[i]+j和*(a+i)+j都代表某个元素的地址，那么*(a[i]+j)和*(*(a+i)+j)都是代表指向的确切值。</h3> <h3 id="a-1和-a-1-有何区别-a-1代表第1行元素的首地址-a-1-可表示为a-i-也代表第1行元素的首地址"><a href="#a-1和-a-1-有何区别-a-1代表第1行元素的首地址-a-1-可表示为a-i-也代表第1行元素的首地址" class="header-anchor">#</a> a+1和*(a+1)有何区别？a+1代表第1行元素的首地址，*(a+1)可表示为a[i]，也代表第1行元素的首地址</h3> <h3 id="二维数组中-a-i、a-i-、-a-i-、-a-i-、-a-i-0-的值相等-a-i代表指向第i行的指针-类型是int-4-a-i-代表取出第i行的值-a-i-就是数组名-即一维数组首元素地址-所以-a-i-类型是int-而a-i-代表一维数组-是int-类型。-a-i-代表第i行的地址-类型是int-4-。-a-i-0-代表第i行第0列的地址-类型是int-。"><a href="#二维数组中-a-i、a-i-、-a-i-、-a-i-、-a-i-0-的值相等-a-i代表指向第i行的指针-类型是int-4-a-i-代表取出第i行的值-a-i-就是数组名-即一维数组首元素地址-所以-a-i-类型是int-而a-i-代表一维数组-是int-类型。-a-i-代表第i行的地址-类型是int-4-。-a-i-0-代表第i行第0列的地址-类型是int-。" class="header-anchor">#</a> 二维数组中，a+i、a[i]、<em>(a+i)、&amp;a[i]、&amp;a[i][0]的值相等，a+i代表指向第i行的指针，类型是int (</em>)[4]，<em>(a+i)代表取出第i行的值，</em>(a+i)就是数组名，即一维数组首元素地址，所以*(a+i)类型是int *，而a[i]代表一维数组，是int <em>类型。&amp;a[i]代表第i行的地址，类型是int (</em>)[4]。&amp;a[i][0]代表第i行第0列的地址，类型是int *。</h3> <h2 id="指针需要理解指向的概念-不仅仅地址相同-指向的概念也很重要"><a href="#指针需要理解指向的概念-不仅仅地址相同-指向的概念也很重要" class="header-anchor">#</a> 指针需要理解指向的概念，不仅仅地址相同，指向的概念也很重要</h2> <h3 id="a代表二维数组首元素的地址-a-0-代表二维数组第一行首元素的地址-a-0-0-代表第一行第一列首元素的地址。虽然他们的地址值相同-但是概念不同-这点非常重要"><a href="#a代表二维数组首元素的地址-a-0-代表二维数组第一行首元素的地址-a-0-0-代表第一行第一列首元素的地址。虽然他们的地址值相同-但是概念不同-这点非常重要" class="header-anchor">#</a> a代表二维数组首元素的地址，a[0]代表二维数组第一行首元素的地址，&amp;a[0][0]代表第一行第一列首元素的地址。虽然他们的地址值相同，但是概念不同，这点非常重要</h3> <h3 id="int-p-4-和int-p-4-不同。"><a href="#int-p-4-和int-p-4-不同。" class="header-anchor">#</a> int (*p)[4]和int *p[4]不同。</h3> <ul><li><p>(*p)[4]表示指向数组的指针，即表示(*p)有四个元素，每个元素为整型，也就是p所指的对象是有4个整型元素的数组，即p是指向一维数组的指针，不能指向一维数组中的某一元素，(*p)[0]、(*p)[1]、(*p)[2]、(*p)[3]、分别代表各元素的确切值。例如int a[4]={1,3,5,7}，将p指向数组，即p = &amp;a，这里用了&amp;取地址符，&amp;不能省略，因为p=a表示指向a[0]，而p=&amp;a表示指向一维数组</p> <ul><li><p>int a[4] = {1,3,5,7};
int (*p)[4];
int *q;
p = &amp;a;
q =  a;
printf(&quot;%d---%d&quot;,(<em>p)[3],</em>(q+3));</p> <ul><li>p的基类型是int(*)[4]，类型长度是16字节，而q的基类型是int *，类型长度是4字节</li></ul></li> <li><p>int a[3][4] = {1,3,5,7,9,11,13,15,17,19,21,23};
int (*p)[4];
int <em>q;
p = a;
q = <em>a;
printf(&quot;%d&quot;,</em>(</em>(p+1)+2));</p> <ul><li>根据数组名代表首元素的地址这一原则，因为p的基类型是int(<em>)[4]，类型长度是16字节，所以p+1时，p的地址就会增加16字节，示例数组中p表示指向a，即二维数组首元素的地址，因为首元素是一个一维数组，所以p就指向这个一维数组，类型是int(</em>)[4]。而q=*a；*a代表取出二维数组中第一行的值（依旧是指针），<em>a就是一维数组的数组名，根据数组名代表首元素的地址这一原则，所以</em>a就是第一行第一列元素的地址，所以它是int *类型。</li></ul></li></ul></li> <li><p>int * p[4]表示指针数组</p> <ul><li><p>数组中存放的是指针</p> <ul><li><p>p表示指向指针数组中第一个元素的指针，因为第一个元素本来就是指针，所以p就是指针的指针，即双重指针，p+i就是指向指针型数据的指针。可以用char **q来表示这个p+i指针</p> <ul><li><p>char **q的理解</p> <ul><li>分为两部分来看：char <em>和(</em> q)，后面的（*q）表示q是指针变量，前面的char *表示p指向的是char *型的数据，也就是说p指向一个字符指针变量，然后这个字符指针变量又指向一个字符型数据</li></ul></li></ul></li></ul></li></ul></li></ul> <h3 id="指向函数的指针int-p-int-int"><a href="#指向函数的指针int-p-int-int" class="header-anchor">#</a> 指向函数的指针int (*p)(int, int)</h3> <ul><li>p的类型为int (*) (int, int)</li> <li>即可通过函数名调用函数，也可通过函数指针调用函数</li> <li>和数组名代表数组首元素的地址类似，函数名代表该函数的入口地址</li></ul> <h3 id="返回值为int-类型的函数int-p-int-int"><a href="#返回值为int-类型的函数int-p-int-int" class="header-anchor">#</a> 返回值为int *类型的函数int *p(int, int)</h3> <h2 id="c语言对字符串常量是按字符数组处理的-在内存中开辟了一个字符数组用来存放该字符串常量-但是这个字符数组是没有名字的-所以只能通过指针变量来引用。"><a href="#c语言对字符串常量是按字符数组处理的-在内存中开辟了一个字符数组用来存放该字符串常量-但是这个字符数组是没有名字的-所以只能通过指针变量来引用。" class="header-anchor">#</a> C语言对字符串常量是按字符数组处理的，在内存中开辟了一个字符数组用来存放该字符串常量，但是这个字符数组是没有名字的，所以只能通过指针变量来引用。</h2> <h3 id="例如char-string-i-love-china"><a href="#例如char-string-i-love-china" class="header-anchor">#</a> 例如char *string = &quot;I love China!&quot;;</h3> <h3 id="但是这样写却是错的-int-a-123"><a href="#但是这样写却是错的-int-a-123" class="header-anchor">#</a> 但是这样写却是错的：int *a = 123;</h3> <h2 id="实参和形参的地址是两份-改变了形参的指向-实参的指向依旧不变"><a href="#实参和形参的地址是两份-改变了形参的指向-实参的指向依旧不变" class="header-anchor">#</a> 实参和形参的地址是两份，改变了形参的指向，实参的指向依旧不变</h2> <h3 id="比如字符串char-a-bcde-a指向字符串首地址-传入函数后形参可以指向cde-但是实参还是指向首地址"><a href="#比如字符串char-a-bcde-a指向字符串首地址-传入函数后形参可以指向cde-但是实参还是指向首地址" class="header-anchor">#</a> 比如字符串char *a = &quot;bcde&quot;;a指向字符串首地址，传入函数后形参可以指向cde，但是实参还是指向首地址</h3> <h2 id="存储类别"><a href="#存储类别" class="header-anchor">#</a> 存储类别</h2> <h3 id="静态存储区"><a href="#静态存储区" class="header-anchor">#</a> 静态存储区</h3> <p>程序整个运行期间不会被释放</p> <ul><li><p>static局部变量</p> <p>static局部变量作用域为本函数，其他函数无法访问，且只会初始化一次，整个程序运行期间不会被释放</p></li> <li><p>static全局变量</p> <p>将作用域限制在本文件范围内，其他文件无法用extern访问</p></li> <li><p>全局变量</p> <p>整个文件作用域范围内有效，其他文件可通过extern进行访问</p></li> <li><p>extern变量</p> <p>对于不同的文件，如果某个全局变量未加static，那么可通过extern来声明这个外部变量供自己使用。</p></li></ul> <h3 id="动态存储区"><a href="#动态存储区" class="header-anchor">#</a> 动态存储区</h3> <ul><li><p>栈</p> <ul><li><p>auto变量</p> <p>作用域为本函数</p></li> <li><p>register变量</p> <p>作用域为本函数</p></li></ul></li> <li><p>堆</p> <p>由于未在声明部分定义它们为变量或数组，因此不能通过变量名或数组名去引用这些数据，只能通过指针来引用。</p> <ul><li><p>malloc</p> <p>void * malloc(unsigned int size);分配size大小的连续空间，返回值是所分配区域的第一个字节的地址，即指针。内存空间不足时返回空指针，size表示字节数</p></li> <li><p>calloc</p> <p>void *calloc(unsigned n, unsigned size);分配n个size大小的连续空间</p></li> <li><p>free</p> <p>void free(void *p);释放内存空间</p></li> <li><p>realloc</p> <p>void *realloc(void *p, unsigned int size);如果已经通过malloc函数或calloc函数获得了动态空间，想改变其大小，可以用realloc函数重新分配，这样p的值不变。相当于在同一个位置开辟空间。size为字节数</p></li></ul></li></ul> <h3 id="程序区"><a href="#程序区" class="header-anchor">#</a> 程序区</h3> <h2 id="函数类别"><a href="#函数类别" class="header-anchor">#</a> 函数类别</h2> <h3 id="内部函数"><a href="#内部函数" class="header-anchor">#</a> 内部函数</h3> <p>内部函数用static声明，即作用域限制在本文件，其他文件不可调用，又称静态函数</p> <h3 id="外部函数"><a href="#外部函数" class="header-anchor">#</a> 外部函数</h3> <p>使用extern或者不使用extern，表示外部函数，C语言默认的都是外部函数，extern可以省略。</p> <h2 id="void"><a href="#void" class="header-anchor">#</a> void *</h2> <p>指向空类型的指针，指向不确定类型的指针</p> <h2 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h2> <h3 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h3> <h3 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h3> <ul><li><p>静态链表</p> <p>通过简单的初始化、赋值来创建</p></li> <li><p>动态链表</p> <p>通过malloc、calloc、realloc函数创建</p></li></ul> <h2 id="共用体"><a href="#共用体" class="header-anchor">#</a> 共用体</h2> <p>几个不同的变量共享同一段内存的结构，就是共用体类型</p> <h3 id="union"><a href="#union" class="header-anchor">#</a> union</h3> <p>定义和结构体类似，关键字不一样。采用覆盖技术，后一个数据覆盖前面的数据。</p> <h2 id="结构体区分"><a href="#结构体区分" class="header-anchor">#</a> 结构体区分</h2> <h3 id="struct-student"><a href="#struct-student" class="header-anchor">#</a> struct Student</h3> <p>{
long num;
};</p> <ul><li>一般定义</li></ul> <h3 id="typedef-struct"><a href="#typedef-struct" class="header-anchor">#</a> typedef struct</h3> <p>{
long num;
} Student1;</p> <ul><li>将匿名结构体重定义为Student1类型</li></ul> <h3 id="struct"><a href="#struct" class="header-anchor">#</a> struct</h3> <p>{
long num;
} stu;</p> <ul><li>用匿名结构体初始化一个stu</li></ul> <h3 id="struct-student2"><a href="#struct-student2" class="header-anchor">#</a> struct Student2</h3> <p>{
long num;
} stu1;</p> <ul><li>定义结构体的同时，初始化一个stu1</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9de76d75.js" defer></script><script src="/assets/js/2.98ea7a63.js" defer></script><script src="/assets/js/45.0c29263b.js" defer></script>
  </body>
</html>
