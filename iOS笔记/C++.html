<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | 文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.9de76d75.js" as="script"><link rel="preload" href="/assets/js/2.98ea7a63.js" as="script"><link rel="preload" href="/assets/js/44.50e2b10d.js" as="script"><link rel="prefetch" href="/assets/js/10.fa8eed47.js"><link rel="prefetch" href="/assets/js/11.f98f25e0.js"><link rel="prefetch" href="/assets/js/12.1ab9b5a3.js"><link rel="prefetch" href="/assets/js/13.75251b00.js"><link rel="prefetch" href="/assets/js/14.b5068189.js"><link rel="prefetch" href="/assets/js/15.33abd7e1.js"><link rel="prefetch" href="/assets/js/16.34ed8053.js"><link rel="prefetch" href="/assets/js/17.b3d52ea3.js"><link rel="prefetch" href="/assets/js/18.cbe71205.js"><link rel="prefetch" href="/assets/js/19.c632cb86.js"><link rel="prefetch" href="/assets/js/20.90d9a221.js"><link rel="prefetch" href="/assets/js/21.15cb7700.js"><link rel="prefetch" href="/assets/js/22.62ea968a.js"><link rel="prefetch" href="/assets/js/23.b743fdd5.js"><link rel="prefetch" href="/assets/js/24.5d157647.js"><link rel="prefetch" href="/assets/js/25.1935fba3.js"><link rel="prefetch" href="/assets/js/26.fd22f8ee.js"><link rel="prefetch" href="/assets/js/27.f47adfe7.js"><link rel="prefetch" href="/assets/js/28.d9f5719d.js"><link rel="prefetch" href="/assets/js/29.82cbf665.js"><link rel="prefetch" href="/assets/js/3.b96f613e.js"><link rel="prefetch" href="/assets/js/30.9f901f01.js"><link rel="prefetch" href="/assets/js/31.d9e2f61c.js"><link rel="prefetch" href="/assets/js/32.b14052e9.js"><link rel="prefetch" href="/assets/js/33.1b2e5efd.js"><link rel="prefetch" href="/assets/js/34.4bf7f44f.js"><link rel="prefetch" href="/assets/js/35.98d5fd2b.js"><link rel="prefetch" href="/assets/js/36.cdaf1c2f.js"><link rel="prefetch" href="/assets/js/37.a67bdb9a.js"><link rel="prefetch" href="/assets/js/38.5d856b83.js"><link rel="prefetch" href="/assets/js/39.27169c95.js"><link rel="prefetch" href="/assets/js/4.268c621c.js"><link rel="prefetch" href="/assets/js/40.8763c647.js"><link rel="prefetch" href="/assets/js/41.cd839f43.js"><link rel="prefetch" href="/assets/js/42.a97bf97a.js"><link rel="prefetch" href="/assets/js/43.fd126bb1.js"><link rel="prefetch" href="/assets/js/45.0c29263b.js"><link rel="prefetch" href="/assets/js/46.fdee27aa.js"><link rel="prefetch" href="/assets/js/47.c7c7e966.js"><link rel="prefetch" href="/assets/js/48.80bc6f0a.js"><link rel="prefetch" href="/assets/js/49.d457b0ac.js"><link rel="prefetch" href="/assets/js/5.f577ebb9.js"><link rel="prefetch" href="/assets/js/50.cea3b0e6.js"><link rel="prefetch" href="/assets/js/51.eaab3e31.js"><link rel="prefetch" href="/assets/js/52.010a2dfb.js"><link rel="prefetch" href="/assets/js/53.3622f7b6.js"><link rel="prefetch" href="/assets/js/54.817aba2b.js"><link rel="prefetch" href="/assets/js/55.c3984ff9.js"><link rel="prefetch" href="/assets/js/56.6f20785e.js"><link rel="prefetch" href="/assets/js/57.07c7f6fc.js"><link rel="prefetch" href="/assets/js/58.4ec50d24.js"><link rel="prefetch" href="/assets/js/59.626b42b0.js"><link rel="prefetch" href="/assets/js/6.b9249342.js"><link rel="prefetch" href="/assets/js/60.ba2af5c7.js"><link rel="prefetch" href="/assets/js/61.6e22c298.js"><link rel="prefetch" href="/assets/js/62.df85ea27.js"><link rel="prefetch" href="/assets/js/63.cd3c1f6a.js"><link rel="prefetch" href="/assets/js/64.d0f75a86.js"><link rel="prefetch" href="/assets/js/65.12e0c392.js"><link rel="prefetch" href="/assets/js/66.aac422ac.js"><link rel="prefetch" href="/assets/js/67.3ff890c6.js"><link rel="prefetch" href="/assets/js/68.c6d12518.js"><link rel="prefetch" href="/assets/js/69.455e0c09.js"><link rel="prefetch" href="/assets/js/7.375eddd0.js"><link rel="prefetch" href="/assets/js/70.73d975e7.js"><link rel="prefetch" href="/assets/js/71.66528e07.js"><link rel="prefetch" href="/assets/js/72.a608a326.js"><link rel="prefetch" href="/assets/js/73.b8ed0811.js"><link rel="prefetch" href="/assets/js/74.68f4db5d.js"><link rel="prefetch" href="/assets/js/75.85059bdc.js"><link rel="prefetch" href="/assets/js/8.a04b9d9b.js"><link rel="prefetch" href="/assets/js/9.04a00c43.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>iOS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>iOS笔记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iOS笔记/工具.html" class="sidebar-link">工具</a></li><li><a href="/iOS笔记/计算机网络.html" class="sidebar-link">计算机网络</a></li><li><a href="/iOS笔记/架构.html" class="sidebar-link">架构</a></li><li><a href="/iOS笔记/视频播放器设计（基于FFmpeg）.html" class="sidebar-link">视频播放器设计（基于FFmpeg）</a></li><li><a href="/iOS笔记/视频常识.html" class="sidebar-link">视频常识</a></li><li><a href="/iOS笔记/数据结构与算法分析.html" class="sidebar-link">数据结构与算法分析</a></li><li><a href="/iOS笔记/算法.html" class="sidebar-link">算法</a></li><li><a href="/iOS笔记/音频常识.html" class="sidebar-link">音频常识</a></li><li><a href="/iOS笔记/音视频开发.html" class="sidebar-link">音视频开发</a></li><li><a href="/iOS笔记/直播.html" class="sidebar-link">直播</a></li><li><a href="/iOS笔记/App启动优化.html" class="sidebar-link">App启动优化</a></li><li><a href="/iOS笔记/Audio.html" class="sidebar-link">Audio</a></li><li><a href="/iOS笔记/AudioToolbox.html" class="sidebar-link">AudioToolbox</a></li><li><a href="/iOS笔记/AVFoundation.html" class="sidebar-link">AVFoundation</a></li><li><a href="/iOS笔记/C.html#.html" class="sidebar-link">C</a></li><li><a href="/iOS笔记/C.html#.html" class="sidebar-link">C#</a></li><li><a href="/iOS笔记/C++.html" class="active sidebar-link">C++</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#虚函数" class="sidebar-link">虚函数</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#纯虚函数" class="sidebar-link">纯虚函数</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#虚析构函数" class="sidebar-link">虚析构函数</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#虚基类" class="sidebar-link">虚基类</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#抽象类" class="sidebar-link">抽象类</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#类的特性" class="sidebar-link">类的特性</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#模板" class="sidebar-link">模板</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#逗号表达式" class="sidebar-link">逗号表达式</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#内联函数inline" class="sidebar-link">内联函数inline</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#重载" class="sidebar-link">重载</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#c-中字符串是const-char数组-所以在使用指针变量指向字符串需要加const-char-p-abcd-但这并不表示p是不可改变的指针-我们可以任意改变p的指向-例如-p-123" class="sidebar-link">c++中字符串是const char数组，所以在使用指针变量指向字符串需要加const char *p = &quot;abcd&quot;;但这并不表示p是不可改变的指针，我们可以任意改变p的指向，例如：p = &quot;123&quot;;</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#字符串操作" class="sidebar-link">字符串操作</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#字符串类string" class="sidebar-link">字符串类string</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#内存的动态分配和静态分配" class="sidebar-link">内存的动态分配和静态分配</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#对象的赋值与复制" class="sidebar-link">对象的赋值与复制</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#静态数据成员" class="sidebar-link">静态数据成员</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#静态成员函数" class="sidebar-link">静态成员函数</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#友元" class="sidebar-link">友元</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#运算符重载-2" class="sidebar-link">运算符重载</a></li><li class="sidebar-sub-header"><a href="/iOS笔记/C++.html#编译c" class="sidebar-link">编译c++</a></li></ul></li><li><a href="/iOS笔记/CoreAudio.html" class="sidebar-link">CoreAudio</a></li><li><a href="/iOS笔记/CoreVideo.html" class="sidebar-link">CoreVideo</a></li><li><a href="/iOS笔记/FFmpeg.html" class="sidebar-link">FFmpeg</a></li><li><a href="/iOS笔记/Flutter.html" class="sidebar-link">Flutter</a></li><li><a href="/iOS笔记/GPUImage.html" class="sidebar-link">GPUImage</a></li><li><a href="/iOS笔记/ijkPlayer.html" class="sidebar-link">ijkPlayer</a></li><li><a href="/iOS笔记/iOS细节.html" class="sidebar-link">iOS细节</a></li><li><a href="/iOS笔记/iOS性能优化.html" class="sidebar-link">iOS性能优化</a></li><li><a href="/iOS笔记/LFLiveKit.html" class="sidebar-link">LFLiveKit</a></li><li><a href="/iOS笔记/Metal.html" class="sidebar-link">Metal</a></li><li><a href="/iOS笔记/Objective-C.html" class="sidebar-link">Objective-C</a></li><li><a href="/iOS笔记/OpenGL相关概念.html" class="sidebar-link">OpenGL相关概念</a></li><li><a href="/iOS笔记/pthread.html" class="sidebar-link">pthread</a></li><li><a href="/iOS笔记/ReactNative.html" class="sidebar-link">React Native</a></li><li><a href="/iOS笔记/RunLoop.html" class="sidebar-link">RunLoop</a></li><li><a href="/iOS笔记/UI视图.html" class="sidebar-link">UI视图</a></li><li><a href="/iOS笔记/VideoToolbox.html" class="sidebar-link">VideoToolbox</a></li><li><a href="/iOS笔记/WebAssembly.html" class="sidebar-link">WebAssembly</a></li><li><a href="/iOS笔记/WebRTC.html" class="sidebar-link">WebRTC</a></li><li><a href="/iOS笔记/第三方.html" class="sidebar-link">第三方</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="c"><a href="#c" class="header-anchor">#</a> C++</h1> <h2 id="虚函数"><a href="#虚函数" class="header-anchor">#</a> 虚函数</h2> <p>虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类的同名函数。在基类中声明虚函数后，派生类的继承函数自动为虚函数，派生内的virtual可以省略</p> <h3 id="更加方便让父类指针调用子类中继承至父类的方法"><a href="#更加方便让父类指针调用子类中继承至父类的方法" class="header-anchor">#</a> 更加方便让父类指针调用子类中继承至父类的方法</h3> <h3 id="virtual-void-display"><a href="#virtual-void-display" class="header-anchor">#</a> virtual void display();</h3> <h2 id="纯虚函数"><a href="#纯虚函数" class="header-anchor">#</a> 纯虚函数</h2> <p>定义虚函数的地方没有实现该方法，直接 = 0表示这是一个纯虚函数，本身自己不用实现该方法，由派生类实现。</p> <h3 id="virtual-函数类型-函数名-参数表列-0"><a href="#virtual-函数类型-函数名-参数表列-0" class="header-anchor">#</a> virtual 函数类型 函数名 （参数表列）=  0;</h3> <h2 id="虚析构函数"><a href="#虚析构函数" class="header-anchor">#</a> 虚析构函数</h2> <p>如果派生类的对象在堆内存空间创建(new)，用基类的指针指向这个派生对象，在delete释放该指针时不会调用派生类的析构函数，通过声明为虚析构函数，在delete时会自动调用派生类的析构函数。</p> <h2 id="虚基类"><a href="#虚基类" class="header-anchor">#</a> 虚基类</h2> <h3 id="class-b-virtual-public-a"><a href="#class-b-virtual-public-a" class="header-anchor">#</a> class B: virtual public A;</h3> <p>class C: virtual public A;
class D: public B, public C;</p> <p>如果定义了虚基类，那么在D中仅仅只会有一份A成员变量或者成员函数的拷贝，所以在D中访问基类成员时，不用指定是通过B还是C继承过来的。</p> <ul><li><p>A是B的虚基类；A是C的虚基类；</p> <p>如果虚基类中定义了带参数的构造函数且未定义默认构造函数，那么派生类则通过构造函数初始化表对虚基类进行初始化。也就是说后面派生类的派生类都要调用虚基类的构造函数。</p></li></ul> <h2 id="抽象类"><a href="#抽象类" class="header-anchor">#</a> 抽象类</h2> <p>不用来定义对象只作为一种基本类型用作继承的类称为抽象类。虽然抽象类不能用来定义对象，但是可以定义指向抽象类的指针变量。</p> <h3 id="如果包含纯虚函数-那就是抽象类-不能用来创建对象。"><a href="#如果包含纯虚函数-那就是抽象类-不能用来创建对象。" class="header-anchor">#</a> 如果包含纯虚函数，那就是抽象类，不能用来创建对象。</h3> <h3 id="如果不包含纯虚函数-那么就不是抽象类-可以用来创建对象。"><a href="#如果不包含纯虚函数-那么就不是抽象类-可以用来创建对象。" class="header-anchor">#</a> 如果不包含纯虚函数，那么就不是抽象类，可以用来创建对象。</h3> <h2 id="类的特性"><a href="#类的特性" class="header-anchor">#</a> 类的特性</h2> <h3 id="c-类默认都有一个隐式的无参构造函数-如果我们在类外实现这个无参构造函数-那么必须显示的在类当中进行声明。"><a href="#c-类默认都有一个隐式的无参构造函数-如果我们在类外实现这个无参构造函数-那么必须显示的在类当中进行声明。" class="header-anchor">#</a> C++类默认都有一个隐式的无参构造函数，如果我们在类外实现这个无参构造函数，那么必须显示的在类当中进行声明。</h3> <h3 id="如果子类不写构造函数-在初始化子类时-c-默认也会调用父类的无参构造函数"><a href="#如果子类不写构造函数-在初始化子类时-c-默认也会调用父类的无参构造函数" class="header-anchor">#</a> 如果子类不写构造函数，在初始化子类时，C++默认也会调用父类的无参构造函数</h3> <h3 id="如果我们定义了自己的有参构造函数-那么c-为我们创建的隐式构造函数就会失效"><a href="#如果我们定义了自己的有参构造函数-那么c-为我们创建的隐式构造函数就会失效" class="header-anchor">#</a> 如果我们定义了自己的有参构造函数，那么C++为我们创建的隐式构造函数就会失效</h3> <h3 id="如果子类构造函数初始化时没有调用父类的构造函数-那么c-会默认调用父类的无参数构造函数"><a href="#如果子类构造函数初始化时没有调用父类的构造函数-那么c-会默认调用父类的无参数构造函数" class="header-anchor">#</a> 如果子类构造函数初始化时没有调用父类的构造函数，那么C++会默认调用父类的无参数构造函数</h3> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <p>public:类外可以访问，类内可以访问，子类可以访问，可被继承
protected:类外不能访问，类内可以访问，子类可以访问，可被继承
private:类外不能访问，类内可以访问，子类不能访问，不能被继承</p> <h3 id="class-b-public-a"><a href="#class-b-public-a" class="header-anchor">#</a> class B: public A</h3> <ul><li>类B继承类A的public和protected成员，继承后在B中仍然为public和protected</li></ul> <h3 id="class-b-protected-a"><a href="#class-b-protected-a" class="header-anchor">#</a> class B: protected A</h3> <ul><li>类B继承类A的public和protected成员，继承后A中的public和protected成员在B中变成protected成员</li></ul> <h3 id="class-b-private-a"><a href="#class-b-private-a" class="header-anchor">#</a> class B:private A</h3> <ul><li>类B继承类A的public和protected成员，继承后A中的public和protected成员在B中变成private成员</li></ul> <h2 id="模板"><a href="#模板" class="header-anchor">#</a> 模板</h2> <h3 id="函数模板-即泛型函数"><a href="#函数模板-即泛型函数" class="header-anchor">#</a> 函数模板（即泛型函数）</h3> <ul><li><p>template <typename T="">
T max(T a, T b, T c)
{
if (b &gt; a) a = b;
if (c &gt; a) a = c;
return a;
}</typename></p> <p>typename也可以写class</p></li></ul> <h3 id="类模板-其实和函数模板没区别-只是用法的不同"><a href="#类模板-其实和函数模板没区别-只是用法的不同" class="header-anchor">#</a> 类模板，其实和函数模板没区别，只是用法的不同</h3> <ul><li><p>Compare<int> cmp(4,7);</int></p> <p>使用模板类初始化一个对象</p></li> <li><p>void Compare<T>::max();</T></p> <p>类内声明，类外定义需要加上T</p></li></ul> <h2 id="逗号表达式"><a href="#逗号表达式" class="header-anchor">#</a> 逗号表达式</h2> <h3 id="a-3-5-a-4"><a href="#a-3-5-a-4" class="header-anchor">#</a> a = 3 * 5, a * 4;</h3> <p>结果为60</p> <h3 id="a-3-5-a-4-a-5"><a href="#a-3-5-a-4-a-5" class="header-anchor">#</a> (a=3 * 5, a * 4), a + 5;</h3> <p>结果为 20</p> <h2 id="内联函数inline"><a href="#内联函数inline" class="header-anchor">#</a> 内联函数inline</h2> <p>在编译时将被调函数嵌入到主调函数中去，可以节省内存空间，因为在调用函数时，主调函数不再需要保护现场了</p> <h2 id="重载"><a href="#重载" class="header-anchor">#</a> 重载</h2> <h3 id="函数的重载"><a href="#函数的重载" class="header-anchor">#</a> 函数的重载</h3> <p>c++可以函数重载，即函数名相同，参数的个数和参数类型不同，所以仍然会有不同的函数体，因为它们仍然是多个函数</p> <h3 id="运算符重载"><a href="#运算符重载" class="header-anchor">#</a> 运算符重载</h3> <h2 id="c-中字符串是const-char数组-所以在使用指针变量指向字符串需要加const-char-p-abcd-但这并不表示p是不可改变的指针-我们可以任意改变p的指向-例如-p-123"><a href="#c-中字符串是const-char数组-所以在使用指针变量指向字符串需要加const-char-p-abcd-但这并不表示p是不可改变的指针-我们可以任意改变p的指向-例如-p-123" class="header-anchor">#</a> c++中字符串是const char数组，所以在使用指针变量指向字符串需要加const char *p = &quot;abcd&quot;;但这并不表示p是不可改变的指针，我们可以任意改变p的指向，例如：p = &quot;123&quot;;</h2> <h3 id="指向常量的指针"><a href="#指向常量的指针" class="header-anchor">#</a> 指向常量的指针</h3> <p>可以改变指针的指向，但不能改变变量的值</p> <ul><li>const Time *box;或者Time const *box;</li></ul> <h3 id="常指针"><a href="#常指针" class="header-anchor">#</a> 常指针</h3> <p>不能改变指针的指向，可以改变对象的值</p> <ul><li>Time * const ptr1;</li></ul> <h3 id="常引用"><a href="#常引用" class="header-anchor">#</a> 常引用</h3> <p>常引用不能对引用变量重新赋值</p> <ul><li>void fun(const Box &amp;t)
{
t.a = 100;//t接收实参的地址，用点访问
t-&gt;a = 1000;//错误，t不是指针，不能用箭头访问
}</li></ul> <h2 id="字符串操作"><a href="#字符串操作" class="header-anchor">#</a> 字符串操作</h2> <h3 id="int-ret-strcmp-char-const-char"><a href="#int-ret-strcmp-char-const-char" class="header-anchor">#</a> int ret = strcmp(char [], const char []);</h3> <h3 id="char-result-strcpy-char-const-char"><a href="#char-result-strcpy-char-const-char" class="header-anchor">#</a> char *result = strcpy(char [], const char []);</h3> <p>将第二个参数的字符串复制到第一个参数当中，将第一个字符串全部覆盖</p> <h3 id="char-result-strcat-char-const-char"><a href="#char-result-strcat-char-const-char" class="header-anchor">#</a> char *result = strcat(char [], const char []);</h3> <p>将第二个参数的字符连接到第一个参数当中，返回值为字符串首地址。</p> <h3 id="int-length-strlen-const-char"><a href="#int-length-strlen-const-char" class="header-anchor">#</a> int length = strlen(const char[]);</h3> <h2 id="字符串类string"><a href="#字符串类string" class="header-anchor">#</a> 字符串类string</h2> <h3 id="string-string1-china"><a href="#string-string1-china" class="header-anchor">#</a> string string1 = &quot;China&quot;;</h3> <h2 id="内存的动态分配和静态分配"><a href="#内存的动态分配和静态分配" class="header-anchor">#</a> 内存的动态分配和静态分配</h2> <p>调用对象既可以通过对象名，也可以通过指针，静态分配的内存通过对象名访问，动态分配的内存通过指针访问</p> <h3 id="静态分配"><a href="#静态分配" class="header-anchor">#</a> 静态分配</h3> <p>普通方法创建的对象都是静态分配，只有在函数结束时才会进行释放，例如：</p> <ul><li>Box box1(1,2,3)</li></ul> <h3 id="动态分配"><a href="#动态分配" class="header-anchor">#</a> 动态分配</h3> <p>c++中new或者c中malloc/calloc/realloc分配的内存，可以随时通过delete或者free释放，例如：delete [] pt; delete p;动态分配内存后，将返回一个指向对象的指针。</p> <ul><li>Box *pt = new Box(1,2,3);</li></ul> <h2 id="对象的赋值与复制"><a href="#对象的赋值与复制" class="header-anchor">#</a> 对象的赋值与复制</h2> <h3 id="赋值"><a href="#赋值" class="header-anchor">#</a> 赋值</h3> <ul><li>对象名1 = 对象名2;</li></ul> <h3 id="复制"><a href="#复制" class="header-anchor">#</a> 复制</h3> <p>用对象2复制出对象1</p> <ul><li>类名 对象1(对象2)</li></ul> <h2 id="静态数据成员"><a href="#静态数据成员" class="header-anchor">#</a> 静态数据成员</h2> <p>所有对象共享，在静态存储区创建，只能在类外初始化，不就相当于类变量？</p> <h3 id="class-box"><a href="#class-box" class="header-anchor">#</a> class Box</h3> <p>{
static int a;//声明
};</p> <h3 id="初始化-int-box-a-10"><a href="#初始化-int-box-a-10" class="header-anchor">#</a> 初始化 int Box::a = 10;</h3> <h2 id="静态成员函数"><a href="#静态成员函数" class="header-anchor">#</a> 静态成员函数</h2> <p>同样只能在类外初始化，且不能和普通成员函数同名，不就相当于类方法？</p> <h3 id="class-box-2"><a href="#class-box-2" class="header-anchor">#</a> class Box</h3> <p>{
static int volume();
};</p> <h3 id="调用box-volume"><a href="#调用box-volume" class="header-anchor">#</a> 调用Box::volume();</h3> <h2 id="友元"><a href="#友元" class="header-anchor">#</a> 友元</h2> <h3 id="友元函数"><a href="#友元函数" class="header-anchor">#</a> 友元函数</h3> <p>如果在本类(class A)以外的其他地方(class B)定义了一个函数(可以是成员函数也可以不是成员函数)，在B中用friend对这个函数进行声明，此函数就称为A的友元函数。友元函数可以访问A的私有成员。一个函数可以被多个类声明为朋友</p> <ul><li><p>步骤</p> <p>类B中的display为类A的友元函数</p> <ul><li><ol><li>类A声明一个成员函数void display(B &amp;);不用实现该方法</li></ol></li> <li>2.类B中声明A的display为友元函数：friend void A::display(Date &amp;);</li> <li>3.类B中实现该display方法，那么在该实现中就可以访问A的私有变量了</li></ul></li></ul> <h3 id="友元类"><a href="#友元类" class="header-anchor">#</a> 友元类</h3> <p>在A类的定义体中用friend B;声明B类为A的友元类，那么B类就可以访问A类中的所有成员。</p> <h2 id="运算符重载-2"><a href="#运算符重载-2" class="header-anchor">#</a> 运算符重载</h2> <p>C++不允许定义新的运算符，只能对已有的运算符进行重载</p> <h3 id="h-operator-t-a-m-b"><a href="#h-operator-t-a-m-b" class="header-anchor">#</a> H operator + (T a, M b);</h3> <p>相当于把函数名改成：operator 运算符，T和M至少要有一个是类对象。</p> <h3 id="operator-double-return-real"><a href="#operator-double-return-real" class="header-anchor">#</a> operator double() { return real}</h3> <p>类型转换函数可以将类转换成其他的类型，这是隐式调用的，比如：double d = 2.5 + Complex(1,2)，其中Complex是类，但是它里面有隐式转换函数，所以可以这样加减</p> <h2 id="编译c"><a href="#编译c" class="header-anchor">#</a> 编译c++</h2> <h3 id="clang-std-c-11-g-o-test-test-cpp"><a href="#clang-std-c-11-g-o-test-test-cpp" class="header-anchor">#</a> clang++ -std=c++11 -g -o test test.cpp</h3> <p><em>XMind - Trial Version</em></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/iOS笔记/C.html#.html" class="prev">
        C#
      </a></span> <span class="next"><a href="/iOS笔记/CoreAudio.html">
        CoreAudio
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9de76d75.js" defer></script><script src="/assets/js/2.98ea7a63.js" defer></script><script src="/assets/js/44.50e2b10d.js" defer></script>
  </body>
</html>
