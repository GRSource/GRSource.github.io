<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>RunLoop | 文档</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.9de76d75.js" as="script"><link rel="preload" href="/assets/js/2.98ea7a63.js" as="script"><link rel="preload" href="/assets/js/8.a04b9d9b.js" as="script"><link rel="prefetch" href="/assets/js/10.fa8eed47.js"><link rel="prefetch" href="/assets/js/11.f98f25e0.js"><link rel="prefetch" href="/assets/js/12.1ab9b5a3.js"><link rel="prefetch" href="/assets/js/13.75251b00.js"><link rel="prefetch" href="/assets/js/14.b5068189.js"><link rel="prefetch" href="/assets/js/15.33abd7e1.js"><link rel="prefetch" href="/assets/js/16.34ed8053.js"><link rel="prefetch" href="/assets/js/17.b3d52ea3.js"><link rel="prefetch" href="/assets/js/18.cbe71205.js"><link rel="prefetch" href="/assets/js/19.c632cb86.js"><link rel="prefetch" href="/assets/js/20.90d9a221.js"><link rel="prefetch" href="/assets/js/21.15cb7700.js"><link rel="prefetch" href="/assets/js/22.62ea968a.js"><link rel="prefetch" href="/assets/js/23.b743fdd5.js"><link rel="prefetch" href="/assets/js/24.5d157647.js"><link rel="prefetch" href="/assets/js/25.1935fba3.js"><link rel="prefetch" href="/assets/js/26.fd22f8ee.js"><link rel="prefetch" href="/assets/js/27.f47adfe7.js"><link rel="prefetch" href="/assets/js/28.d9f5719d.js"><link rel="prefetch" href="/assets/js/29.82cbf665.js"><link rel="prefetch" href="/assets/js/3.b96f613e.js"><link rel="prefetch" href="/assets/js/30.9f901f01.js"><link rel="prefetch" href="/assets/js/31.d9e2f61c.js"><link rel="prefetch" href="/assets/js/32.b14052e9.js"><link rel="prefetch" href="/assets/js/33.1b2e5efd.js"><link rel="prefetch" href="/assets/js/34.4bf7f44f.js"><link rel="prefetch" href="/assets/js/35.98d5fd2b.js"><link rel="prefetch" href="/assets/js/36.cdaf1c2f.js"><link rel="prefetch" href="/assets/js/37.a67bdb9a.js"><link rel="prefetch" href="/assets/js/38.5d856b83.js"><link rel="prefetch" href="/assets/js/39.27169c95.js"><link rel="prefetch" href="/assets/js/4.268c621c.js"><link rel="prefetch" href="/assets/js/40.8763c647.js"><link rel="prefetch" href="/assets/js/41.cd839f43.js"><link rel="prefetch" href="/assets/js/42.a97bf97a.js"><link rel="prefetch" href="/assets/js/43.fd126bb1.js"><link rel="prefetch" href="/assets/js/44.50e2b10d.js"><link rel="prefetch" href="/assets/js/45.0c29263b.js"><link rel="prefetch" href="/assets/js/46.fdee27aa.js"><link rel="prefetch" href="/assets/js/47.c7c7e966.js"><link rel="prefetch" href="/assets/js/48.80bc6f0a.js"><link rel="prefetch" href="/assets/js/49.d457b0ac.js"><link rel="prefetch" href="/assets/js/5.f577ebb9.js"><link rel="prefetch" href="/assets/js/50.cea3b0e6.js"><link rel="prefetch" href="/assets/js/51.eaab3e31.js"><link rel="prefetch" href="/assets/js/52.010a2dfb.js"><link rel="prefetch" href="/assets/js/53.3622f7b6.js"><link rel="prefetch" href="/assets/js/54.817aba2b.js"><link rel="prefetch" href="/assets/js/55.c3984ff9.js"><link rel="prefetch" href="/assets/js/56.6f20785e.js"><link rel="prefetch" href="/assets/js/57.07c7f6fc.js"><link rel="prefetch" href="/assets/js/58.4ec50d24.js"><link rel="prefetch" href="/assets/js/59.626b42b0.js"><link rel="prefetch" href="/assets/js/6.b9249342.js"><link rel="prefetch" href="/assets/js/60.ba2af5c7.js"><link rel="prefetch" href="/assets/js/61.6e22c298.js"><link rel="prefetch" href="/assets/js/62.df85ea27.js"><link rel="prefetch" href="/assets/js/63.cd3c1f6a.js"><link rel="prefetch" href="/assets/js/64.d0f75a86.js"><link rel="prefetch" href="/assets/js/65.12e0c392.js"><link rel="prefetch" href="/assets/js/66.aac422ac.js"><link rel="prefetch" href="/assets/js/67.3ff890c6.js"><link rel="prefetch" href="/assets/js/68.c6d12518.js"><link rel="prefetch" href="/assets/js/69.455e0c09.js"><link rel="prefetch" href="/assets/js/7.375eddd0.js"><link rel="prefetch" href="/assets/js/70.73d975e7.js"><link rel="prefetch" href="/assets/js/71.66528e07.js"><link rel="prefetch" href="/assets/js/72.a608a326.js"><link rel="prefetch" href="/assets/js/73.b8ed0811.js"><link rel="prefetch" href="/assets/js/74.68f4db5d.js"><link rel="prefetch" href="/assets/js/75.85059bdc.js"><link rel="prefetch" href="/assets/js/9.04a00c43.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>iOS</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/iOS知识体系/UI视图.html" class="sidebar-link">UI视图</a></li><li><a href="/iOS知识体系/Objective-C.html" class="sidebar-link">Objective-C</a></li><li><a href="/iOS知识体系/Swift.html" class="sidebar-link">Swift</a></li><li><a href="/iOS知识体系/Runtime.html" class="sidebar-link">Runtime</a></li><li><a href="/iOS知识体系/内存管理.html" class="sidebar-link">内存管理</a></li><li><a href="/iOS知识体系/Block.html" class="sidebar-link">Block</a></li><li><a href="/iOS知识体系/多线程.html" class="sidebar-link">多线程</a></li><li><a href="/iOS知识体系/线程锁.html" class="sidebar-link">线程锁</a></li><li><a href="/iOS知识体系/RunLoop.html" class="active sidebar-link">RunLoop</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/iOS知识体系/RunLoop.html#runloop本质" class="sidebar-link">RunLoop本质</a></li><li class="sidebar-sub-header"><a href="/iOS知识体系/RunLoop.html#runloop数据结构" class="sidebar-link">RunLoop数据结构</a></li><li class="sidebar-sub-header"><a href="/iOS知识体系/RunLoop.html#runloop执行过程" class="sidebar-link">RunLoop执行过程</a></li><li class="sidebar-sub-header"><a href="/iOS知识体系/RunLoop.html#runloop事件循环机制" class="sidebar-link">RunLoop事件循环机制</a></li><li class="sidebar-sub-header"><a href="/iOS知识体系/RunLoop.html#runloop与多线程" class="sidebar-link">RunLoop与多线程</a></li></ul></li><li><a href="/iOS知识体系/动画.html" class="sidebar-link">动画</a></li><li><a href="/iOS知识体系/数据持久化.html" class="sidebar-link">数据持久化</a></li><li><a href="/iOS知识体系/加密.html" class="sidebar-link">加密</a></li><li><a href="/iOS知识体系/网络.html" class="sidebar-link">网络</a></li><li><a href="/iOS知识体系/设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/iOS知识体系/架构&amp;框架设计.html" class="sidebar-link">架构&amp;框架设计</a></li><li><a href="/iOS知识体系/第三方库.html" class="sidebar-link">第三方库</a></li><li><a href="/iOS知识体系/ReactNative.html" class="sidebar-link">React Native</a></li><li><a href="/iOS知识体系/算法.html" class="sidebar-link">算法</a></li><li><a href="/iOS知识体系/软件优化.html" class="sidebar-link">软件优化</a></li><li><a href="/iOS知识体系/Git.html" class="sidebar-link">Git</a></li><li><a href="/iOS知识体系/iOS内核.html" class="sidebar-link">iOS内核</a></li><li><a href="/iOS知识体系/视频及音频处理.html" class="sidebar-link">视频及音频处理</a></li><li><a href="/iOS知识体系/直播类软件实现方案.html" class="sidebar-link">直播类软件实现方案</a></li><li><a href="/iOS知识体系/聊天类软件实现方案.html" class="sidebar-link">聊天类软件实现方案</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>iOS笔记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="runloop"><a href="#runloop" class="header-anchor">#</a> RunLoop</h1> <h2 id="runloop本质"><a href="#runloop本质" class="header-anchor">#</a> RunLoop本质</h2> <p>什么是RunLoop?<br>
RunLoop是通过内部维护的事件循环来对事件/消息进行管理的一个对象。<br>
事件循环：</p> <ul><li>没有消息需要处理时，休眠以避免资源占用</li> <li>有消息需要处理时，立刻被唤醒</li></ul> <p>为了系统安全，有些指令只能通过系统来调用，有些指令通过用户来调用，所以就区分出了内核态和用户态。<br>
当一个进程在执行用户自己的代码时处于用户态，此时特权级最低，为Ring3，当一个进程因为系统调用陷入内核代码中执行时处于内核态，此时特权级最高Ring0，执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈，内核态的进程执行完后又会切换到Ring3，回到用户态。</p> <p>用户态切换到内核态的3种方式：</p> <ul><li>系统调用，比如文件读写、网络数据请求</li> <li>异常，当cpu在执行用户态下的程序时，发生了一些不可预知的异常，这是会触发进入处理异常的内核相关进程中，也就切换到了内核态。</li> <li>外围设备的中断，当外围设备发出中断请求信号后，cpu会转到处理中断信号的内核态。</li></ul> <p>问1：什么是事件循环？<br>
事件循环可以用来不断处理消息，对他们进行管理，同时当没有消息需要处理时，会从用户态到内核态的切换，由此可以用来进行当前线程的休眠，避免资源占用。当有消息需要处理时，会从内核态切换到用户态，唤醒当前线程。<br>
问2：main函数为什么能一直保持运行而不退出？<br>
在main函数中调用的UIApplication会启动主线程的runloop，而runloop是对事件循环的维护机制，可以做到在有事做的时候做事，没事做的时候会发生用户态到内核态的切换，避免资源的占用，当前线程处于休眠状态。</p> <h2 id="runloop数据结构"><a href="#runloop数据结构" class="header-anchor">#</a> RunLoop数据结构</h2> <p>NSRunLoop是对CFRunLoop的封装，提供了面向对象的API，NSRunLoop位于Foundation中，CFRunLoop位于CoreFoundation，我们主要来分析CFRunLoop。</p> <p>RunLoop的运行模式：</p> <ul><li>KCFRunLoopDefaultMode，App的默认运行模式，通常主线程是在这个运行模式下运行</li> <li>UITrackingRunLoopMode，跟踪用户交互事件（用于ScrollView追踪触摸滑动，保证界面滑动时不受其他mode影响）</li> <li>KCFRunLoopCommonModes，伪模式，不是一种真正的运行模式</li> <li>UIInitializationRunLoopMode，在刚启动App时进入的第一个Mode，启动完成后就不再使用</li> <li>GSEventReceiveRunLoopMode，接受系统内部事件，通常用不到</li></ul> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <ul><li>RunLoop只会运行在一个模式下</li> <li>要切换模式，就要暂停当前模式，重新启动一个运行模式</li></ul></div> <p>RunLoop主要有三种数据结构：</p> <ul><li>CFRunLoop</li> <li>CFRunLoopMode</li> <li>Source/Timer/Observer</li></ul> <h3 id="cfrunloop"><a href="#cfrunloop" class="header-anchor">#</a> CFRunLoop</h3> <p>主要包含：pthread、currentMode、modes、commonModes、commonModeItems
<img src="/assets/img/RunLoop包含关系.33173292.png" alt="RunLoop包含关系"> <img src="/assets/img/CFRunLoop.9ac45099.png" alt="CFRunLoop">
从上面可以看出一个RunLoop包含一个线程，也就是和线程是一一对应的；以及若干个Mode、若干个commonModeItem，还有一个当前运行的CurrentMode。如果在RunLoop中需要切换Mode，只能退出Loop，再重新指定一个Mode进入。这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响。</p> <h3 id="cfrunloopmode"><a href="#cfrunloopmode" class="header-anchor">#</a> CFRunLoopMode</h3> <p>主要包含：name、sources0、source1、observers、timers
<img src="/assets/img/CFRunLoopMode.2bd157f7.png" alt="CFRunLoopMode">
从上可以看出一个CFRunLoopMode对象有一个name，若干source0、source1、timer、observer和若干port，其中source，timer，observer数据结果被统称为mode item。上面提到的那几种mode（UITrackingRunLoopMode、GSEventReceiveRunLoopMode、kCFRunLoopDefaultMode、kCFRunLoopCommonMode），其实就是这里的name。</p> <p>只能通过mode的name字段(也就是字符串)操作内部的Mode，当你传入一个新的mode name但RunLoop内部没有对应mode时，RunLoop会自动帮你创建对应的CFRunLoopModeRef。对于一个RunLoop来说，其内部的mode只能增加不能删除。</p> <p>source、timer、observer可以再多个mode中注册，但是只有runloop当前的currentMode下的source、timer、observer才可以运行。</p> <p>Model暴露给外面管理Mode Item的接口：</p> <div class="language-C extra-class"><pre class="language-c"><code>
<span class="token function">CFRunLoopAddSource</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopSourceRef source<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CFRunLoopAddObserver</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopObserverRef observer<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CFRunLoopAddTimer</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopTimerRef timer<span class="token punctuation">,</span> CFStringRef mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CFRunLoopRemoveSource</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopSourceRef source<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CFRunLoopRemoveObserver</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopObserverRef observer<span class="token punctuation">,</span> CFStringRef modeName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">CFRunLoopRemoveTimer</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopTimerRef timer<span class="token punctuation">,</span> CFStringRef mode<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>CFRunLoopSource：
<img src="/assets/img/CFRunLoopSource.d06ce1ee.png" alt="CFRunLoopSource">
__CFRunLoopSource是事件产生的地方。Source有两个版本：Source0和Source1。</p> <ul><li>source0只包含了一个回调（函数指针），source0是需要手动触发的Source，<strong>它并不能主动触发事件，必须要先把它标记为Signal状态。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，也就是通过uint32_t _bits来实现的</strong>，只有_bits标记为Signaled状态才会被处理。然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件。</li> <li>source1包含了一个mach_port和一个回调（函数指针），<strong>被用于通过内核和其他线程互相发送消息。这种Source能主动唤醒RunLoop的线程</strong>。简单来说就更加偏向于底层。</li></ul> <p>source0：
<img src="/assets/img/source0.d7c1f84c.png" alt="source0">
source1：
<img src="/assets/img/source1.b412af4a.png" alt="source1">
source1除了多个了getPort。其余的字段含义和source0相同。作用就是当source被添加到mode中的时候，从这个函数中获得具体mach_port_t。</p> <p>CFRunLoopTimer：
<img src="/assets/img/CFRunLoopTimer.0efb1922.png" alt="CFRunLoopTimer">
它和NSTimer是toll-free bridged的(<a href="https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677" target="_blank" rel="noopener noreferrer">资料可以看这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。根据上面的分析一个timer可能会在多个mode中存在。</p> <p>CFRunLoopObserver：
<img src="/assets/img/CFRunLoopObserver.2429eb8e.png" alt="CFRunLoopObserver">
CFRunLoopObserver是观察者，可以观察RunLoop的各种状态，每个Observer都包含了一个回调（也就是上面的CFRunLoopObserverCallBack函数指针），当RunLoop状态发生变化时，观察者就能通过回调接收到这个变化。状态定义在_CF_OPTIONS：
<img src="/assets/img/CF_OPTIONS.bb477846.png" alt="CF_OPTIONS">
观察对象为：</p> <ul><li>KCFRunLoopEntry，即将进入runloop</li> <li>KCFRunLoopBeforeTimers，即将处理timer</li> <li>KCFRunLoopBeforeSources，即将处理source</li> <li>KCFRunLoopBeforeWaiting，即将进入休眠</li> <li>KCFRunLoopAfterWaiting，被唤醒但是还没处理事件</li> <li>KCFRunLoopExit，runloop已经退出</li> <li>KCFRunLoopAllActivities</li></ul> <h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>根据上面的数据结构，总结出如下内容。</p> <p>一个mode中有多个item，这些item由source、observe、timer组成。对于我们来讲用的最多的应该是observer和timer，常常通过回调来得知当前runloop的状态，进行来优化应用程序（比如监控在waiting状态下，这个时候做一些优化的事情）。其次设置定时器执行定时任务也是很常见的。</p> <p>一个runloop包含多个mode，但是runloop在一个时间点只会处于一种mode（KCFRunLoopDefaultMode、UITrackingRunLoopMode、）状态下也即是currentMode，如果该当前应用状态在另一种mode下，则该mode下的item（source、observer、timer）就不会工作。</p> <p>runloop其中有一个commonModes的数组，里面保存的是被标记为common的mode，这种标记为common的mode有种特性，那就是当RunLoop的内容发生变化时，RunLoop都会自动将commonModeItems里的Source/Observer/Timer同步到具有&quot;Common&quot;标记的所有所有Mode里。可以这样理解，runloop中的_commonModeItems由被标记为common的mode下的各个item(source、observer、timer)组成。</p> <p>Runloop初始化的时候的会把名字为kCFRunLoopDefaultMode、UITrackingRunLoopMode的model加入到common modesls数组里面，标记为common mode。</p> <h2 id="runloop执行过程"><a href="#runloop执行过程" class="header-anchor">#</a> RunLoop执行过程</h2> <p><img src="/assets/img/RunLoop执行过程.7aab9f00.png" alt="RunLoop执行过程"></p> <ul><li>如果指定了一个不存在的mode来运行RunLoop，那么会失败，mode不会被创建，所以这里传入的mode必须是存在的。</li> <li>如果指定了一个mode，但是这个mode中不包含任何modeItem，那么RunLoop也不会运行，所以必须传入至少包含一个modeItem的mode</li> <li>在进入runloop之后通知observer，状态为kCFRunLoopEntry</li> <li>在退出runloop之后通知observer，状态为kCFRunLoopExit</li> <li>CFRunLoopRun有五个参数：</li></ul> <div class="language-C extra-class"><pre class="language-c"><code><span class="token comment">/**
 *  运行run loop
 *
 *  @param rl              运行的RunLoop对象
 *  @param rlm             运行的mode
 *  @param seconds         run loop超时时间
 *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止
 *  @param previousMode    上一次运行的mode
 *
 *  @return 返回4种状态
 */</span>
<span class="token keyword">static</span> <span class="token class-name">int32_t</span> <span class="token function">__CFRunLoopRun</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFRunLoopModeRef rlm<span class="token punctuation">,</span> CFTimeInterval seconds<span class="token punctuation">,</span> Boolean stopAfterHandle<span class="token punctuation">,</span> CFRunLoopModeRef previousMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>CFRunLoop是基于pthread来管理的。iOS中不能直接创建RunLoop，只能从系统中获取CFRunLoopGetMain()和CFRunLoopGetCurrent()。</p> <div class="language-C extra-class"><pre class="language-c"><code>CFRunLoopRef <span class="token function">CFRunLoopGetCurrent</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取当前线程的RunLoop对象</span>
CFRunLoopRef <span class="token function">CFRunLoopGetMain</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取主线程的RunLoop对象</span>
<span class="token operator">+</span><span class="token punctuation">(</span>NSRunLoop <span class="token operator">*</span><span class="token punctuation">)</span>currentRunLoop
<span class="token operator">+</span><span class="token punctuation">(</span>NSRunLoop <span class="token operator">*</span><span class="token punctuation">)</span>mainRunLoop
</code></pre></div><p>获取当前线程RunLoop:
<img src="/assets/img/CFRunLoopGetCurrent.45f232e7.png" alt="CFRunLoopGetCurrent">
在CFRunLoopGetCurrent函数内部调用了_CFRunLoopGet0(),传入的参数是当前线程，这里可以看出CFRunLoopGetCurrent函数必须要在线程内部调用，才能获取当前线程的RunLoop。也就是说子线程的RunLoop必须要在子线程内部获取。</p> <p>获取主线程RunLoop:
<img src="/assets/img/CFRunLoopGetMain.87da6143.png" alt="CFRunLoopGetMain">
在CFRunLoopGetMain函数内部也调用了_CFRunLoopGet0(),传入的参数是主线程。可以看出，CFRunLoopGetMain()不管在主线程还是子线程中调用，都可以获取到主线程的RunLoop。</p> <ul><li>线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary中。</li> <li>线程刚创建时并没有RunLoop（没有加到对应的runloop字典中），如果你不主动获取，那么它一直都不会有</li> <li>RunLoop的创建是发生在第一次获取时。一般是获取主线程的时候。</li> <li>RunLoop的销毁是发生在线程结束时。</li> <li>只能在一个线程的内部获取其RunLoop（主线程除外），否则这个Runloop就没有注册销毁回调。因为上面讲过Runlopp暴露给外部的创建方式只有CFRunLoopGetMain() 和 CFRunLoopGetCurrent()两种，所以这种情况不用考虑。</li></ul> <div class="language-C extra-class"><pre class="language-c"><code><span class="token function">CFRunLoopAddCommonMode</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">,</span> CFStringRef mode<span class="token punctuation">)</span><span class="token comment">//向当前RunLoop的common modes中添加一个mode。</span>
CFStringRef <span class="token function">CFRunLoopCopyCurrentMode</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">)</span><span class="token comment">//返回当前运行的mode的name</span>
CFArrayRef <span class="token function">CFRunLoopCopyAllModes</span><span class="token punctuation">(</span>CFRunLoopRef rl<span class="token punctuation">)</span><span class="token comment">//返回当前RunLoop的所有mode</span>
</code></pre></div><p>我们没有办法直接创建一个CFRunLoopMode对象，但是我们可以调用CFRunLoopAddCommonMode传入一个字符串向RunLoop中添加Mode，传入的字符串即为Mode的名字，Mode对象应该是此时在RunLoop内部创建的。<strong>特别注意只能通过CFRunLoopAddCommonMode，是CommonMode</strong>。</p> <ul><li>modeName不能重复，modeName是mode的唯一标识符</li> <li>添加commonMode会把commonModeItems数组中的所有item(source,observer,time)同步到新添加的mode中。</li></ul> <p><strong>observer和timer只能被添加到一个RunLoop的一个或者多个mode中，比如一个timer被添加到主线程的RunLoop中，则不能再把该timer添加到子线程的RunLoop，而source没有这个限制，不管是哪个RunLoop，只要mode中没有，就可以添加。</strong></p> <h3 id="block"><a href="#block" class="header-anchor">#</a> Block</h3> <ul><li>block其实在runloop中通过循环链表保存的</li> <li>如果block可以加入到多个mode下面，但是执行block只有在加入的那个mode下才能执行，或者加入mode用common标记</li> <li>每次调用_CFRunLoopDoBlocks，会把加入的block遍历执行，然后重置循环链表</li></ul> <h3 id="autoreleasepool"><a href="#autoreleasepool" class="header-anchor">#</a> AutoreleasePool</h3> <p>App启动后，苹果在主线程RunLoop里注册了两个Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。</p> <p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p> <p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p> <h3 id="其他使用案例"><a href="#其他使用案例" class="header-anchor">#</a> 其他使用案例</h3> <p>RunLoop还在手势识别、界面更新(setNeedsLayout/setNeedsDisplay)、定时器、PerformSelctor(延迟执行)、GCD(回调主线程)、网络请求当中发挥了作用。详情参考<a href="http://weslyxl.coding.me/2018/03/18/2018/3/RunLoop%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%BA%94%E7%94%A8%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="runloop事件循环机制"><a href="#runloop事件循环机制" class="header-anchor">#</a> RunLoop事件循环机制</h2> <p><img src="/assets/img/RunLoop执行2.82ea1f00.png" alt="RunLoop执行2"></p> <h2 id="runloop与多线程"><a href="#runloop与多线程" class="header-anchor">#</a> RunLoop与多线程</h2> <p>线程时和RunLoop一一对应的。<br>
自己创建的线程默认是没有RunLoop的。</p> <p>怎样实现一个常驻线程呢？</p> <ol><li>为当前线程开启一个RunLoop。</li> <li>向该RunLoop中添加一个Port/Source等维持RunLoop的事件循环。</li> <li>启动该RunLoop。</li></ol> <p><img src="/assets/img/常驻线程代码.6f4b389e.png" alt="常驻线程代码"></p> <p>什么是RunLoop，它是怎样做到有事做事，没事休息的？</p> <ol><li>RunLoop是一个事件循环用已处理我们的事件和消息以及对他们的管理。</li> <li>是调用CFRunLoopRun之后，会调用系统的mach_msg，同时发生了用户态到内核态的切换，当前线程处于休眠状态，所以做到了有事做事，没事休息。</li></ol> <p>RunLoop与线程是怎样的关系？</p> <ol><li>RunLoop与线程一一对应的关系</li> <li>子线程默认是没有RunLoop的，我们需要手动创建</li></ol> <p>如何退出一个RunLoop？</p> <p>如果不想退出runloop可以使用run方式启动runloop；如果使用runUntilDate方式启动runloop，可以通过设置超时时间来退出；如果使用runMode：beforeDate方式启动runloop，可以通过设置超时时间或者使用CFRunLoopStop方法来退出。</p> <p>怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作？</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/iOS知识体系/线程锁.html" class="prev">
        线程锁
      </a></span> <span class="next"><a href="/iOS知识体系/动画.html">
        动画
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9de76d75.js" defer></script><script src="/assets/js/2.98ea7a63.js" defer></script><script src="/assets/js/8.a04b9d9b.js" defer></script>
  </body>
</html>
