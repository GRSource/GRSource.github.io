(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{444:function(t,s,a){t.exports=a.p+"assets/img/objc_object.46e7d6fd.png"},445:function(t,s,a){t.exports=a.p+"assets/img/objc_class.ed56b711.png"},446:function(t,s,a){t.exports=a.p+"assets/img/cache_t.0147a411.png"},447:function(t,s,a){t.exports=a.p+"assets/img/bucket_t.ccd2f419.png"},448:function(t,s,a){t.exports=a.p+"assets/img/class_rw_t.9a04a7ca.png"},449:function(t,s,a){t.exports=a.p+"assets/img/class_rw_t图解.ac5afe9f.png"},450:function(t,s,a){t.exports=a.p+"assets/img/method_t.5f4baf5d.png"},451:function(t,s,a){t.exports=a.p+"assets/img/property_t.dcd3feac.png"},452:function(t,s,a){t.exports=a.p+"assets/img/prototol_ref_t.f69be70b.png"},453:function(t,s,a){t.exports=a.p+"assets/img/class_ro_t.4d4fc24e.png"},454:function(t,s,a){t.exports=a.p+"assets/img/class_ro_t图解.def78f3f.png"},455:function(t,s,a){t.exports=a.p+"assets/img/method_t图解.b815f8c7.png"},456:function(t,s,a){t.exports=a.p+"assets/img/typeEncodings.63c7e1d4.png"},457:function(t,s,a){t.exports=a.p+"assets/img/runtime图解.d5083177.png"},458:function(t,s,a){t.exports=a.p+"assets/img/runtime继承关系.6612161c.png"},459:function(t,s,a){t.exports=a.p+"assets/img/objc_msgSend.7cc34ef2.png"},460:function(t,s,a){t.exports=a.p+"assets/img/消息传递1.29e0a60d.png"},461:function(t,s,a){t.exports=a.p+"assets/img/消息传递2.122a256e.png"},462:function(t,s,a){t.exports=a.p+"assets/img/动态添加方法.c812aee9.png"},560:function(t,s,a){"use strict";a.r(s);var e=a(65),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"runtime"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[t._v("#")]),t._v(" Runtime")]),t._v(" "),e("h2",{attrs:{id:"runtime数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runtime数据结构"}},[t._v("#")]),t._v(" Runtime数据结构")]),t._v(" "),e("p",[e("strong",[t._v("objc_object")]),e("br"),t._v(" "),e("img",{attrs:{src:a(444),alt:"objc_object"}}),e("br"),t._v("\nisa指针指向它所对应的Class，即类对象\n"),e("strong",[t._v("objc_class")]),t._v("继承至objc_object，是一个类对象\n"),e("img",{attrs:{src:a(445),alt:"objc_class"}}),e("br"),t._v("\nsuperclass指针指向父类对象；cache_t表示方法缓存；class_data_bits_t存了对象的一些信息，比如说方法、属性、协议等等"),e("br"),t._v("\n因为objc_class继承至objc_object，所以objc_class也有一个isa指针，其指向元类对象\n如果我们调用一个实例的实例方法，实际上就是通过实例isa指针到它所对应的类对象当中去查找，如果我们调用的是一个类方法，实际上就是通过类对象的isa指针到它的元类对象当中去查找。"),e("br"),t._v(" "),e("img",{attrs:{src:a(446),alt:"cache_t"}}),e("br"),t._v("\ncache_t用于快速查找方法的执行函数,是可增量扩展的哈希表结构,是局部性原理的最佳应用"),e("br"),t._v("\ncache_t由bucket_t的数组组成，bucket_t由对应的key和imp来实现"),e("br"),t._v(" "),e("img",{attrs:{src:a(447),alt:"bucket_t"}}),e("br"),t._v("\nclass_data_bits_t主要是对class_rw_t的封装，class_rw_t代表了类相关的读写信息（如方法、属性、协议）和对class_ro_t的封装"),e("br"),t._v(" "),e("img",{attrs:{src:a(448),alt:"class_rw_t"}}),t._v("\nclass_rw_t主要由四个部分组成：")]),t._v(" "),e("ul",[e("li",[t._v("class_ro_t")]),t._v(" "),e("li",[t._v("protocols")]),t._v(" "),e("li",[t._v("properties")]),t._v(" "),e("li",[t._v("methods")])]),t._v(" "),e("p",[t._v("1.我们通过分类添加的一些信息都是在protocols、properties和methods当中，这三个数据结构是一个二维数组，他们都继承至list_array_tt，我们以methods为例，methods每个元素都是一个一维数组类型，每个一维数组又存了很多method_t类型的数据结构，图解\n"),e("img",{attrs:{src:a(449),alt:"class_rw_t图解"}}),t._v("\nmethod_t的图解："),e("br"),t._v(" "),e("img",{attrs:{src:a(450),alt:"method_t"}}),t._v("\nproperties由property_t组成，property_t图解：\n"),e("img",{attrs:{src:a(451),alt:"property_t"}}),t._v("\nprotocols由protocol_ref_t组成，图解：\n"),e("img",{attrs:{src:a(452),alt:"protocol_ref_t"}})]),t._v(" "),e("p",[t._v("2.class_ro_t代表了类相关的只读信息，由五个部分组成：")]),t._v(" "),e("ul",[e("li",[t._v("name //类名")]),t._v(" "),e("li",[t._v("ivars //成员变量")]),t._v(" "),e("li",[t._v("baseProperties  //属性")]),t._v(" "),e("li",[t._v("baseProtocols //协议")]),t._v(" "),e("li",[t._v("baseMethodList //方法列表"),e("br"),t._v(" "),e("img",{attrs:{src:a(453),alt:"class_ro_t"}}),t._v("\n而这里的properties、protocols、methodList都是一维数组，存储的都是原始类当中的一些信息，我们以methodList为例，里面存的是method_t类型的数据结构，跟class_rw_t当中的method_t是一致的，图解：\n"),e("img",{attrs:{src:a(454),alt:"class_ro_t图解"}})])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("1.函数四要素：名称、返回值、参数、函数体。和method_t对应关系如图：\n"),e("img",{attrs:{src:a(455),alt:"method_t图解"}}),t._v("\ntypes对应于方法签名的type Encodings，如图\n"),e("img",{attrs:{src:a(456),alt:"typeEncodings"}})]),t._v(" "),e("hr"),t._v(" "),e("p",[e("img",{attrs:{src:a(457),alt:"runtime图解"}})]),t._v(" "),e("h2",{attrs:{id:"类对象和元类对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类对象和元类对象"}},[t._v("#")]),t._v(" 类对象和元类对象")]),t._v(" "),e("p",[t._v("问1：类对象和元类对象的区别？"),e("br"),t._v("\n1.类对象存储实例方法列表等信息"),e("br"),t._v("\n2.元类对象存储类方法列表等信息"),e("br"),t._v(" "),e("img",{attrs:{src:a(458),alt:"runtime继承关系"}}),t._v("\n问2：objective-c消息传递的过程？"),e("br"),t._v("\n当我们调用某个实例的方法时，首先系统会根据当前实例的isa指针找到他的类对象，然后在他的类对象中去遍历方法列表，去查找同名的方法实现，如果没有查找到的话，就会顺次去查找父类的方法列表，然后再顺次去查找根类对象的方法类别，如果没有找到就会进入消息转发流程，后面会介绍消息转发。\n当我们调用类方法，就会通过类对象的isa指针找到元类对象，顺次遍历方法列表，直到根元类对象，然后再到根类对象，然后再到nil，进入消息转发流程。")]),t._v(" "),e("p",[t._v("** 消息传递"),e("br"),t._v(" "),e("img",{attrs:{src:a(459),alt:"objc_msgSend"}}),t._v(" "),e("img",{attrs:{src:a(460),alt:"消息传递1"}}),t._v(" "),e("img",{attrs:{src:a(461),alt:"消息传递2"}})]),t._v(" "),e("p",[t._v("问3：消息传递查找流程？"),e("br"),t._v("\n调用方法后，先查找缓存，如果缓存中有对应选择器方法的实现，就调用函数指针，完成消息传递，如果缓存中没有，就调用当前类对象的方法列表，如果命中，就通过函数指针进行调用，完成消息传递，如果没有，则逐级在父类对象中进行查找，如果某个父类命中，则通过函数指针调用函数实现，完成消息传递，如果查到根类对象还没有查到，就进入消息转发流程，结束消息传递。")]),t._v(" "),e("h2",{attrs:{id:"方法缓存查找"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法缓存查找"}},[t._v("#")]),t._v(" 方法缓存查找")]),t._v(" "),e("p",[t._v("问1：给你值SEL，目标是对应缓存中bucket_t中的IMP"),e("br"),t._v("\n通过哈希查找到对应的bucket_t，哈希算法采用是key & mask，其中mask是cache_t的一个成员变量"),e("br"),t._v("\n问2：当前类中查找方法"),e("br"),t._v("\n对于已排序好的列表，采用二分查找算法查找方法对应执行函数"),e("br"),t._v("\n对于没有排序的列表，采用一般遍历查找方法对应执行函数"),e("br"),t._v("\n问3：缓存查找和当前类中方法查找的区别？"),e("br"),t._v("\n优先查找缓存，采用哈希查找算法，如果没有命中，就继续查找当前类对象的方法列表，对于已排序的方法列表采用二分查找，对于没有排序的方法列表采用一般遍历查找，如果还没找到，就逐级父类进行查找。")]),t._v(" "),e("h2",{attrs:{id:"消息转发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息转发"}},[t._v("#")]),t._v(" 消息转发")]),t._v(" "),e("p",[t._v("当向Objective-C对象发送一个消息，但runtime在当前类及父类中找不到此selector对应的方法时，消息转发(message forwarding)流程开始启动。")]),t._v(" "),e("p",[t._v("动态方法解析\n向当前类发送+resolveInstanceMethod:(对于类方法则为+resolveClassMethod:)消息，如果返回YES,则系统认为请求的方法已经加入到了，则会重新发送消息。\n快速转发路径\n如果当前target实现了-forwardingTargetForSelector:方法,则调用此方法。如果此方法返回除nil和self的其他对象，则向返回对象重新发送消息。\n慢速转发路径\n首先runtime发送-methodSignatureForSelector:消息查看Selector对应的方法签名，即参数与返回值的类型信息。如果有方法签名返回，runtime则根据方法签名创建描述该消息的NSInvocation，向当前对象发送forwardInvocation:消息，以创建的NSInvocation对象作为参数；若methodSignatureForSelector:无方法签名返回，则向当前对象发送doesNotRecognizeSelector:消息,程序抛出异常退出。")]),t._v(" "),e("h2",{attrs:{id:"method-swizzling"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#method-swizzling"}},[t._v("#")]),t._v(" Method-Swizzling")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("Method test = class_getInstanceMethod(self, @selector(test));\nMethod otherTest = class_getInstanceMethod(self, @selector(otherTest));\nmethod_exchangeImplementations(test, otherTest);\n")])])]),e("h2",{attrs:{id:"动态添加方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态添加方法"}},[t._v("#")]),t._v(" 动态添加方法")]),t._v(" "),e("p",[e("img",{attrs:{src:a(462),alt:"动态添加方法"}})]),t._v(" "),e("h2",{attrs:{id:"动态创建类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态创建类"}},[t._v("#")]),t._v(" 动态创建类")]),t._v(" "),e("h3",{attrs:{id:"使用objc-allocateclasspair创建一个类class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用objc-allocateclasspair创建一个类class"}},[t._v("#")]),t._v(" 使用objc_allocateClassPair创建一个类Class")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('const char * className = "Calculator";\nClass kclass = objc_getClass(className);\nif (!kclass) \n{\n   Class superClass = [NSObject class]; \n   kclass = objc_allocateClassPair(superClass, className, 0);\n}\n')])])]),e("h3",{attrs:{id:"使用class-addivar添加一个成员变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用class-addivar添加一个成员变量"}},[t._v("#")]),t._v(" 使用class_addIvar添加一个成员变量")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('NSUInteger size;\nNSUInteger alignment;\nNSGetSizeAndAlignment("*", &size, &alignment);\nclass_addIvar(kclass, "expression", size, alignment, "*");\n\n\n注:\n1.type定义参考:https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\n2."*"星号代表字符(),iOS字符为4位，并采用4位对齐kclass\n')])])]),e("h3",{attrs:{id:"使用class-addmethod添加成员方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用class-addmethod添加成员方法"}},[t._v("#")]),t._v(" 使用class_addMethod添加成员方法")]),t._v(" "),e("p",[t._v('class_addMethod(kclass, @selector(setExpressionFormula:), (IMP)setExpressionFormula, "v@😡");\nclass_addMethod(kclass, @selector(getExpressionFormula), (IMP)getExpressionFormula, "@@😊;')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('static void setExpressionFormula(id self, SEL cmd, id value)\n{\n   NSLog(@"call setExpressionFormula");\n}\n\nstatic void getExpressionFormula(id self, SEL cmd)\n{\n    NSLog(@"call getExpressionFormula");\n} \n\n注:\n1.type定义参考:https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\n2."v@:@",解释v-返回值void类型,@-self指针id类型,:-SEL指针SEL类型,@-函数第一个参数为id类型\n3."@@:",解释@-返回值id类型,@-self指针id类型,:-SEL指针SEL类型,\n')])])]),e("h3",{attrs:{id:"注册到运行时环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#注册到运行时环境"}},[t._v("#")]),t._v(" 注册到运行时环境")]),t._v(" "),e("p",[t._v("objc_registerClassPair(kclass);")]),t._v(" "),e("h3",{attrs:{id:"实例化类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例化类"}},[t._v("#")]),t._v(" 实例化类")]),t._v(" "),e("p",[t._v("id instance = [[kclass alloc] init];")]),t._v(" "),e("h3",{attrs:{id:"给变量赋值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#给变量赋值"}},[t._v("#")]),t._v(" 给变量赋值")]),t._v(" "),e("p",[t._v('object_setInstanceVariable(instance, "expression", "1+1");')]),t._v(" "),e("h3",{attrs:{id:"获取变量值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取变量值"}},[t._v("#")]),t._v(" 获取变量值")]),t._v(" "),e("p",[t._v('void * value = NULL;\nobject_getInstanceVariable(instance, "expression", &value);')]),t._v(" "),e("h3",{attrs:{id:"调用函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#调用函数"}},[t._v("#")]),t._v(" 调用函数")]),t._v(" "),e("p",[t._v("[instance performSelector:@selector(getExpressionFormula)];")]),t._v(" "),e("h2",{attrs:{id:"runtime问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#runtime问题"}},[t._v("#")]),t._v(" Runtime问题")]),t._v(" "),e("p",[t._v("问1：[obj foo]和objc_msgSend()函数之间有什么关系？"),e("br"),t._v("\n在编译器编译后会变成objc_msgSend()，然后进行消息传递"),e("br"),t._v("\n问2：能否向编译后的类中增加实例变量？"),e("br"),t._v("\n编译前创建的类已经完成了实例变量的布局，从runtime数据结构class_ro_t的只读特性可以看出编译后的类是不能增加实例变量的。"),e("br"),t._v("\n问3：能否向动态添加的类中增加实例变量？"),e("br"),t._v("\n可以，因为动态添加类的过程中，只要在注册类对(objc_registerClassPair)之前添加是可以的。")])])}),[],!1,null,null,null);s.default=r.exports}}]);