(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{588:function(a,t,s){"use strict";s.r(t);var r=s(65),v=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"c"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c"}},[a._v("#")]),a._v(" C")]),a._v(" "),s("h2",{attrs:{id:"文件操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件操作"}},[a._v("#")]),a._v(" 文件操作")]),a._v(" "),s("h3",{attrs:{id:"file-fp-fopen-文件名-使用文件的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#file-fp-fopen-文件名-使用文件的方式"}},[a._v("#")]),a._v(" FILE *fp = fopen(文件名, 使用文件的方式);")]),a._v(" "),s("p",[a._v("打开文件，是指为文件建立相应的信息区（用来存放有关文件的信息）和文件缓冲区（用来暂时存放输入输出的数据）")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("指定文件不存在会建立新文件，指定文件存在会删除旧文件")]),a._v(" "),s("ul",[s("li",[a._v('"w"只写')]),a._v(" "),s("li",[a._v('"wb"写二进制')]),a._v(" "),s("li",[a._v('"w+"读写')]),a._v(" "),s("li",[a._v('"wb+"读写二进制')])])]),a._v(" "),s("li",[s("p",[a._v("指定文件不存在时会出错")]),a._v(" "),s("ul",[s("li",[a._v('"r"只读')]),a._v(" "),s("li",[a._v('"r+"读写')]),a._v(" "),s("li",[a._v('"rb"读二进制')]),a._v(" "),s("li",[a._v('"rb+"读写二进制')]),a._v(" "),s("li",[a._v('"a"追加写')]),a._v(" "),s("li",[a._v('"a+"追加读写')]),a._v(" "),s("li",[a._v('"ab"追加二进制')]),a._v(" "),s("li",[a._v('"ab+"读写二进制')])])])]),a._v(" "),s("h3",{attrs:{id:"int-ret-fclose-文件指针"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#int-ret-fclose-文件指针"}},[a._v("#")]),a._v(" int ret = fclose(文件指针);")]),a._v(" "),s("p",[a._v("关闭是指撤销文件信息区和文件缓冲区，使文件指针变量不再指向该文件，显然就无法再进行对文件的读写了")]),a._v(" "),s("h3",{attrs:{id:"顺序读写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#顺序读写"}},[a._v("#")]),a._v(" 顺序读写")]),a._v(" "),s("p",[a._v("先写的数据存放在文件前面。\n先读文件前面的数据。\n每读一次就将文件位置标记向后移动一次，下次再从新位置读入。\n每写一次就将文件写入位置向后移动一次，下次再从新位置写入。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("char ch = fgetc(fp);")]),a._v(" "),s("p",[a._v("读一个字符")])]),a._v(" "),s("li",[s("p",[a._v("char ch = fputc(ch, fp);")]),a._v(" "),s("p",[a._v("把字符ch写入到fp中")])]),a._v(" "),s("li",[s("p",[a._v("char * result = fgets(char * str, int n, FILE *fp);")]),a._v(" "),s("p",[a._v("从fp中读一个长度为n-1（因为最后会追加一个'\\0'，所以只能读n-1）的字符串，存放到字符数组str中。返回结果为str的地址。")])]),a._v(" "),s("li",[s("p",[a._v("int ret = fputs(str, fp);")]),a._v(" "),s("p",[a._v("把str写入到文件fp中")])]),a._v(" "),s("li",[s("p",[a._v("fprintf(文件指针，格式字符串，输出表列);")]),a._v(" "),s("p",[a._v("格式化打印到磁盘")])]),a._v(" "),s("li",[s("p",[a._v("fscanf(文件指针，格式字符串，输入表列);")]),a._v(" "),s("p",[a._v("格式化输入到内存")])]),a._v(" "),s("li",[s("p",[a._v("fread(buffer, size, count, fp);")]),a._v(" "),s("p",[a._v("buffer：是一个地址，用来存放从文件读入的数据的存储区的地址。\t\nsize：要读取的字节数。\ncount：要读多少个数据项（每个数据项长度为size）")])]),a._v(" "),s("li",[s("p",[a._v("fwrite(buffer, size, count, fp);")]),a._v(" "),s("p",[a._v("buffer：要把此地址开始的存储区中的数据向文件输出。\nsize：要写入的字节数。\ncount：要写多少个数据项（每个数据项长度为size）")])])]),a._v(" "),s("h3",{attrs:{id:"随机读写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#随机读写"}},[a._v("#")]),a._v(" 随机读写")]),a._v(" "),s("p",[a._v("可以对任何位置上的数据进行访问。通过移动文件位置标记的位置，可以从任何位置进行读写。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("rewind(FILE *fp)")]),a._v(" "),s("p",[a._v("使文件位置标记指向文件开头")])]),a._v(" "),s("li",[s("p",[a._v("fseek(文件类型指针，位移量，起始点)")]),a._v(" "),s("p",[a._v("起始点：SEEK_SET(0表示)，从文件开始位置计算。SEEK_CUR(1表示)，从当前位置开始计算。SEEK_END(2表示)，从文件末尾开始计算。")])]),a._v(" "),s("li",[s("p",[a._v("ftell")]),a._v(" "),s("p",[a._v("获取文件位置标记的当前位置")])]),a._v(" "),s("li",[s("p",[a._v("ferror(fp)")]),a._v(" "),s("p",[a._v("检查之前的操作是否出错")])]),a._v(" "),s("li",[s("p",[a._v("clearerr")]),a._v(" "),s("p",[a._v("使文件错误标志和文件结束标志置为0")])])]),a._v(" "),s("h2",{attrs:{id:"数组int-a-10-1-2-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组int-a-10-1-2-3"}},[a._v("#")]),a._v(" 数组int a[10]={1,2,3}")]),a._v(" "),s("h3",{attrs:{id:"a"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a"}},[a._v("#")]),a._v(" a")]),a._v(" "),s("p",[a._v("取数组第一个元素的指针")]),a._v(" "),s("h3",{attrs:{id:"a-i"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-i"}},[a._v("#")]),a._v(" a+i")]),a._v(" "),s("p",[a._v("取数组第i个元素的指针")]),a._v(" "),s("h3",{attrs:{id:"int-p1-p2-x-p1-p2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#int-p1-p2-x-p1-p2"}},[a._v("#")]),a._v(" int *p1, *p2; x = p1-p2")]),a._v(" "),s("p",[a._v("x表示p1和p2相隔几个元素")]),a._v(" "),s("h3",{attrs:{id:"如果int-p-a-则p-i-等价于a-i-和-p-i"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果int-p-a-则p-i-等价于a-i-和-p-i"}},[a._v("#")]),a._v(" 如果int "),s("em",[a._v("p = a,则p[i]等价于a[i]和")]),a._v("(p+i)")]),a._v(" "),s("h3",{attrs:{id:"p"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#p"}},[a._v("#")]),a._v(" p++")]),a._v(" "),s("p",[a._v("指向下一个元素，还是指针")]),a._v(" "),s("h3",{attrs:{id:"p-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#p-2"}},[a._v("#")]),a._v(" *p")]),a._v(" "),s("p",[a._v("指针指向的值，结果为真实值")]),a._v(" "),s("h3",{attrs:{id:"p-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#p-3"}},[a._v("#")]),a._v(" *p++")]),a._v(" "),s("p",[a._v("由于++和"),s("em",[a._v("同优先级，结合方向为自由向左，因此等价于")]),a._v("(p++)，先引用p的值，实现*p运算，然后再使p自增1。")]),a._v(" "),s("h3",{attrs:{id:"p-4"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#p-4"}},[a._v("#")]),a._v(" *(++p)")]),a._v(" "),s("h3",{attrs:{id:"p-5"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#p-5"}},[a._v("#")]),a._v(" ++(*p)")]),a._v(" "),s("h2",{attrs:{id:"函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[a._v("#")]),a._v(" 函数")]),a._v(" "),s("h3",{attrs:{id:"形参类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#形参类型"}},[a._v("#")]),a._v(" 形参类型")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("变量")]),a._v(" "),s("ul",[s("li",[a._v("值传递，不改变实参的值")])])]),a._v(" "),s("li",[s("p",[a._v("数组名")]),a._v(" "),s("ul",[s("li",[a._v("传递的数组首元素地址，指针传递，可以改变实参的值")])])])]),a._v(" "),s("h3",{attrs:{id:"形参数组实际上是一个指针变量-并不是真正开辟一个数组空间-所以不必指定长度大小"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#形参数组实际上是一个指针变量-并不是真正开辟一个数组空间-所以不必指定长度大小"}},[a._v("#")]),a._v(" 形参数组实际上是一个指针变量，并不是真正开辟一个数组空间，所以不必指定长度大小")]),a._v(" "),s("h2",{attrs:{id:"多维数组int-a-3-4-三行四列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多维数组int-a-3-4-三行四列"}},[a._v("#")]),a._v(" 多维数组int a[3][4]，三行四列")]),a._v(" "),s("div",{staticClass:"language-C extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("9")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("11")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("13")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("15")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("17")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("19")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("21")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("23")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])])]),s("h3",{attrs:{id:"a和a-0-虽然地址一样-但是它们所表示含义不一样-一个代表二维数组的首地址-一个代表二维数组内部一维数组的首地址"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a和a-0-虽然地址一样-但是它们所表示含义不一样-一个代表二维数组的首地址-一个代表二维数组内部一维数组的首地址"}},[a._v("#")]),a._v(" a和a[0]虽然地址一样，但是它们所表示含义不一样，一个代表二维数组的首地址，一个代表二维数组内部一维数组的首地址")]),a._v(" "),s("h3",{attrs:{id:"a代表a-0-a-1代表a-1-a-2代表a-2-它们都指向内部数组首元素的地址-相当于-a-x-0-地址值相同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a代表a-0-a-1代表a-1-a-2代表a-2-它们都指向内部数组首元素的地址-相当于-a-x-0-地址值相同"}},[a._v("#")]),a._v(" a代表a[0]，a+1代表a[1]，a+2代表a[2]，它们都指向内部数组首元素的地址，相当于&a[x][0]，地址值相同")]),a._v(" "),s("h3",{attrs:{id:"a-0-a-1-a-2-即是地址-又是内部一维数组名-所以a-0-a-1-a-2-代表一维数组首元素的地址-即-a-0-0-a-1-0-a-2-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-0-a-1-a-2-即是地址-又是内部一维数组名-所以a-0-a-1-a-2-代表一维数组首元素的地址-即-a-0-0-a-1-0-a-2-0"}},[a._v("#")]),a._v(" a[0]，a[1]，a[2]即是地址，又是内部一维数组名，所以a[0]，a[1]，a[2]代表一维数组首元素的地址，即&a[0][0]，&a[1][0]，&a[2][0]")]),a._v(" "),s("h3",{attrs:{id:"既然a-x-代表第x个内部一维数组首元素地址-那么a-x-y就表示内部一维数组的第y个元素的地址"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#既然a-x-代表第x个内部一维数组首元素地址-那么a-x-y就表示内部一维数组的第y个元素的地址"}},[a._v("#")]),a._v(" 既然a[x]代表第x个内部一维数组首元素地址，那么a[x]+y就表示内部一维数组的第y个元素的地址")]),a._v(" "),s("h3",{attrs:{id:"因为在一维数组中-a-i-和-a-i-都指向第i个元素的值-在二维数组中a-i-又代表地址-所以a-i-j和-a-i-j都代表-a-i-j-都是地址"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#因为在一维数组中-a-i-和-a-i-都指向第i个元素的值-在二维数组中a-i-又代表地址-所以a-i-j和-a-i-j都代表-a-i-j-都是地址"}},[a._v("#")]),a._v(" 因为在一维数组中，a[i]和*(a+i)都指向第i个元素的值，在二维数组中a[i]又代表地址，所以a[i]+j和*(a+i)+j都代表&a[i][j]，都是地址")]),a._v(" "),s("h3",{attrs:{id:"因为a-i-j和-a-i-j都代表某个元素的地址-那么-a-i-j-和-a-i-j-都是代表指向的确切值。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#因为a-i-j和-a-i-j都代表某个元素的地址-那么-a-i-j-和-a-i-j-都是代表指向的确切值。"}},[a._v("#")]),a._v(" 因为a[i]+j和*(a+i)+j都代表某个元素的地址，那么*(a[i]+j)和*(*(a+i)+j)都是代表指向的确切值。")]),a._v(" "),s("h3",{attrs:{id:"a-1和-a-1-有何区别-a-1代表第1行元素的首地址-a-1-可表示为a-i-也代表第1行元素的首地址"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-1和-a-1-有何区别-a-1代表第1行元素的首地址-a-1-可表示为a-i-也代表第1行元素的首地址"}},[a._v("#")]),a._v(" a+1和*(a+1)有何区别？a+1代表第1行元素的首地址，*(a+1)可表示为a[i]，也代表第1行元素的首地址")]),a._v(" "),s("h3",{attrs:{id:"二维数组中-a-i、a-i-、-a-i-、-a-i-、-a-i-0-的值相等-a-i代表指向第i行的指针-类型是int-4-a-i-代表取出第i行的值-a-i-就是数组名-即一维数组首元素地址-所以-a-i-类型是int-而a-i-代表一维数组-是int-类型。-a-i-代表第i行的地址-类型是int-4-。-a-i-0-代表第i行第0列的地址-类型是int-。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二维数组中-a-i、a-i-、-a-i-、-a-i-、-a-i-0-的值相等-a-i代表指向第i行的指针-类型是int-4-a-i-代表取出第i行的值-a-i-就是数组名-即一维数组首元素地址-所以-a-i-类型是int-而a-i-代表一维数组-是int-类型。-a-i-代表第i行的地址-类型是int-4-。-a-i-0-代表第i行第0列的地址-类型是int-。"}},[a._v("#")]),a._v(" 二维数组中，a+i、a[i]、"),s("em",[a._v("(a+i)、&a[i]、&a[i][0]的值相等，a+i代表指向第i行的指针，类型是int (")]),a._v(")[4]，"),s("em",[a._v("(a+i)代表取出第i行的值，")]),a._v("(a+i)就是数组名，即一维数组首元素地址，所以*(a+i)类型是int *，而a[i]代表一维数组，是int "),s("em",[a._v("类型。&a[i]代表第i行的地址，类型是int (")]),a._v(")[4]。&a[i][0]代表第i行第0列的地址，类型是int *。")]),a._v(" "),s("h2",{attrs:{id:"指针需要理解指向的概念-不仅仅地址相同-指向的概念也很重要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指针需要理解指向的概念-不仅仅地址相同-指向的概念也很重要"}},[a._v("#")]),a._v(" 指针需要理解指向的概念，不仅仅地址相同，指向的概念也很重要")]),a._v(" "),s("h3",{attrs:{id:"a代表二维数组首元素的地址-a-0-代表二维数组第一行首元素的地址-a-0-0-代表第一行第一列首元素的地址。虽然他们的地址值相同-但是概念不同-这点非常重要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a代表二维数组首元素的地址-a-0-代表二维数组第一行首元素的地址-a-0-0-代表第一行第一列首元素的地址。虽然他们的地址值相同-但是概念不同-这点非常重要"}},[a._v("#")]),a._v(" a代表二维数组首元素的地址，a[0]代表二维数组第一行首元素的地址，&a[0][0]代表第一行第一列首元素的地址。虽然他们的地址值相同，但是概念不同，这点非常重要")]),a._v(" "),s("h3",{attrs:{id:"int-p-4-和int-p-4-不同。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#int-p-4-和int-p-4-不同。"}},[a._v("#")]),a._v(" int (*p)[4]和int *p[4]不同。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("(*p)[4]表示指向数组的指针，即表示(*p)有四个元素，每个元素为整型，也就是p所指的对象是有4个整型元素的数组，即p是指向一维数组的指针，不能指向一维数组中的某一元素，(*p)[0]、(*p)[1]、(*p)[2]、(*p)[3]、分别代表各元素的确切值。例如int a[4]={1,3,5,7}，将p指向数组，即p = &a，这里用了&取地址符，&不能省略，因为p=a表示指向a[0]，而p=&a表示指向一维数组")]),a._v(" "),s("ul",[s("li",[s("p",[a._v('int a[4] = {1,3,5,7};\nint (*p)[4];\nint *q;\np = &a;\nq =  a;\nprintf("%d---%d",('),s("em",[a._v("p)[3],")]),a._v("(q+3));")]),a._v(" "),s("ul",[s("li",[a._v("p的基类型是int(*)[4]，类型长度是16字节，而q的基类型是int *，类型长度是4字节")])])]),a._v(" "),s("li",[s("p",[a._v("int a[3][4] = {1,3,5,7,9,11,13,15,17,19,21,23};\nint (*p)[4];\nint "),s("em",[a._v("q;\np = a;\nq = "),s("em",[a._v('a;\nprintf("%d",')]),a._v("(")]),a._v("(p+1)+2));")]),a._v(" "),s("ul",[s("li",[a._v("根据数组名代表首元素的地址这一原则，因为p的基类型是int("),s("em",[a._v(")[4]，类型长度是16字节，所以p+1时，p的地址就会增加16字节，示例数组中p表示指向a，即二维数组首元素的地址，因为首元素是一个一维数组，所以p就指向这个一维数组，类型是int(")]),a._v(")[4]。而q=*a；*a代表取出二维数组中第一行的值（依旧是指针），"),s("em",[a._v("a就是一维数组的数组名，根据数组名代表首元素的地址这一原则，所以")]),a._v("a就是第一行第一列元素的地址，所以它是int *类型。")])])])])]),a._v(" "),s("li",[s("p",[a._v("int * p[4]表示指针数组")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("数组中存放的是指针")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("p表示指向指针数组中第一个元素的指针，因为第一个元素本来就是指针，所以p就是指针的指针，即双重指针，p+i就是指向指针型数据的指针。可以用char **q来表示这个p+i指针")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("char **q的理解")]),a._v(" "),s("ul",[s("li",[a._v("分为两部分来看：char "),s("em",[a._v("和(")]),a._v(" q)，后面的（*q）表示q是指针变量，前面的char *表示p指向的是char *型的数据，也就是说p指向一个字符指针变量，然后这个字符指针变量又指向一个字符型数据")])])])])])])])])])]),a._v(" "),s("h3",{attrs:{id:"指向函数的指针int-p-int-int"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指向函数的指针int-p-int-int"}},[a._v("#")]),a._v(" 指向函数的指针int (*p)(int, int)")]),a._v(" "),s("ul",[s("li",[a._v("p的类型为int (*) (int, int)")]),a._v(" "),s("li",[a._v("即可通过函数名调用函数，也可通过函数指针调用函数")]),a._v(" "),s("li",[a._v("和数组名代表数组首元素的地址类似，函数名代表该函数的入口地址")])]),a._v(" "),s("h3",{attrs:{id:"返回值为int-类型的函数int-p-int-int"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#返回值为int-类型的函数int-p-int-int"}},[a._v("#")]),a._v(" 返回值为int *类型的函数int *p(int, int)")]),a._v(" "),s("h2",{attrs:{id:"c语言对字符串常量是按字符数组处理的-在内存中开辟了一个字符数组用来存放该字符串常量-但是这个字符数组是没有名字的-所以只能通过指针变量来引用。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#c语言对字符串常量是按字符数组处理的-在内存中开辟了一个字符数组用来存放该字符串常量-但是这个字符数组是没有名字的-所以只能通过指针变量来引用。"}},[a._v("#")]),a._v(" C语言对字符串常量是按字符数组处理的，在内存中开辟了一个字符数组用来存放该字符串常量，但是这个字符数组是没有名字的，所以只能通过指针变量来引用。")]),a._v(" "),s("h3",{attrs:{id:"例如char-string-i-love-china"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#例如char-string-i-love-china"}},[a._v("#")]),a._v(' 例如char *string = "I love China!";')]),a._v(" "),s("h3",{attrs:{id:"但是这样写却是错的-int-a-123"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#但是这样写却是错的-int-a-123"}},[a._v("#")]),a._v(" 但是这样写却是错的：int *a = 123;")]),a._v(" "),s("h2",{attrs:{id:"实参和形参的地址是两份-改变了形参的指向-实参的指向依旧不变"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实参和形参的地址是两份-改变了形参的指向-实参的指向依旧不变"}},[a._v("#")]),a._v(" 实参和形参的地址是两份，改变了形参的指向，实参的指向依旧不变")]),a._v(" "),s("h3",{attrs:{id:"比如字符串char-a-bcde-a指向字符串首地址-传入函数后形参可以指向cde-但是实参还是指向首地址"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#比如字符串char-a-bcde-a指向字符串首地址-传入函数后形参可以指向cde-但是实参还是指向首地址"}},[a._v("#")]),a._v(' 比如字符串char *a = "bcde";a指向字符串首地址，传入函数后形参可以指向cde，但是实参还是指向首地址')]),a._v(" "),s("h2",{attrs:{id:"存储类别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#存储类别"}},[a._v("#")]),a._v(" 存储类别")]),a._v(" "),s("h3",{attrs:{id:"静态存储区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态存储区"}},[a._v("#")]),a._v(" 静态存储区")]),a._v(" "),s("p",[a._v("程序整个运行期间不会被释放")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("static局部变量")]),a._v(" "),s("p",[a._v("static局部变量作用域为本函数，其他函数无法访问，且只会初始化一次，整个程序运行期间不会被释放")])]),a._v(" "),s("li",[s("p",[a._v("static全局变量")]),a._v(" "),s("p",[a._v("将作用域限制在本文件范围内，其他文件无法用extern访问")])]),a._v(" "),s("li",[s("p",[a._v("全局变量")]),a._v(" "),s("p",[a._v("整个文件作用域范围内有效，其他文件可通过extern进行访问")])]),a._v(" "),s("li",[s("p",[a._v("extern变量")]),a._v(" "),s("p",[a._v("对于不同的文件，如果某个全局变量未加static，那么可通过extern来声明这个外部变量供自己使用。")])])]),a._v(" "),s("h3",{attrs:{id:"动态存储区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态存储区"}},[a._v("#")]),a._v(" 动态存储区")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("栈")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("auto变量")]),a._v(" "),s("p",[a._v("作用域为本函数")])]),a._v(" "),s("li",[s("p",[a._v("register变量")]),a._v(" "),s("p",[a._v("作用域为本函数")])])])]),a._v(" "),s("li",[s("p",[a._v("堆")]),a._v(" "),s("p",[a._v("由于未在声明部分定义它们为变量或数组，因此不能通过变量名或数组名去引用这些数据，只能通过指针来引用。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("malloc")]),a._v(" "),s("p",[a._v("void * malloc(unsigned int size);分配size大小的连续空间，返回值是所分配区域的第一个字节的地址，即指针。内存空间不足时返回空指针，size表示字节数")])]),a._v(" "),s("li",[s("p",[a._v("calloc")]),a._v(" "),s("p",[a._v("void *calloc(unsigned n, unsigned size);分配n个size大小的连续空间")])]),a._v(" "),s("li",[s("p",[a._v("free")]),a._v(" "),s("p",[a._v("void free(void *p);释放内存空间")])]),a._v(" "),s("li",[s("p",[a._v("realloc")]),a._v(" "),s("p",[a._v("void *realloc(void *p, unsigned int size);如果已经通过malloc函数或calloc函数获得了动态空间，想改变其大小，可以用realloc函数重新分配，这样p的值不变。相当于在同一个位置开辟空间。size为字节数")])])])])]),a._v(" "),s("h3",{attrs:{id:"程序区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#程序区"}},[a._v("#")]),a._v(" 程序区")]),a._v(" "),s("h2",{attrs:{id:"函数类别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数类别"}},[a._v("#")]),a._v(" 函数类别")]),a._v(" "),s("h3",{attrs:{id:"内部函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内部函数"}},[a._v("#")]),a._v(" 内部函数")]),a._v(" "),s("p",[a._v("内部函数用static声明，即作用域限制在本文件，其他文件不可调用，又称静态函数")]),a._v(" "),s("h3",{attrs:{id:"外部函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#外部函数"}},[a._v("#")]),a._v(" 外部函数")]),a._v(" "),s("p",[a._v("使用extern或者不使用extern，表示外部函数，C语言默认的都是外部函数，extern可以省略。")]),a._v(" "),s("h2",{attrs:{id:"void"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#void"}},[a._v("#")]),a._v(" void *")]),a._v(" "),s("p",[a._v("指向空类型的指针，指向不确定类型的指针")]),a._v(" "),s("h2",{attrs:{id:"数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[a._v("#")]),a._v(" 数据结构")]),a._v(" "),s("h3",{attrs:{id:"数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[a._v("#")]),a._v(" 数组")]),a._v(" "),s("h3",{attrs:{id:"链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[a._v("#")]),a._v(" 链表")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("静态链表")]),a._v(" "),s("p",[a._v("通过简单的初始化、赋值来创建")])]),a._v(" "),s("li",[s("p",[a._v("动态链表")]),a._v(" "),s("p",[a._v("通过malloc、calloc、realloc函数创建")])])]),a._v(" "),s("h2",{attrs:{id:"共用体"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#共用体"}},[a._v("#")]),a._v(" 共用体")]),a._v(" "),s("p",[a._v("几个不同的变量共享同一段内存的结构，就是共用体类型")]),a._v(" "),s("h3",{attrs:{id:"union"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#union"}},[a._v("#")]),a._v(" union")]),a._v(" "),s("p",[a._v("定义和结构体类似，关键字不一样。采用覆盖技术，后一个数据覆盖前面的数据。")]),a._v(" "),s("h2",{attrs:{id:"结构体区分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结构体区分"}},[a._v("#")]),a._v(" 结构体区分")]),a._v(" "),s("h3",{attrs:{id:"struct-student"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-student"}},[a._v("#")]),a._v(" struct Student")]),a._v(" "),s("p",[a._v("{\nlong num;\n};")]),a._v(" "),s("ul",[s("li",[a._v("一般定义")])]),a._v(" "),s("h3",{attrs:{id:"typedef-struct"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#typedef-struct"}},[a._v("#")]),a._v(" typedef struct")]),a._v(" "),s("p",[a._v("{\nlong num;\n} Student1;")]),a._v(" "),s("ul",[s("li",[a._v("将匿名结构体重定义为Student1类型")])]),a._v(" "),s("h3",{attrs:{id:"struct"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct"}},[a._v("#")]),a._v(" struct")]),a._v(" "),s("p",[a._v("{\nlong num;\n} stu;")]),a._v(" "),s("ul",[s("li",[a._v("用匿名结构体初始化一个stu")])]),a._v(" "),s("h3",{attrs:{id:"struct-student2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#struct-student2"}},[a._v("#")]),a._v(" struct Student2")]),a._v(" "),s("p",[a._v("{\nlong num;\n} stu1;")]),a._v(" "),s("ul",[s("li",[a._v("定义结构体的同时，初始化一个stu1")])])])}),[],!1,null,null,null);t.default=v.exports}}]);