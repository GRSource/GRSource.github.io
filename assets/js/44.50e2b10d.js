(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{587:function(a,t,r){"use strict";r.r(t);var s=r(65),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"c"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c"}},[a._v("#")]),a._v(" C++")]),a._v(" "),r("h2",{attrs:{id:"虚函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚函数"}},[a._v("#")]),a._v(" 虚函数")]),a._v(" "),r("p",[a._v("虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类的同名函数。在基类中声明虚函数后，派生类的继承函数自动为虚函数，派生内的virtual可以省略")]),a._v(" "),r("h3",{attrs:{id:"更加方便让父类指针调用子类中继承至父类的方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#更加方便让父类指针调用子类中继承至父类的方法"}},[a._v("#")]),a._v(" 更加方便让父类指针调用子类中继承至父类的方法")]),a._v(" "),r("h3",{attrs:{id:"virtual-void-display"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtual-void-display"}},[a._v("#")]),a._v(" virtual void display();")]),a._v(" "),r("h2",{attrs:{id:"纯虚函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#纯虚函数"}},[a._v("#")]),a._v(" 纯虚函数")]),a._v(" "),r("p",[a._v("定义虚函数的地方没有实现该方法，直接 = 0表示这是一个纯虚函数，本身自己不用实现该方法，由派生类实现。")]),a._v(" "),r("h3",{attrs:{id:"virtual-函数类型-函数名-参数表列-0"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#virtual-函数类型-函数名-参数表列-0"}},[a._v("#")]),a._v(" virtual 函数类型 函数名 （参数表列）=  0;")]),a._v(" "),r("h2",{attrs:{id:"虚析构函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚析构函数"}},[a._v("#")]),a._v(" 虚析构函数")]),a._v(" "),r("p",[a._v("如果派生类的对象在堆内存空间创建(new)，用基类的指针指向这个派生对象，在delete释放该指针时不会调用派生类的析构函数，通过声明为虚析构函数，在delete时会自动调用派生类的析构函数。")]),a._v(" "),r("h2",{attrs:{id:"虚基类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚基类"}},[a._v("#")]),a._v(" 虚基类")]),a._v(" "),r("h3",{attrs:{id:"class-b-virtual-public-a"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#class-b-virtual-public-a"}},[a._v("#")]),a._v(" class B: virtual public A;")]),a._v(" "),r("p",[a._v("class C: virtual public A;\nclass D: public B, public C;")]),a._v(" "),r("p",[a._v("如果定义了虚基类，那么在D中仅仅只会有一份A成员变量或者成员函数的拷贝，所以在D中访问基类成员时，不用指定是通过B还是C继承过来的。")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("A是B的虚基类；A是C的虚基类；")]),a._v(" "),r("p",[a._v("如果虚基类中定义了带参数的构造函数且未定义默认构造函数，那么派生类则通过构造函数初始化表对虚基类进行初始化。也就是说后面派生类的派生类都要调用虚基类的构造函数。")])])]),a._v(" "),r("h2",{attrs:{id:"抽象类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[a._v("#")]),a._v(" 抽象类")]),a._v(" "),r("p",[a._v("不用来定义对象只作为一种基本类型用作继承的类称为抽象类。虽然抽象类不能用来定义对象，但是可以定义指向抽象类的指针变量。")]),a._v(" "),r("h3",{attrs:{id:"如果包含纯虚函数-那就是抽象类-不能用来创建对象。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如果包含纯虚函数-那就是抽象类-不能用来创建对象。"}},[a._v("#")]),a._v(" 如果包含纯虚函数，那就是抽象类，不能用来创建对象。")]),a._v(" "),r("h3",{attrs:{id:"如果不包含纯虚函数-那么就不是抽象类-可以用来创建对象。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如果不包含纯虚函数-那么就不是抽象类-可以用来创建对象。"}},[a._v("#")]),a._v(" 如果不包含纯虚函数，那么就不是抽象类，可以用来创建对象。")]),a._v(" "),r("h2",{attrs:{id:"类的特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类的特性"}},[a._v("#")]),a._v(" 类的特性")]),a._v(" "),r("h3",{attrs:{id:"c-类默认都有一个隐式的无参构造函数-如果我们在类外实现这个无参构造函数-那么必须显示的在类当中进行声明。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c-类默认都有一个隐式的无参构造函数-如果我们在类外实现这个无参构造函数-那么必须显示的在类当中进行声明。"}},[a._v("#")]),a._v(" C++类默认都有一个隐式的无参构造函数，如果我们在类外实现这个无参构造函数，那么必须显示的在类当中进行声明。")]),a._v(" "),r("h3",{attrs:{id:"如果子类不写构造函数-在初始化子类时-c-默认也会调用父类的无参构造函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如果子类不写构造函数-在初始化子类时-c-默认也会调用父类的无参构造函数"}},[a._v("#")]),a._v(" 如果子类不写构造函数，在初始化子类时，C++默认也会调用父类的无参构造函数")]),a._v(" "),r("h3",{attrs:{id:"如果我们定义了自己的有参构造函数-那么c-为我们创建的隐式构造函数就会失效"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如果我们定义了自己的有参构造函数-那么c-为我们创建的隐式构造函数就会失效"}},[a._v("#")]),a._v(" 如果我们定义了自己的有参构造函数，那么C++为我们创建的隐式构造函数就会失效")]),a._v(" "),r("h3",{attrs:{id:"如果子类构造函数初始化时没有调用父类的构造函数-那么c-会默认调用父类的无参数构造函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如果子类构造函数初始化时没有调用父类的构造函数-那么c-会默认调用父类的无参数构造函数"}},[a._v("#")]),a._v(" 如果子类构造函数初始化时没有调用父类的构造函数，那么C++会默认调用父类的无参数构造函数")]),a._v(" "),r("h2",{attrs:{id:"继承"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[a._v("#")]),a._v(" 继承")]),a._v(" "),r("p",[a._v("public:类外可以访问，类内可以访问，子类可以访问，可被继承\nprotected:类外不能访问，类内可以访问，子类可以访问，可被继承\nprivate:类外不能访问，类内可以访问，子类不能访问，不能被继承")]),a._v(" "),r("h3",{attrs:{id:"class-b-public-a"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#class-b-public-a"}},[a._v("#")]),a._v(" class B: public A")]),a._v(" "),r("ul",[r("li",[a._v("类B继承类A的public和protected成员，继承后在B中仍然为public和protected")])]),a._v(" "),r("h3",{attrs:{id:"class-b-protected-a"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#class-b-protected-a"}},[a._v("#")]),a._v(" class B: protected A")]),a._v(" "),r("ul",[r("li",[a._v("类B继承类A的public和protected成员，继承后A中的public和protected成员在B中变成protected成员")])]),a._v(" "),r("h3",{attrs:{id:"class-b-private-a"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#class-b-private-a"}},[a._v("#")]),a._v(" class B:private A")]),a._v(" "),r("ul",[r("li",[a._v("类B继承类A的public和protected成员，继承后A中的public和protected成员在B中变成private成员")])]),a._v(" "),r("h2",{attrs:{id:"模板"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模板"}},[a._v("#")]),a._v(" 模板")]),a._v(" "),r("h3",{attrs:{id:"函数模板-即泛型函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数模板-即泛型函数"}},[a._v("#")]),a._v(" 函数模板（即泛型函数）")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("template "),r("typename",{attrs:{T:""}},[a._v("\nT max(T a, T b, T c)\n{\nif (b > a) a = b;\nif (c > a) a = c;\nreturn a;\n}")])],1),a._v(" "),r("p",[a._v("typename也可以写class")])])]),a._v(" "),r("h3",{attrs:{id:"类模板-其实和函数模板没区别-只是用法的不同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类模板-其实和函数模板没区别-只是用法的不同"}},[a._v("#")]),a._v(" 类模板，其实和函数模板没区别，只是用法的不同")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("Compare"),r("int",[a._v(" cmp(4,7);")])],1),a._v(" "),r("p",[a._v("使用模板类初始化一个对象")])]),a._v(" "),r("li",[r("p",[a._v("void Compare"),r("T",[a._v("::max();")])],1),a._v(" "),r("p",[a._v("类内声明，类外定义需要加上T")])])]),a._v(" "),r("h2",{attrs:{id:"逗号表达式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#逗号表达式"}},[a._v("#")]),a._v(" 逗号表达式")]),a._v(" "),r("h3",{attrs:{id:"a-3-5-a-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-3-5-a-4"}},[a._v("#")]),a._v(" a = 3 * 5, a * 4;")]),a._v(" "),r("p",[a._v("结果为60")]),a._v(" "),r("h3",{attrs:{id:"a-3-5-a-4-a-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-3-5-a-4-a-5"}},[a._v("#")]),a._v(" (a=3 * 5, a * 4), a + 5;")]),a._v(" "),r("p",[a._v("结果为 20")]),a._v(" "),r("h2",{attrs:{id:"内联函数inline"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内联函数inline"}},[a._v("#")]),a._v(" 内联函数inline")]),a._v(" "),r("p",[a._v("在编译时将被调函数嵌入到主调函数中去，可以节省内存空间，因为在调用函数时，主调函数不再需要保护现场了")]),a._v(" "),r("h2",{attrs:{id:"重载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重载"}},[a._v("#")]),a._v(" 重载")]),a._v(" "),r("h3",{attrs:{id:"函数的重载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数的重载"}},[a._v("#")]),a._v(" 函数的重载")]),a._v(" "),r("p",[a._v("c++可以函数重载，即函数名相同，参数的个数和参数类型不同，所以仍然会有不同的函数体，因为它们仍然是多个函数")]),a._v(" "),r("h3",{attrs:{id:"运算符重载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运算符重载"}},[a._v("#")]),a._v(" 运算符重载")]),a._v(" "),r("h2",{attrs:{id:"c-中字符串是const-char数组-所以在使用指针变量指向字符串需要加const-char-p-abcd-但这并不表示p是不可改变的指针-我们可以任意改变p的指向-例如-p-123"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#c-中字符串是const-char数组-所以在使用指针变量指向字符串需要加const-char-p-abcd-但这并不表示p是不可改变的指针-我们可以任意改变p的指向-例如-p-123"}},[a._v("#")]),a._v(' c++中字符串是const char数组，所以在使用指针变量指向字符串需要加const char *p = "abcd";但这并不表示p是不可改变的指针，我们可以任意改变p的指向，例如：p = "123";')]),a._v(" "),r("h3",{attrs:{id:"指向常量的指针"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#指向常量的指针"}},[a._v("#")]),a._v(" 指向常量的指针")]),a._v(" "),r("p",[a._v("可以改变指针的指向，但不能改变变量的值")]),a._v(" "),r("ul",[r("li",[a._v("const Time *box;或者Time const *box;")])]),a._v(" "),r("h3",{attrs:{id:"常指针"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常指针"}},[a._v("#")]),a._v(" 常指针")]),a._v(" "),r("p",[a._v("不能改变指针的指向，可以改变对象的值")]),a._v(" "),r("ul",[r("li",[a._v("Time * const ptr1;")])]),a._v(" "),r("h3",{attrs:{id:"常引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常引用"}},[a._v("#")]),a._v(" 常引用")]),a._v(" "),r("p",[a._v("常引用不能对引用变量重新赋值")]),a._v(" "),r("ul",[r("li",[a._v("void fun(const Box &t)\n{\nt.a = 100;//t接收实参的地址，用点访问\nt->a = 1000;//错误，t不是指针，不能用箭头访问\n}")])]),a._v(" "),r("h2",{attrs:{id:"字符串操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字符串操作"}},[a._v("#")]),a._v(" 字符串操作")]),a._v(" "),r("h3",{attrs:{id:"int-ret-strcmp-char-const-char"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#int-ret-strcmp-char-const-char"}},[a._v("#")]),a._v(" int ret = strcmp(char [], const char []);")]),a._v(" "),r("h3",{attrs:{id:"char-result-strcpy-char-const-char"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#char-result-strcpy-char-const-char"}},[a._v("#")]),a._v(" char *result = strcpy(char [], const char []);")]),a._v(" "),r("p",[a._v("将第二个参数的字符串复制到第一个参数当中，将第一个字符串全部覆盖")]),a._v(" "),r("h3",{attrs:{id:"char-result-strcat-char-const-char"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#char-result-strcat-char-const-char"}},[a._v("#")]),a._v(" char *result = strcat(char [], const char []);")]),a._v(" "),r("p",[a._v("将第二个参数的字符连接到第一个参数当中，返回值为字符串首地址。")]),a._v(" "),r("h3",{attrs:{id:"int-length-strlen-const-char"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#int-length-strlen-const-char"}},[a._v("#")]),a._v(" int length = strlen(const char[]);")]),a._v(" "),r("h2",{attrs:{id:"字符串类string"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#字符串类string"}},[a._v("#")]),a._v(" 字符串类string")]),a._v(" "),r("h3",{attrs:{id:"string-string1-china"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#string-string1-china"}},[a._v("#")]),a._v(' string string1 = "China";')]),a._v(" "),r("h2",{attrs:{id:"内存的动态分配和静态分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存的动态分配和静态分配"}},[a._v("#")]),a._v(" 内存的动态分配和静态分配")]),a._v(" "),r("p",[a._v("调用对象既可以通过对象名，也可以通过指针，静态分配的内存通过对象名访问，动态分配的内存通过指针访问")]),a._v(" "),r("h3",{attrs:{id:"静态分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#静态分配"}},[a._v("#")]),a._v(" 静态分配")]),a._v(" "),r("p",[a._v("普通方法创建的对象都是静态分配，只有在函数结束时才会进行释放，例如：")]),a._v(" "),r("ul",[r("li",[a._v("Box box1(1,2,3)")])]),a._v(" "),r("h3",{attrs:{id:"动态分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态分配"}},[a._v("#")]),a._v(" 动态分配")]),a._v(" "),r("p",[a._v("c++中new或者c中malloc/calloc/realloc分配的内存，可以随时通过delete或者free释放，例如：delete [] pt; delete p;动态分配内存后，将返回一个指向对象的指针。")]),a._v(" "),r("ul",[r("li",[a._v("Box *pt = new Box(1,2,3);")])]),a._v(" "),r("h2",{attrs:{id:"对象的赋值与复制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象的赋值与复制"}},[a._v("#")]),a._v(" 对象的赋值与复制")]),a._v(" "),r("h3",{attrs:{id:"赋值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#赋值"}},[a._v("#")]),a._v(" 赋值")]),a._v(" "),r("ul",[r("li",[a._v("对象名1 = 对象名2;")])]),a._v(" "),r("h3",{attrs:{id:"复制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复制"}},[a._v("#")]),a._v(" 复制")]),a._v(" "),r("p",[a._v("用对象2复制出对象1")]),a._v(" "),r("ul",[r("li",[a._v("类名 对象1(对象2)")])]),a._v(" "),r("h2",{attrs:{id:"静态数据成员"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#静态数据成员"}},[a._v("#")]),a._v(" 静态数据成员")]),a._v(" "),r("p",[a._v("所有对象共享，在静态存储区创建，只能在类外初始化，不就相当于类变量？")]),a._v(" "),r("h3",{attrs:{id:"class-box"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#class-box"}},[a._v("#")]),a._v(" class Box")]),a._v(" "),r("p",[a._v("{\nstatic int a;//声明\n};")]),a._v(" "),r("h3",{attrs:{id:"初始化-int-box-a-10"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#初始化-int-box-a-10"}},[a._v("#")]),a._v(" 初始化 int Box::a = 10;")]),a._v(" "),r("h2",{attrs:{id:"静态成员函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#静态成员函数"}},[a._v("#")]),a._v(" 静态成员函数")]),a._v(" "),r("p",[a._v("同样只能在类外初始化，且不能和普通成员函数同名，不就相当于类方法？")]),a._v(" "),r("h3",{attrs:{id:"class-box-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#class-box-2"}},[a._v("#")]),a._v(" class Box")]),a._v(" "),r("p",[a._v("{\nstatic int volume();\n};")]),a._v(" "),r("h3",{attrs:{id:"调用box-volume"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#调用box-volume"}},[a._v("#")]),a._v(" 调用Box::volume();")]),a._v(" "),r("h2",{attrs:{id:"友元"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#友元"}},[a._v("#")]),a._v(" 友元")]),a._v(" "),r("h3",{attrs:{id:"友元函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#友元函数"}},[a._v("#")]),a._v(" 友元函数")]),a._v(" "),r("p",[a._v("如果在本类(class A)以外的其他地方(class B)定义了一个函数(可以是成员函数也可以不是成员函数)，在B中用friend对这个函数进行声明，此函数就称为A的友元函数。友元函数可以访问A的私有成员。一个函数可以被多个类声明为朋友")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("步骤")]),a._v(" "),r("p",[a._v("类B中的display为类A的友元函数")]),a._v(" "),r("ul",[r("li",[r("ol",[r("li",[a._v("类A声明一个成员函数void display(B &);不用实现该方法")])])]),a._v(" "),r("li",[a._v("2.类B中声明A的display为友元函数：friend void A::display(Date &);")]),a._v(" "),r("li",[a._v("3.类B中实现该display方法，那么在该实现中就可以访问A的私有变量了")])])])]),a._v(" "),r("h3",{attrs:{id:"友元类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#友元类"}},[a._v("#")]),a._v(" 友元类")]),a._v(" "),r("p",[a._v("在A类的定义体中用friend B;声明B类为A的友元类，那么B类就可以访问A类中的所有成员。")]),a._v(" "),r("h2",{attrs:{id:"运算符重载-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#运算符重载-2"}},[a._v("#")]),a._v(" 运算符重载")]),a._v(" "),r("p",[a._v("C++不允许定义新的运算符，只能对已有的运算符进行重载")]),a._v(" "),r("h3",{attrs:{id:"h-operator-t-a-m-b"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#h-operator-t-a-m-b"}},[a._v("#")]),a._v(" H operator + (T a, M b);")]),a._v(" "),r("p",[a._v("相当于把函数名改成：operator 运算符，T和M至少要有一个是类对象。")]),a._v(" "),r("h3",{attrs:{id:"operator-double-return-real"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#operator-double-return-real"}},[a._v("#")]),a._v(" operator double() { return real}")]),a._v(" "),r("p",[a._v("类型转换函数可以将类转换成其他的类型，这是隐式调用的，比如：double d = 2.5 + Complex(1,2)，其中Complex是类，但是它里面有隐式转换函数，所以可以这样加减")]),a._v(" "),r("h2",{attrs:{id:"编译c"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编译c"}},[a._v("#")]),a._v(" 编译c++")]),a._v(" "),r("h3",{attrs:{id:"clang-std-c-11-g-o-test-test-cpp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#clang-std-c-11-g-o-test-test-cpp"}},[a._v("#")]),a._v(" clang++ -std=c++11 -g -o test test.cpp")]),a._v(" "),r("p",[r("em",[a._v("XMind - Trial Version")])])])}),[],!1,null,null,null);t.default=v.exports}}]);