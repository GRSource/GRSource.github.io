(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{585:function(t,e,i){"use strict";i.r(e);var a=i(65),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"audiotoolbox"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiotoolbox"}},[t._v("#")]),t._v(" AudioToolbox")]),t._v(" "),i("h2",{attrs:{id:"采集设计到的类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#采集设计到的类"}},[t._v("#")]),t._v(" 采集设计到的类")]),t._v(" "),i("h2",{attrs:{id:"audiocomponent"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiocomponent"}},[t._v("#")]),t._v(" AudioComponent")]),t._v(" "),i("h3",{attrs:{id:"_1-audiocomponentdescription"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-audiocomponentdescription"}},[t._v("#")]),t._v(" 1.AudioComponentDescription")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("componentType")]),t._v(" "),i("p",[t._v("一个音频组件的通用的独特的四字节码标识")])]),t._v(" "),i("li",[i("p",[t._v("componentSubType")]),t._v(" "),i("p",[t._v("根据componentType设置相应的类型")])]),t._v(" "),i("li",[i("p",[t._v("componentManufacturer")]),t._v(" "),i("p",[t._v("厂商的身份验证")])]),t._v(" "),i("li",[i("p",[t._v("componentFlags")]),t._v(" "),i("p",[t._v("如果没有一个明确指定的值，那么他必须被设置为0")]),t._v(" "),i("ul",[i("li",[t._v("0")])])]),t._v(" "),i("li",[i("p",[t._v("componentFlagsMask")]),t._v(" "),i("p",[t._v("如果没有一个明确指定的值，那么他必须被设置为0")]),t._v(" "),i("ul",[i("li",[t._v("0")])])]),t._v(" "),i("li",[i("p",[t._v("例子")]),t._v(" "),i("ul",[i("li",[t._v("AudioComponentDescription ioUnitDescription;\nioUnitDescription.componentType = kAudioUnitType_Output;\nioUnitDescription.componentSubType = kAudioUnitSubType_RemoteIO;\nioUnitDescription.componentManufacturer = kAudioUnitManufacturer_Apple;\nioUnitDescription.componentFlags = 0;\nioUnitDescription.componentFlagsMask = 0;")])])])]),t._v(" "),i("h3",{attrs:{id:"_2-audiocomponent-foundiounitreference-audiocomponentfindnext-null-iounitdescription"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-audiocomponent-foundiounitreference-audiocomponentfindnext-null-iounitdescription"}},[t._v("#")]),t._v(" 2.AudioComponent foundIoUnitReference = AudioComponentFindNext(NULL, &ioUnitDescription);")]),t._v(" "),i("p",[t._v("如果第一个参数传空，按照系统定义的排序，找到第一个符合的 audio unit ，如果该参数为先前找到的音频单元，则该功能找到与描述匹配的下一个 audio unit，例如此用法可以通过重复调用 AudioComponentFindNext 来获取所有 I/O 单元的引用。")]),t._v(" "),i("h2",{attrs:{id:"audiounit"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiounit"}},[t._v("#")]),t._v(" AudioUnit")]),t._v(" "),i("p",[t._v("即AudioComponentInstance")]),t._v(" "),i("h3",{attrs:{id:"_3-audiounit-iounitinstance"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-audiounit-iounitinstance"}},[t._v("#")]),t._v(" 3.AudioUnit ioUnitInstance;")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("AudioComponentInstanceNew(foundIoUnitReference, &ioUnitInstance);\n")])])]),i("p",[t._v("初始化componentInstance")]),t._v(" "),i("h3",{attrs:{id:"_4-设置属性-可以使用函数-audiounitsetproperty"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_4-设置属性-可以使用函数-audiounitsetproperty"}},[t._v("#")]),t._v(" 4.设置属性，可以使用函数 AudioUnitSetProperty")]),t._v(" "),i("p",[t._v("第二个 参数AudioUnitPropertyID表示key，就是说你要设置什么类型的属性，比如EnableIO开启输入输出、streamFormat音频流格式等等。")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("UInt32 flagOne = 1;\nAudioUnitSetProperty(ioUnitInstance, kAudioOutputUnitProperty_EnableIO, kAudioUnitScope_Input, 1, &flagOne, sizeof(flagOne));")]),t._v(" "),i("p",[t._v("AudioUnitSetProperty(_ioUnit,kAudioOutputUnitProperty_EnableIO , kAudioUnitScope_Output,0, &flag, sizeof(flag));")]),t._v(" "),i("p",[t._v("上面的1表示Element1为和录音的麦克风相连，0表示Element0和输出硬件相连。，flagOne不知道啥意思，是成功与否的标致吗？")])])]),t._v(" "),i("h3",{attrs:{id:"常见的属性"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#常见的属性"}},[t._v("#")]),t._v(" 常见的属性")]),t._v(" "),i("p",[t._v("大部分属性可以在 audio unit 未初始化的时候设置，因为这些属性一般不会发生改变，有些属性像 iPod EQ unit 中的 kAudioUnitProperty_PresentPreset和 Voice-Processing I/O unit 中的 kAUVoiceIOProperty_MuteOutput 这些属性会在播放音频的时候也会发生改变")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("kAudioOutputUnitProperty_EnableIO")]),t._v(" "),i("p",[t._v("启用或禁止 I/O，默认输出开启，输入禁止。")])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitProperty_ElementCount")]),t._v(" "),i("p",[t._v("配置元素个数")])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitProperty_MaximumFramesPerSlice")]),t._v(" "),i("p",[t._v("设置 audio unit 的最大帧数")])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitProperty_StreamFormat")]),t._v(" "),i("p",[t._v("指定输入 audio unit 输入输出元素的数据格式")])])]),t._v(" "),i("h2",{attrs:{id:"audiounitproperties"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiounitproperties"}},[t._v("#")]),t._v(" AudioUnitProperties")]),t._v(" "),i("h3",{attrs:{id:"aurendercallbackstruct"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#aurendercallbackstruct"}},[t._v("#")]),t._v(" AURenderCallbackStruct")]),t._v(" "),i("p",[t._v("用于给audio unit的输入总线提供数据，\nAURenderCallbackStruct cb;")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("inputProcRefCon")]),t._v(" "),i("ul",[i("li",[t._v("(__bridge void *)(self);")])])]),t._v(" "),i("li",[i("p",[t._v("inputProc设置回调函数")]),t._v(" "),i("p",[t._v("回调函数，从回调函数得到音频数据，可能线程不安全，也可通过AUGraph来设置回调函数，线程安全")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("static OSStatus handleInputBuffer(void *inRefCon,\nAudioUnitRenderActionFlags *ioActionFlags,\nconst AudioTimeStamp *inTimeStamp,\nUInt32 inBusNumber,\nUInt32 inNumberFrames,\nAudioBufferList *ioData)")]),t._v(" "),i("ul",[i("li",[t._v("回调中调用AudioUnitRender，似乎是取数据用的？")])])])])])]),t._v(" "),i("h2",{attrs:{id:"aucomponent"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#aucomponent"}},[t._v("#")]),t._v(" AUComponent")]),t._v(" "),i("h3",{attrs:{id:"audiounitinitialize"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiounitinitialize"}},[t._v("#")]),t._v(" AudioUnitInitialize")]),t._v(" "),i("h2",{attrs:{id:"audiooutputunit"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiooutputunit"}},[t._v("#")]),t._v(" AudioOutputUnit")]),t._v(" "),i("h3",{attrs:{id:"audiooutputunitstart"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiooutputunitstart"}},[t._v("#")]),t._v(" AudioOutputUnitStart")]),t._v(" "),i("h3",{attrs:{id:"audiooutputunitstop"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiooutputunitstop"}},[t._v("#")]),t._v(" AudioOutputUnitStop")]),t._v(" "),i("h2",{attrs:{id:"componenttype和componentsubtype根据不同的音频单元功能来设置"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#componenttype和componentsubtype根据不同的音频单元功能来设置"}},[t._v("#")]),t._v(" componentType和componentSubType根据不同的音频单元功能来设置")]),t._v(" "),i("h3",{attrs:{id:"按使用场景分类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#按使用场景分类"}},[t._v("#")]),t._v(" 按使用场景分类")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("Converter unit")]),t._v(" "),i("p",[t._v("转换器单元，支持线性PCM的音频格式转换。")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("componentType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitType_FormatConverter")])])]),t._v(" "),i("li",[i("p",[t._v("componentSubType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitSubType_AUConverter")])])])])]),t._v(" "),i("li",[i("p",[t._v("iPod Equalizer unit")]),t._v(" "),i("p",[t._v("iOS 4 提供了一个效果单元，iPod Equalizer，与 iPod 内置应用使用相同的均衡器。查看这个 audio unit 的 iPod 应用用户界面，进入设置 -> iPod -> EQ。当使用此 audio unit，必须提供自己的用户界面。此 audio unit 提供了一组预设的均衡曲线，例如低音增强，Pop 和 Spoken Word。iPod均衡器，提供iPod均衡器的功能。")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("componentType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitType_Effect")])])]),t._v(" "),i("li",[i("p",[t._v("componentSubType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitSubType_AUiPodEQ")])])])])]),t._v(" "),i("li",[i("p",[t._v("3D Mixer unit")]),t._v(" "),i("p",[t._v("iOS 提供两个 mixer units。3D Mixer unit 是 OpenAL 的基础，如果需要实现 3D Mixer unit 的特征，可以优先使用 OpenAL，它提供了高级 API，并且非常适合游戏应用程序。3D混音器单元，支持混合多个音频流，输出平移，采样率转换等。")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("componentType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitType_Mixer")])])]),t._v(" "),i("li",[i("p",[t._v("componentSubType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitSubType_SpatialMixer")])])])])]),t._v(" "),i("li",[i("p",[t._v("Multichannel Mixer unit")]),t._v(" "),i("p",[t._v("Multichannel Mixer unit 为任意数量的单声道或立体声提供混音，立体声输出。可以打开和关闭每一个输入，设置输入增益，并设置立体声平移位置。多通道混合器单元，支持将多个音频流混合到一个流中。")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("componentType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitType_Mixer")])])]),t._v(" "),i("li",[i("p",[t._v("componentSubType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitSubType_MultiChannelMixer")])])])])]),t._v(" "),i("li",[i("p",[t._v("Generic Output unit")]),t._v(" "),i("p",[t._v("Generic Output unit 不连接音频硬件，而是提供了一种将处理链的输出发送到应用程序的机制。通常会使用做离线音频处理。通用输出单元，支持向和从线性PCM格式转换；可以用来启动和停止图形。")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("componentType")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("kAudioUnitType_Output")]),t._v(" "),i("p",[t._v("提供的就是I/O的功能")])])])]),t._v(" "),i("li",[i("p",[t._v("componentSubType")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("kAudioUnitSubType_GenericOutput")]),t._v(" "),i("p",[t._v("当 开发者需要进行离线处理，或者说在AUGraph中不使用Speaker(扬声 器)来驱动整个数据流（通常都是Speaker向前一级AUNode要数据），而是希望使用一个输出(可以放入内存队列或 者进行磁盘I/O操作)来驱动数据流时，就使用该子类型。")])])])])])]),t._v(" "),i("li",[i("p",[t._v("Remote I/O unit，音频输出就是用它了")]),t._v(" "),i("p",[t._v("iOS 提供了三个 I/O units，其中 Remote I/O unit 是最常用的。连接输入输出音频硬件，对传入和传出的样本值低延迟访问，提供硬件音频格式和应用音频格式之间的格式转化。远程I/O单元，连接到硬件设备，用于输入、输出或同时输入和输出。")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("componentType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitType_Output")])])]),t._v(" "),i("li",[i("p",[t._v("componentSubType")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("kAudioUnitSubType_RemoteIO")]),t._v(" "),i("p",[t._v("用来采集音频与播放音频的")])])])])])]),t._v(" "),i("li",[i("p",[t._v("Voice Processing I/O unit")]),t._v(" "),i("p",[t._v("Voice-Processing I/O unit 是对 Remote I/O unit 的拓展，添加了语音聊天中的回声消除，还提供了自动增益矫正，语音质量调整，静音等特性。语音处理I/O单元，具有I/O单元的特性并为双向通信添加回声抑制。")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("componentType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitType_Output")])])]),t._v(" "),i("li",[i("p",[t._v("componentSubType")]),t._v(" "),i("ul",[i("li",[t._v("kAudioUnitSubType_VoiceProcessingIO")])])])])])]),t._v(" "),i("h3",{attrs:{id:"按类型和子类型分类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#按类型和子类型分类"}},[t._v("#")]),t._v(" 按类型和子类型分类")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("kAudioUnitType_Effect")]),t._v(" "),i("p",[t._v("提供声音特效处理")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("kAudioUnitSubType_NBandEQ")]),t._v(" "),i("p",[t._v("均衡效果器，主要作用 是为声音的某些频带增强或者减弱能量，该效果器需要指定多个频带， 然后为各个频带设置宽度以及增益，最终将改变声音在频域上的能量分 布。个人理解似乎是降噪关键")])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitSubType_DynamicsProcessor")]),t._v(" "),i("p",[t._v("压缩效果器，主 要作用是当声音较小的时候可以提高声音的能量，当声音的能量超过了 设置的阈值时，可以降低声音的能量，当然应合理地设置作用时间、释 放时间以及触发值，使得最终可以将声音在时域上的能量压缩到一定范 围之内。")])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitSubType_Reverb2")]),t._v(" "),i("p",[t._v("混响效果器，对于人声处 理来讲这是非常重要的效果器，可以想象自己身处在一个空房子中，如 果有非常多的反射声和原始声音叠加在一起，那么从听感上可能会更有 震撼力，但是同时原始声音也会变得更加模糊，原始声音的一些细节会 被遮盖掉，所以混响设置的大或者小对于不同的人来讲会很不一致，可 以根据自己的喜好来进行设置。")])])])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitType_Mixer")]),t._v(" "),i("p",[t._v("提供Mix多路声音的功能")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("3D Mixer")]),t._v(" "),i("p",[t._v("该效果器在移动设备上是无法使用。")])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitSubType_MultiChannelMixer")]),t._v(" "),i("p",[t._v("该效果器将是本书重点介绍的 对象，它是多路声音混音的效果器，可以接收多路音频的输入，还可以 分别调整每一路音频的增益与开关，并将多路音频合并成一路，该效果 器在处理音频的图状结构中非常有用。")])])])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitType_Output")]),t._v(" "),i("p",[t._v("提供的就是I/O的功能")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("kAudioUnitSubType_RemoteIO")]),t._v(" "),i("p",[t._v("用来采集音频与播放音频的")])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitSubType_GenericOutput")]),t._v(" "),i("p",[t._v("当 开发者需要进行离线处理，或者说在AUGraph中不使用Speaker(扬声 器)来驱动整个数据流（通常都是Speaker向前一级AUNode要数据），而是希望使用一个输出(可以放入内存队列或 者进行磁盘I/O操作)来驱动数据流时，就使用该子类型。")])])])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitType_FormatConverter")]),t._v(" "),i("p",[t._v("主要用于提供格式转换 的功能，比如:采样格式由Float到SInt16的转换、交错和平铺的格式转 换、单双声道的转换等，")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("kAudioUnitSubType_AUConverter")]),t._v(" "),i("p",[t._v("当某些效果器对输入的音频格式有 明确的要求时(比如3D Mixer Unit就必须使用UInt16格式的sample)， 或者开发者将音频数据输入给一些其他的编码器进行编码，又或者开发\n     者想使用SInt16格式的PCM裸数据在其他CPU上进行音频算法计算等的 场景下，就需要使用到这个ConverterNode了。下面来看一个比较典型的 场景，我们自定义一个音频播放器(代码仓库中的AudioPlayer项目)， 由FFmpeg解码出来的PCM数据是SInt16格式的，因此不能直接输送给 RemoteIO Unit进行播放，所以需要构建一个ConvertNode将SInt16格式 表示的数据转换为Float32格式表示的数据，然后再输送给RemoteIO Unit，最终才能正常播放出来。")])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitSubType_NewTimePitch")]),t._v(" "),i("p",[t._v("变速 变调效果器，这是一个很有意思的效果器，可以对声音的音高、速度进 行调整，像“会说话的Tom猫”类似的应用场景就可以使用这个效果器来 实现。")])])])]),t._v(" "),i("li",[i("p",[t._v("kAudioUnitType_Generator")]),t._v(" "),i("p",[t._v("使用它来提供播放器的功能")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("kAudioUnitSubType_AudioFilePlayer")]),t._v(" "),i("p",[t._v("在AudioUnit里面，如果我们的输入不是麦克风，而希望其是一个媒体 文件，当然，也可以类似于代码仓库中的AudioPlayer项目自行解码，转 换之后将数据输送给RemoteIO Unit播放出来")])])])])]),t._v(" "),i("h2",{attrs:{id:"audiostreambasicdescription-inputformat-0"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiostreambasicdescription-inputformat-0"}},[t._v("#")]),t._v(" AudioStreamBasicDescription inputFormat = {0};")]),t._v(" "),i("h2",{attrs:{id:"audiostreambasicdescription-outputformat-这里开始是输出音频格式"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiostreambasicdescription-outputformat-这里开始是输出音频格式"}},[t._v("#")]),t._v(" AudioStreamBasicDescription outputFormat; // 这里开始是输出音频格式")]),t._v(" "),i("h2",{attrs:{id:"audioclassdescription-requestedcodecs-2"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audioclassdescription-requestedcodecs-2"}},[t._v("#")]),t._v(" AudioClassDescription requestedCodecs[2] = {")]),t._v(" "),i("h2",{attrs:{id:"audioconverter"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audioconverter"}},[t._v("#")]),t._v(" AudioConverter")]),t._v(" "),i("h3",{attrs:{id:"audioconverternewspecific-inputformat-outputformat-2-requestedcodecs-m-converter"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audioconverternewspecific-inputformat-outputformat-2-requestedcodecs-m-converter"}},[t._v("#")]),t._v(" AudioConverterNewSpecific(&inputFormat, &outputFormat, 2, requestedCodecs, &m_converter);;")]),t._v(" "),i("p",[t._v("创建编码器")]),t._v(" "),i("ul",[i("li",[t._v("AudioConverterFillComplexBuffer编码函数")])]),t._v(" "),i("h3",{attrs:{id:"设置属性audioconvertersetproperty-m-converter-kaudioconverterencodebitrate-propsize-outputbitrate"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#设置属性audioconvertersetproperty-m-converter-kaudioconverterencodebitrate-propsize-outputbitrate"}},[t._v("#")]),t._v(" 设置属性AudioConverterSetProperty(m_converter, kAudioConverterEncodeBitRate, propSize, &outputBitrate);")]),t._v(" "),i("h2",{attrs:{id:"编码相关"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#编码相关"}},[t._v("#")]),t._v(" 编码相关")]),t._v(" "),i("h2",{attrs:{id:"构建音频单元流程-解码播放"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#构建音频单元流程-解码播放"}},[t._v("#")]),t._v(" 构建音频单元流程（解码播放）")]),t._v(" "),i("h3",{attrs:{id:"_1-创建augraph-相当于上下文"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建augraph-相当于上下文"}},[t._v("#")]),t._v(" 1.创建AUGraph(相当于上下文)")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("2.添加各种node")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("3.打开AUGraph")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("4.通过nodeid获取AudioUnit")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("5.创建音频流描述符")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("6.为AudioUnit添加属性（比如添加第5步音频流属性）")]),t._v(" "),i("p",[t._v("AudioStreamBasicDescription streamFormat = [self nonInterleavedPCMFormatWithChannels:2];\n  status = AudioUnitSetProperty(_ioUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 1,\n                 &streamFormat, sizeof(streamFormat));\nioUnit表示为哪个AudioUnit设置属性。\nkAudioUnitProperty_StreamFormat表示设置的是流格式信息。\nkAudioUnitScope_Output表示的是属性添加到AudioUnit的输出范围。我们知道，麦克风的输入和扬声器的输出是由系统控制的，我们没办法接管，我们只能接管麦克风的输出和扬声器的输入，那么谁的输出能被app控制呢？没错，就是麦克风输出的音频流能被app控制。\nAudioUnitElement表示系统的Element，其中Element1表示麦克风和app的通道，Element0表示app和扬声器的通道。\n所以上面代码的意思就是将流格式运用于麦克风的输出上面，那么我们app拿到的原始音频流就是streamFormat类型。")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("7.连接node，并设置回调")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("8.AUGraphInitialize")]),t._v(" "),i("ul",[i("li",[t._v("9.AUGraphStart开始")]),t._v(" "),i("li",[t._v("10.AUGraphStop停止")])])])])])])])])])])])])])])])]),t._v(" "),i("h2",{attrs:{id:"构建音频流描述符audiostreambasicdescription"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#构建音频流描述符audiostreambasicdescription"}},[t._v("#")]),t._v(" 构建音频流描述符AudioStreamBasicDescription")]),t._v(" "),i("h3",{attrs:{id:"msamplerate"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#msamplerate"}},[t._v("#")]),t._v(" mSampleRate")]),t._v(" "),i("p",[t._v("采样率")]),t._v(" "),i("h3",{attrs:{id:"mformatid"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mformatid"}},[t._v("#")]),t._v(" mFormatID")]),t._v(" "),i("p",[t._v("格式")]),t._v(" "),i("ul",[i("li",[t._v("kAudioFormatLinearPCM")])]),t._v(" "),i("h3",{attrs:{id:"mformatflags"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mformatflags"}},[t._v("#")]),t._v(" mFormatFlags")]),t._v(" "),i("p",[t._v("float类型的packet，且是非交错类型")]),t._v(" "),i("ul",[i("li",[t._v("kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved")])]),t._v(" "),i("h3",{attrs:{id:"mbitsperchannel"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mbitsperchannel"}},[t._v("#")]),t._v(" mBitsPerChannel")]),t._v(" "),i("p",[t._v("每帧的比特率，即位深，根据每个样品的字节数x8。\nUInt32 bytesPerSample = sizeof(Float32);")]),t._v(" "),i("ul",[i("li",[t._v("8 * bytesPerSample")])]),t._v(" "),i("h3",{attrs:{id:"mbytesperframe"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mbytesperframe"}},[t._v("#")]),t._v(" mBytesPerFrame")]),t._v(" "),i("p",[t._v("每帧的字节数")]),t._v(" "),i("ul",[i("li",[t._v("bytesPerSample")])]),t._v(" "),i("h3",{attrs:{id:"mbytesperpacket"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mbytesperpacket"}},[t._v("#")]),t._v(" mBytesPerPacket")]),t._v(" "),i("p",[t._v("每个packet的字节数，可能和frame的字节数不一样，因为一个packet可能包含多个frame")]),t._v(" "),i("ul",[i("li",[t._v("bytesPerSample")])]),t._v(" "),i("h3",{attrs:{id:"mframesperpacket"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mframesperpacket"}},[t._v("#")]),t._v(" mFramesPerPacket")]),t._v(" "),i("p",[t._v("每个packet对应的帧数，一般每个packet可以有1帧音频及以上")]),t._v(" "),i("ul",[i("li",[t._v("1")])]),t._v(" "),i("h3",{attrs:{id:"mchannelsperframe"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#mchannelsperframe"}},[t._v("#")]),t._v(" mChannelsPerFrame")]),t._v(" "),i("p",[t._v("通道数")]),t._v(" "),i("h2",{attrs:{id:"audiounitscope和audiounitelement介绍"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiounitscope和audiounitelement介绍"}},[t._v("#")]),t._v(" AudioUnitScope和AudioUnitElement介绍")]),t._v(" "),i("h3",{attrs:{id:"audiounitelement代表的是通道-一般有两条通道-0表示输出通道-1表示输入通道-而输入通道和输出通道又有通道头和通道尾-如果audiounit类型是remoteio-那么输入通道的scopeinput连接麦克风-我们无法控制input流格式-输出通道的scopeoutput连接扬声器-我们也无法控制ouput的流格式-此时我们只能控制输入通道的通道尾-scopeoutput-和输出通道的通道头-scopeinput-输入通道的数据交给app-输出通道同app拿数据-如果不是remoteio类型-那我们就可以随意控制流格式信息了。这就是element和scope的关系"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audiounitelement代表的是通道-一般有两条通道-0表示输出通道-1表示输入通道-而输入通道和输出通道又有通道头和通道尾-如果audiounit类型是remoteio-那么输入通道的scopeinput连接麦克风-我们无法控制input流格式-输出通道的scopeoutput连接扬声器-我们也无法控制ouput的流格式-此时我们只能控制输入通道的通道尾-scopeoutput-和输出通道的通道头-scopeinput-输入通道的数据交给app-输出通道同app拿数据-如果不是remoteio类型-那我们就可以随意控制流格式信息了。这就是element和scope的关系"}},[t._v("#")]),t._v(" AudioUnitElement代表的是通道，一般有两条通道，0表示输出通道，1表示输入通道，而输入通道和输出通道又有通道头和通道尾，如果AudioUnit类型是RemoteIO，那么输入通道的scopeinput连接麦克风，我们无法控制input流格式，输出通道的scopeoutput连接扬声器，我们也无法控制ouput的流格式，此时我们只能控制输入通道的通道尾(scopeoutput)和输出通道的通道头(scopeinput)，输入通道的数据交给app，输出通道同app拿数据，如果不是remoteIO类型，那我们就可以随意控制流格式信息了。这就是element和scope的关系")]),t._v(" "),i("h3",{attrs:{id:"输入输出通道数可以不对称-即可以没有输入通道-因为我们可以直接从app参数输入-然后传入输出通道。"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#输入输出通道数可以不对称-即可以没有输入通道-因为我们可以直接从app参数输入-然后传入输出通道。"}},[t._v("#")]),t._v(" 输入输出通道数可以不对称，即可以没有输入通道，因为我们可以直接从app参数输入，然后传入输出通道。")]),t._v(" "),i("h2",{attrs:{id:"adts头"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#adts头"}},[t._v("#")]),t._v(" ADTS头")]),t._v(" "),i("p",[t._v("总共7个字节")]),t._v(" "),i("h3",{attrs:{id:"adts-fixed-header"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#adts-fixed-header"}},[t._v("#")]),t._v(" adts_fixed_header")]),t._v(" "),i("p",[t._v("占用28个bit位")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("packet[0]")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("syncword ：同步头 总是0xFFF, all bits must be 1，代表着一个ADTS帧的开始，占用12个比特位，所以packet[1]中前4位也是1，是属于syncword的标识")]),t._v(" "),i("ul",[i("li",[t._v("11111111")])])])])]),t._v(" "),i("li",[i("p",[t._v("packet[1]")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("ID：MPEG Version: 0 for MPEG-4, 1 for MPEG-2，占用1个比特位，即packet[1]中的高位第5位")]),t._v(" "),i("ul",[i("li",[t._v("1111   1")])])]),t._v(" "),i("li",[i("p",[t._v("Layer：always: '00'，占用两个比特位，即packet[1]中的第6和第7位")]),t._v(" "),i("ul",[i("li",[t._v("00")])])]),t._v(" "),i("li",[i("p",[t._v("protection_absent：第8位，总是为1")]),t._v(" "),i("ul",[i("li",[t._v("1")])])])])]),t._v(" "),i("li",[i("p",[t._v("packet[2]")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("高位2个bit表示：profile：表示使用哪个级别的AAC，有些芯片只支持AAC LC 。在MPEG-2 AAC中定义了3种：")]),t._v(" "),i("ul",[i("li",[t._v("0代表main profile")]),t._v(" "),i("li",[t._v("1.代表LC")]),t._v(" "),i("li",[t._v("2.SSR")]),t._v(" "),i("li",[t._v("3.reserved")])])]),t._v(" "),i("li",[i("p",[t._v("sampling_frequency_index：表示使用的采样率下标，通过这个下标在 Sampling Frequencies[ ]数组中查找得知采样率的值。占4个比特位")]),t._v(" "),i("ul",[i("li",[t._v("0: 96000 Hz")]),t._v(" "),i("li",[t._v("1: 88200 Hz")]),t._v(" "),i("li",[t._v("2: 64000 Hz")]),t._v(" "),i("li",[t._v("3: 48000 Hz")]),t._v(" "),i("li",[t._v("4: 44100 Hz")]),t._v(" "),i("li",[t._v("5: 32000 Hz")]),t._v(" "),i("li",[t._v("6: 24000 Hz")]),t._v(" "),i("li",[t._v("7: 22050 Hz")]),t._v(" "),i("li",[t._v("8: 16000 Hz")]),t._v(" "),i("li",[t._v("9: 12000 Hz")]),t._v(" "),i("li",[t._v("10: 11025 Hz")]),t._v(" "),i("li",[t._v("11: 8000 Hz")]),t._v(" "),i("li",[t._v("12: 7350 Hz")]),t._v(" "),i("li",[t._v("13: Reserved")]),t._v(" "),i("li",[t._v("14: Reserved")]),t._v(" "),i("li",[t._v("15: frequency is written explictly")])])]),t._v(" "),i("li",[i("p",[t._v("private_bit:第7位，总是为0")])]),t._v(" "),i("li",[i("p",[t._v("channel_configuration：声道数，占三个bit，所以packet[3]中的前2个bit也是这个属性的标识")]),t._v(" "),i("ul",[i("li",[t._v("0: Defined in AOT Specifc Config")]),t._v(" "),i("li",[t._v("1: 1 channel: front-center")]),t._v(" "),i("li",[t._v("2: 2 channels: front-left, front-right")]),t._v(" "),i("li",[t._v("3: 3 channels: front-center, front-left, front-right")]),t._v(" "),i("li",[t._v("4: 4 channels: front-center, front-left, front-right, back-center")]),t._v(" "),i("li",[t._v("5: 5 channels: front-center, front-left, front-right, back-left, back-right")]),t._v(" "),i("li",[t._v("6: 6 channels: front-center, front-left, front-right, back-left, back-right, LFE-channel")]),t._v(" "),i("li",[t._v("7: 8 channels: front-center, front-left, front-right, side-left, side-right, back-left, back-right, LFE-channel")]),t._v(" "),i("li",[t._v("8-15: Reserved")])])])])]),t._v(" "),i("li",[i("p",[t._v("packet[3]")]),t._v(" "),i("ul",[i("li",[t._v("original_copy：占用1个bit位，从高位算起第3位，通常为0")]),t._v(" "),i("li",[t._v("home：占用1个bit位，第4位，通常为0")])])])]),t._v(" "),i("h3",{attrs:{id:"adts-variable-header"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#adts-variable-header"}},[t._v("#")]),t._v(" adts_variable_header")]),t._v(" "),i("p",[t._v("占用28个bit位")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("packet[3]")]),t._v(" "),i("ul",[i("li",[t._v("copyright_identification_bit：占用1个比特位，第5位，通常为0")]),t._v(" "),i("li",[t._v("copyright_identification_start：占用1个比特位，第6位，通常为0")])])]),t._v(" "),i("li",[i("p",[t._v("packet[4]")]),t._v(" "),i("ul",[i("li",[t._v("aac_frame_length：帧的长度（包含了ADTS头(7字节)和AAC原始流），占用13个比特位，所以packet[3]的后2位、packet[4]的8位、packet[5]的前3位都该属性的标识")])])]),t._v(" "),i("li",[i("p",[t._v("packet[5]")]),t._v(" "),i("ul",[i("li",[t._v("adts_buffer_fullness：0x7FF 说明是码率可变的码流，占用11个bit位，所以packet[5]的后5位和packet[6]的前6位都是该属性的标识")])])]),t._v(" "),i("li",[i("p",[t._v("packet[6]")]),t._v(" "),i("ul",[i("li",[t._v("number_of_raw_data_blocks_in_frame：占用2个bit位，packet[6]的后2位是该属性的标识")])])])]),t._v(" "),i("h2",{attrs:{id:"编码"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#编码"}},[t._v("#")]),t._v(" 编码")]),t._v(" "),i("h3",{attrs:{id:"_1-构建音频描述符audiostreambasicdescription"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-构建音频描述符audiostreambasicdescription"}},[t._v("#")]),t._v(" 1.构建音频描述符AudioStreamBasicDescription")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("2.构建编码器类描述符")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("3.构建AudioConverter，方法：AudioConverterNewSpecific")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("4.设置比特率AudioConverterSetProperty")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("5.获取packet大小AudioConverterGetProperty")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("6.构建outPacketDescription和获取元数据AudioBufferList，方法：AudioConverterFillComplexBuffer(_audioConverter, inInputDataProc, (__bridge void *)(self), &ioOutputDataPacketSize, &outAudioBufferList, outPacketDescription);")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("7.构建ADTS头，ADTS总共7个字节")]),t._v(" "),i("ul",[i("li",[t._v("子主题 1")])])])])])])])])])])])])])]),t._v(" "),i("h2",{attrs:{id:"编码器描述符"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#编码器描述符"}},[t._v("#")]),t._v(" 编码器描述符")]),t._v(" "),i("h3",{attrs:{id:"audioformatgetpropertyinfo-kaudioformatproperty-encoders"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audioformatgetpropertyinfo-kaudioformatproperty-encoders"}},[t._v("#")]),t._v(" AudioFormatGetPropertyInfo(kAudioFormatProperty_Encoders,")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("                                sizeof(encoderSpecifier),\n                                &encoderSpecifier,\n                                &size);\n")])])]),i("ul",[i("li",[t._v("1.获取io属性大小:size")])]),t._v(" "),i("h3",{attrs:{id:"audioformatgetproperty-kaudioformatproperty-encoders"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#audioformatgetproperty-kaudioformatproperty-encoders"}},[t._v("#")]),t._v(" AudioFormatGetProperty(kAudioFormatProperty_Encoders,")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("                            sizeof(encoderSpecifier),\n                            &encoderSpecifier,\n                            &size,\n                            descriptions);\n")])])]),i("ul",[i("li",[t._v("2.获取支持encoderSpecifier格式的描述符数组")])]),t._v(" "),i("h3",{attrs:{id:"for-unsigned-int-i-0-i-count-i"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#for-unsigned-int-i-0-i-count-i"}},[t._v("#")]),t._v(" for (unsigned int i = 0; i < count; i++) {")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("    if ((type == descriptions[i].mSubType) &&\n        (manufacturer == descriptions[i].mManufacturer)) {\n        memcpy(&desc, &(descriptions[i]), sizeof(desc));\n        return &desc;\n    }\n}\n")])])]),i("ul",[i("li",[t._v("3.遍历描述符数组，找到对应的描述符")])]),t._v(" "),i("p",[i("em",[t._v("XMind - Trial Version")])])])}),[],!1,null,null,null);e.default=r.exports}}]);