(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{594:function(t,e,i){"use strict";i.r(e);var r=i(65),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"lflivekit"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lflivekit"}},[t._v("#")]),t._v(" LFLiveKit")]),t._v(" "),i("h2",{attrs:{id:"nginx服务器"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#nginx服务器"}},[t._v("#")]),t._v(" nginx服务器")]),t._v(" "),i("h3",{attrs:{id:"配置nginx-conf"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#配置nginx-conf"}},[t._v("#")]),t._v(" 配置nginx.conf")]),t._v(" "),i("h3",{attrs:{id:"端口号1935"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#端口号1935"}},[t._v("#")]),t._v(" 端口号1935")]),t._v(" "),i("h2",{attrs:{id:"rtmp协议"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#rtmp协议"}},[t._v("#")]),t._v(" rtmp协议")]),t._v(" "),i("h2",{attrs:{id:"gpuimage"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#gpuimage"}},[t._v("#")]),t._v(" GPUImage")]),t._v(" "),i("h3",{attrs:{id:"视频采集"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#视频采集"}},[t._v("#")]),t._v(" 视频采集")]),t._v(" "),i("h3",{attrs:{id:"滤镜"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#滤镜"}},[t._v("#")]),t._v(" 滤镜")]),t._v(" "),i("h2",{attrs:{id:"结构属性"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#结构属性"}},[t._v("#")]),t._v(" 结构属性")]),t._v(" "),i("h3",{attrs:{id:"lflivestreaminfo"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lflivestreaminfo"}},[t._v("#")]),t._v(" LFLiveStreamInfo")]),t._v(" "),i("p",[t._v("用于声明流信息的类，作用类似于model单纯的存储信息。用户可以通过这个类设置去音视频的具体参数，其中包含视频的音视频的相关设置等")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("NSString *streamId;")])]),t._v(" "),i("li",[i("p",[t._v("NSString *host;")])]),t._v(" "),i("li",[i("p",[t._v("NSInteger port;")])]),t._v(" "),i("li",[i("p",[t._v("url")])]),t._v(" "),i("li",[i("p",[t._v("LFLiveAudioConfiguration *audioConfiguration;")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("NSUInteger numberOfChannels;")]),t._v(" "),i("p",[t._v("声道数目，default 2")])]),t._v(" "),i("li",[i("p",[t._v("LFLiveAudioSampleRate audioSampleRate;")]),t._v(" "),i("p",[t._v("采样率")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("LFLiveAudioSampleRate_16000Hz")])]),t._v(" "),i("li",[i("p",[t._v("LFLiveAudioSampleRate_44100Hz")]),t._v(" "),i("ul",[i("li",[t._v("default")])])]),t._v(" "),i("li",[i("p",[t._v("LFLiveAudioSampleRate_48000Hz")])])])]),t._v(" "),i("li",[i("p",[t._v("LFLiveAudioBitRate audioBitrate;")]),t._v(" "),i("p",[t._v("码率")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("LFLiveAudioBitRate_32Kbps")])]),t._v(" "),i("li",[i("p",[t._v("LFLiveAudioBitRate_64Kbps")])]),t._v(" "),i("li",[i("p",[t._v("LFLiveAudioBitRate_96Kbps")]),t._v(" "),i("ul",[i("li",[t._v("default")])])]),t._v(" "),i("li",[i("p",[t._v("LFLiveAudioBitRate_128Kbps")])])])]),t._v(" "),i("li",[i("p",[t._v("char *asc;")]),t._v(" "),i("p",[t._v("flv编码音频头 44100 为0x12 0x10")])]),t._v(" "),i("li",[i("p",[t._v("NSUInteger bufferLength;")]),t._v(" "),i("p",[t._v("缓存区长度")])])])]),t._v(" "),i("li",[i("p",[t._v("LFLiveVideoConfiguration *videoConfiguration;")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("CGSize videoSize;")]),t._v(" "),i("p",[t._v("视频的分辨率，宽高务必设定为 2 的倍数，否则解码播放时可能出现绿边(这个videoSizeRespectingAspectRatio设置为YES则可能会改变)")])]),t._v(" "),i("li",[i("p",[t._v("videoSizeRespectingAspectRatio")]),t._v(" "),i("p",[t._v("输出图像是否等比例,默认为NO")])]),t._v(" "),i("li",[i("p",[t._v("UIInterfaceOrientation outputImageOrientation;")]),t._v(" "),i("p",[t._v("视频输出方向")])]),t._v(" "),i("li",[i("p",[t._v("BOOL autorotate;")]),t._v(" "),i("p",[t._v("自动旋转(这里只支持 left 变 right  portrait 变 portraitUpsideDown)")])]),t._v(" "),i("li",[i("p",[t._v("NSUInteger videoFrameRate;")]),t._v(" "),i("p",[t._v("视频的帧率，即 fps，一般24、25、30")])]),t._v(" "),i("li",[i("p",[t._v("NSUInteger videoMaxFrameRate;")]),t._v(" "),i("p",[t._v("视频的最大帧率，即 fps")])]),t._v(" "),i("li",[i("p",[t._v("NSUInteger videoMinFrameRate;")]),t._v(" "),i("p",[t._v("视频的最小帧率，即 fps")])]),t._v(" "),i("li",[i("p",[t._v("NSUInteger videoMaxKeyframeInterval;")]),t._v(" "),i("p",[t._v("最大关键帧间隔，可设定为 fps 的2倍，影响一个 gop 的大小，也就是最多2秒显示一个关键帧")])]),t._v(" "),i("li",[i("p",[t._v("NSUInteger videoBitRate;")]),t._v(" "),i("p",[t._v("视频的码率，单位是 bps")])]),t._v(" "),i("li",[i("p",[t._v("NSUInteger videoMaxBitRate;")]),t._v(" "),i("p",[t._v("视频的最大码率，单位是 bps")])]),t._v(" "),i("li",[i("p",[t._v("NSUInteger videoMinBitRate;")]),t._v(" "),i("p",[t._v("视频的最小码率，单位是 bps")])]),t._v(" "),i("li",[i("p",[t._v("LFLiveVideoSessionPreset sessionPreset;")]),t._v(" "),i("p",[t._v("分辨率")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("LFCaptureSessionPreset360x640")]),t._v(" "),i("p",[t._v("低分辨率")])]),t._v(" "),i("li",[i("p",[t._v("LFCaptureSessionPreset540x960")]),t._v(" "),i("p",[t._v("中分辨率")])]),t._v(" "),i("li",[i("p",[t._v("LFCaptureSessionPreset720x1280")]),t._v(" "),i("p",[t._v("高分辨率")]),t._v(" "),i("ul",[i("li",[t._v("default")])])])])]),t._v(" "),i("li",[i("p",[t._v("NSString *avSessionPreset;")]),t._v(" "),i("p",[t._v("< ≈sde3分辨率")])]),t._v(" "),i("li",[i("p",[t._v("BOOL landscape;")]),t._v(" "),i("p",[t._v("< 是否是横屏")])])])])]),t._v(" "),i("h3",{attrs:{id:"lflivesession"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#lflivesession"}},[t._v("#")]),t._v(" LFLiveSession")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("BOOL running;")]),t._v(" "),i("p",[t._v("是否开始采集视频")])]),t._v(" "),i("li",[i("p",[t._v("UIView *preView;")]),t._v(" "),i("p",[t._v("用于显示的view")])]),t._v(" "),i("li",[i("ul",[i("li",[t._v("(void)startLive:")])]),t._v(" "),i("p",[t._v("开始直播")])]),t._v(" "),i("li",[i("ul",[i("li",[t._v("(void)stopLive")])]),t._v(" "),i("p",[t._v("停止直播")])]),t._v(" "),i("li",[i("p",[t._v("LFVideoCapture *videoCaptureSource;视频采集类")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("最终调用GPUImage里面的GPUImageVideoCamera类的startCameraCapture方法进行采集")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("通过打印发现GPUImage采集到的CVPixelBufferRef，其pixelFormatType为BGRA，它的颜色空间为BGRA，其在内存中的顺序是BGRABGRA...，所以是kCVPixelFormatType_32BGRA类型？并不是，采集是420f，内部通过一次转换，最后用户发现是RGB类型")]),t._v(" "),i("ul",[i("li",[t._v("对数据进行硬编码LFHardwareVideoEncoder类")])])])])])])]),t._v(" "),i("li",[i("p",[t._v("LFAudioCapture *audioCaptureSource;音频采集类")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("最终使用AudioToolbox中的AudioOutputUnitStart进行采集")]),t._v(" "),i("ul",[i("li",[t._v("对采集的数据进行编码LFHardwareAudioEncoder")])])])])]),t._v(" "),i("li",[i("p",[t._v("LFHardwareAudioEncoder音频编码类")]),t._v(" "),i("p",[t._v("使用系统AudioToolbox进行硬编码")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("初始化编码器")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("初始化输入流描述符")]),t._v(" "),i("ul",[i("li",[i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("AudioStreamBasicDescription inputFormat = {0};\n")])])])])])])])])]),t._v(" "),i("p",[t._v("inputFormat.mSampleRate = _configuration.audioSampleRate;\ninputFormat.mFormatID = kAudioFormatLinearPCM;\ninputFormat.mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagsNativeEndian | kAudioFormatFlagIsPacked;\ninputFormat.mChannelsPerFrame = (UInt32)_configuration.numberOfChannels;\ninputFormat.mFramesPerPacket = 1;\ninputFormat.mBitsPerChannel = 16;\ninputFormat.mBytesPerFrame = inputFormat.mBitsPerChannel / 8 * inputFormat.mChannelsPerFrame;\ninputFormat.mBytesPerPacket = inputFormat.mBytesPerFrame * inputFormat.mFramesPerPacket;")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("  - 初始化输出流描述符\n\n  \t-     AudioStreamBasicDescription outputFormat; // 这里开始是输出音频格式\n")])])]),i("p",[t._v("memset(&outputFormat, 0, sizeof(outputFormat));\noutputFormat.mSampleRate = inputFormat.mSampleRate;       // 采样率保持一致\noutputFormat.mFormatID = kAudioFormatMPEG4AAC;            // AAC编码 kAudioFormatMPEG4AAC kAudioFormatMPEG4AAC_HE_V2\noutputFormat.mChannelsPerFrame = (UInt32)_configuration.numberOfChannels;;\noutputFormat.mFramesPerPacket = 1024;                     // AAC一帧是1024个字节")])]),t._v(" "),i("li",[i("p",[t._v("iOS8.0及以上LFHardwareVideoEncoder视频硬编码类，iOS8以下采用软编码")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("初始化编码器")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("OSStatus status = VTCompressionSessionCreate(NULL, _configuration.videoSize.width, _configuration.videoSize.height, kCMVideoCodecType_H264, NULL, NULL, NULL, VideoCompressonOutputCallback, (__bridge void *)self, &compressionSession);")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("设置编码属性")]),t._v(" "),i("ul",[i("li",[i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("VTSessionSetProperty(compressionSession, kVTCompressionPropertyKey_MaxKeyFrameInterval, (__bridge CFTypeRef)@(_configuration.videoMaxKeyframeInterval));\n")])])])])])])])])])])]),t._v(" "),i("p",[t._v("VTSessionSetProperty(compressionSession, kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration, (__bridge CFTypeRef)@(_configuration.videoMaxKeyframeInterval/_configuration.videoFrameRate));\nVTSessionSetProperty(compressionSession, kVTCompressionPropertyKey_ExpectedFrameRate, (__bridge CFTypeRef)@(_configuration.videoFrameRate));\nVTSessionSetProperty(compressionSession, kVTCompressionPropertyKey_AverageBitRate, (__bridge CFTypeRef)@(_configuration.videoBitRate));\nNSArray *limit = @[@(_configuration.videoBitRate * 1.5/8), @(1)];\nVTSessionSetProperty(compressionSession, kVTCompressionPropertyKey_DataRateLimits, (__bridge CFArrayRef)limit);\nVTSessionSetProperty(compressionSession, kVTCompressionPropertyKey_RealTime, kCFBooleanTrue);\nVTSessionSetProperty(compressionSession, kVTCompressionPropertyKey_ProfileLevel, kVTProfileLevel_H264_Main_AutoLevel);\nVTSessionSetProperty(compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, kCFBooleanTrue);\nVTSessionSetProperty(compressionSession, kVTCompressionPropertyKey_H264EntropyMode, kVTH264EntropyMode_CABAC);")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("  \t\t\t- 准备编码\n\n  \t\t\t\t- VTCompressionSessionPrepareToEncodeFrames(compressionSession);\n\n  \t\t\t\t\t- 输入待编码的数据\n\n  \t\t\t\t\t\t- OSStatus status = VTCompressionSessionEncodeFrame(compressionSession, pixelBuffer, presentationTimeStamp, duration, (__bridge CFDictionaryRef)properties, (__bridge_retained void *)timeNumber, &flags);\n\n  \t\t\t\t\t\t  就是向编码器中传入pixelBuffer\n\n  \t\t\t\t\t\t\t- 获取编码后的数据\n\n  \t\t\t\t\t\t\t  通过初始化时的回调函数VideoCompressonOutputCallback获取编码后的数据，如果这一帧是关键帧，那么我们需要获取SPS和PPS数据，然后给这些数据加上开始码返回出去。\n\n  \t\t\t\t\t\t\t\t- 判断是否是关键帧\n\n  \t\t\t\t\t\t\t\t\t- 是\n\n  \t\t\t\t\t\t\t\t\t\t- 获取pps和sps\n\n  \t\t\t\t\t\t\t\t\t\t\t- CMFormatDescriptionRef format = CMSampleBufferGetFormatDescription(sampleBuffer);       OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 0, &sparameterSet, &sparameterSetSize, &sparameterSetCount, 0);    OSStatus statusCode = CMVideoFormatDescriptionGetH264ParameterSetAtIndex(format, 1, &pparameterSet, &pparameterSetSize, &pparameterSetCount, 0);\n\n  \t\t\t\t\t\t\t\t\t\t\t\t- 获取到sps和pps后，获取帧数据\n\n  \t\t\t\t\t\t\t\t\t\t\t\t\t-     CMBlockBufferRef dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer);\n")])])]),i("p",[t._v("size_t length, totalLength;\nchar *dataPointer;\nOSStatus statusCodeRet = CMBlockBufferGetDataPointer(dataBuffer, 0, &length, &totalLength, &dataPointer);")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("  \t\t\t\t\t\t\t\t\t\t\t\t\t\t- 读取NAL Unit长度\n\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t-             uint32_t NALUnitLength = 0;\n      memcpy(&NALUnitLength, dataPointer + bufferOffset, AVCCHeaderLength);\n\n      NALUnitLength = CFSwapInt32BigToHost(NALUnitLength);//大端转小端\n\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- 组装成LFVideoFrame\n\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  里面包含了时间戳、帧数据、sps、pps字段\n\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- 通过LFStreamRTMPSocket发送音频流\n\n  \t\t\t\t\t\t\t\t\t- 否\n")])])])]),t._v(" "),i("li",[i("p",[t._v("LFStreamRTMPSocket数据发送类")]),t._v(" "),i("p",[t._v("对pili-librtmp的封装")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("开始直播时，建立连接通道")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("分配与初始化rtmp")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("_rtmp = PILI_RTMP_Alloc();\nPILI_RTMP_Init(_rtmp);")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("设置url")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("子主题 1")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("PILI_RTMP_SetupURL(_rtmp, push_url, &_error)")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("设置错误回调、连接回调函数")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("_rtmp->m_errorCallback = RTMPErrorCallback;\n_rtmp->m_connCallback = ConnectionTimeCallback;\n_rtmp->m_userData = (__bridge void *)self;\n_rtmp->m_msgCounter = 1;\n_rtmp->Link.timeout = RTMP_RECEIVE_TIMEOUT;")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("//设置可写，即发布流，这个函数必须在连接前使用，否则无效\nPILI_RTMP_EnableWrite(_rtmp);")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("//连接服务器\nif (PILI_RTMP_Connect(_rtmp, NULL, &_error) == FALSE) {\ngoto Failed;\n}")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("//连接流\nif (PILI_RTMP_ConnectStream(_rtmp, 0, &_error) == FALSE) {\ngoto Failed;\n}")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("连接成功后发送一个参数包，里面包含了一系列参数，方便后面数据的解析")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("初始化完成后开始发送数据")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("对需要发送的LFAudioFrame和LFVideoFrame数据进行缓存，根据时间戳进行排序，缓存的目的主要主要有两个：一是因为包是逐个发送的，需要发送完一个再发送下一个。二是因为我们需要根据帧的时间戳进行排序，排序完后再进行发送")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("准备发送")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("如果当前需要发送的帧是LFVideoFrame")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("视频帧发送前需要先发送sps和pps，如果未发送过，就要优先发送sendVideoHeader")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("然后发送视频帧sendVideo")]),t._v(" "),i("ul",[i("li",[t._v("通过PILI_RTMP_SendPacket函数发送出去")])])])])])])]),t._v(" "),i("li",[i("p",[t._v("如果当前需要发送的帧是LFAudioFrame")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("音频帧发送前需要发送服务器将aac打包成flv所需要的头部信息(44100Hz为0x12、0x10)，即发送\nbody[0] = 0xAF;\nbody[1] = 0x01;")]),t._v(" "),i("ul",[i("li",[i("p",[t._v("然后发送音频帧sendAudio")]),t._v(" "),i("ul",[i("li",[t._v("通过PILI_RTMP_SendPacket函数发送出去")])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])])]),t._v(" "),i("h2",{attrs:{id:"ffmpeg可以推流"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#ffmpeg可以推流"}},[t._v("#")]),t._v(" ffmpeg可以推流")]),t._v(" "),i("p",[i("em",[t._v("XMind - Trial Version")])])])}),[],!1,null,null,null);e.default=a.exports}}]);