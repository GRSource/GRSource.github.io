(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{595:function(e,r,a){"use strict";a.r(r);var t=a(65),s=Object(t.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"metal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#metal"}},[e._v("#")]),e._v(" Metal")]),e._v(" "),a("h2",{attrs:{id:"cametallayer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cametallayer"}},[e._v("#")]),e._v(" CAMetalLayer")]),e._v(" "),a("h3",{attrs:{id:"pixelformat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pixelformat"}},[e._v("#")]),e._v(" pixelFormat")]),e._v(" "),a("ul",[a("li",[a("p",[e._v(".bgra8Unorm")]),e._v(" "),a("p",[e._v("每个像素由蓝、绿、红、alpha分量组成，每个分量是一个8位无符号整数(0-255)")])])]),e._v(" "),a("h3",{attrs:{id:"mtldevice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mtldevice"}},[e._v("#")]),e._v(" MTLDevice")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("MTLCommandQueue")]),e._v(" "),a("p",[e._v("保存了一系列要执行的命令缓存，长期持有，不用每次都创建")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("MTLCommandBuffer")]),e._v(" "),a("p",[e._v("表示一个渲染命令的集合单元")]),e._v(" "),a("ul",[a("li",[e._v("一切设置完之后commandBuffer.commit")])])])])]),e._v(" "),a("li",[a("p",[e._v("render states")])]),e._v(" "),a("li",[a("p",[e._v("MTLLibrary")]),e._v(" "),a("p",[e._v("makeDefaultLibrary，参数为shader所在的bundle")])])]),e._v(" "),a("h3",{attrs:{id:"cametaldrawable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cametaldrawable"}},[e._v("#")]),e._v(" CAMetalDrawable")]),e._v(" "),a("p",[e._v("从layer当中取出下一个空画板(drawable)，然后取出对应的可绘制的texture属性赋给渲染描述符Descriptor，用于绘制")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("MTLTexture")]),e._v(" "),a("p",[e._v("单个纹理可以对应一组图像")])])]),e._v(" "),a("h2",{attrs:{id:"mtlrendercommandencoder"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mtlrendercommandencoder"}},[e._v("#")]),e._v(" MTLRenderCommandEncoder")]),e._v(" "),a("p",[e._v("通过commandBuffer?.makeRenderCommandEncoder获得，负责将高级指令转换成底层指令（设置着色器参数、绘制三角形等等），然后将这些指令写入commandBuffer，完成之后设置endEncoding。encoder是配置跟程序相关的一些设置")]),e._v(" "),a("h2",{attrs:{id:"mtlrenderpassdescriptor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mtlrenderpassdescriptor"}},[e._v("#")]),e._v(" MTLRenderPassDescriptor")]),e._v(" "),a("p",[e._v("告诉Metal在渲染图像时要执行哪些操作。里面进行一些一些跟程序无关的系统设置")]),e._v(" "),a("h3",{attrs:{id:"mtlrenderpasscolorattachmentdescriptor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mtlrenderpasscolorattachmentdescriptor"}},[e._v("#")]),e._v(" MTLRenderPassColorAttachmentDescriptor")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("loadAction")]),e._v(" "),a("p",[e._v("决定每次渲染是否清除或者保留之前的内容")]),e._v(" "),a("ul",[a("li",[e._v(".clear")]),e._v(" "),a("li",[e._v(".dontCare")]),e._v(" "),a("li",[e._v(".load")])])]),e._v(" "),a("li",[a("p",[e._v("storeAction")]),e._v(" "),a("p",[e._v("决定渲染对纹理的影响：结果是被存储还是丢弃，因为我们希望我们的像素最终出现在屏幕上，所以我们选择.store")])]),e._v(" "),a("li",[a("p",[e._v("clearColor")]),e._v(" "),a("p",[e._v("绘制之前显示的颜色，也就是清理后的背景色")])]),e._v(" "),a("li",[a("p",[e._v("texture")]),e._v(" "),a("p",[e._v("回调的texture（即空画板）")])])]),e._v(" "),a("h2",{attrs:{id:"framebuffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#framebuffer"}},[e._v("#")]),e._v(" framebuffer")]),e._v(" "),a("p",[e._v("像素被写入的地方")]),e._v(" "),a("h2",{attrs:{id:"mtlbuffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mtlbuffer"}},[e._v("#")]),e._v(" MTLBuffer")]),e._v(" "),a("p",[e._v("与设备相关的缓冲区，由设备管理，用来存储数据，所以需要由设备创建device.makeBuffer，可以创建顶点、颜色、纹理等坐标缓存，用于commandEncoder")]),e._v(" "),a("h2",{attrs:{id:"shaders-metal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shaders-metal"}},[e._v("#")]),e._v(" Shaders.metal")]),e._v(" "),a("h3",{attrs:{id:"vertex-coloredvertex-vertex-main-constant-float4-position-buffer-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vertex-coloredvertex-vertex-main-constant-float4-position-buffer-0"}},[e._v("#")]),e._v(" vertex ColoredVertex vertex_main(constant float4 *position[[buffer(0)]],")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("                                                         constant float4 *color[[buffer(1)]],\n                             uint vid[[vertex_id]])\n")])])]),a("p",[e._v("{\nColoredVertex vert;\nvert.position = position[vid];\nvert.color = color[vid];\nreturn vert;\n}")]),e._v(" "),a("p",[e._v("fragment float4 fragment_main(ColoredVertex vert[[stage_in]])\n{\nreturn vert.color;\n}")]),e._v(" "),a("ul",[a("li",[e._v("顶点着色器是微观着色程序，片元着色器是宏观着色程序")]),e._v(" "),a("li",[e._v("buffer(0)和buffer(1)对应encoder创建时设置的索引")]),e._v(" "),a("li",[e._v("vid对应当前顶点，从0-2运行（对于三角形中每个点运行一次）")]),e._v(" "),a("li",[e._v("片元着色器中的参数vert和顶点着色器中返回vert并不是一一对应的关系，因为顶点着色器可能只会调用三次来绘制我们的三角形，而片元着色器可能会调用数千次，所以[[stage_in]]限定符是用来取的每个fragment数据")]),e._v(" "),a("li",[e._v("fragment中的的vert是在光栅化阶段构造。光栅化决定了哪些像素被我们绘制的三角形覆盖，同时采用顶点之间插值的方式生成新的vert，以传递给片元着色器。")])]),e._v(" "),a("h2",{attrs:{id:"mtlrenderpipelinestate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mtlrenderpipelinestate"}},[e._v("#")]),e._v(" MTLRenderPipelineState")]),e._v(" "),a("p",[e._v("渲染管线状态对象，封装了已经编译和链接的着色器程序（顶点着色器、片元着色器等），开销比较大，所以我们应该仅仅只为着色程序创建一个管线状态对象。")]),e._v(" "),a("h2",{attrs:{id:"mtlrenderpipelinedescriptor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mtlrenderpipelinedescriptor"}},[e._v("#")]),e._v(" MTLRenderPipelineDescriptor")]),e._v(" "),a("p",[e._v("渲染管线描述符，用来配置顶点函数、片元函数等")]),e._v(" "),a("h3",{attrs:{id:"vertexfunction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vertexfunction"}},[e._v("#")]),e._v(" vertexFunction")]),e._v(" "),a("h3",{attrs:{id:"fragmentfunction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fragmentfunction"}},[e._v("#")]),e._v(" fragmentFunction")]),e._v(" "),a("h3",{attrs:{id:"colorattachments-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#colorattachments-0"}},[e._v("#")]),e._v(" colorAttachments[0]")]),e._v(" "),a("p",[e._v("颜色附件0通常用作渲染到屏幕的帧缓冲区，所以layer的pixelFormat和colorAttachments[0]的pixelFormat")]),e._v(" "),a("h2",{attrs:{id:"流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[e._v("#")]),e._v(" 流程")]),e._v(" "),a("h3",{attrs:{id:"创建device添加到layer当中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建device添加到layer当中"}},[e._v("#")]),e._v(" 创建device添加到layer当中")]),e._v(" "),a("h3",{attrs:{id:"通过device创建position和color的mtlbuffer-后面添加到commandencoder当中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过device创建position和color的mtlbuffer-后面添加到commandencoder当中"}},[e._v("#")]),e._v(" 通过device创建position和color的MTLBuffer，后面添加到commandEncoder当中")]),e._v(" "),a("h3",{attrs:{id:"通过device创建commandqueue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过device创建commandqueue"}},[e._v("#")]),e._v(" 通过device创建commandQueue")]),e._v(" "),a("h3",{attrs:{id:"通过commandqueue创建commandbuffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过commandqueue创建commandbuffer"}},[e._v("#")]),e._v(" 通过commandQueue创建commandBuffer")]),e._v(" "),a("h3",{attrs:{id:"创建renderpassdescriptor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建renderpassdescriptor"}},[e._v("#")]),e._v(" 创建renderpassDescriptor")]),e._v(" "),a("h3",{attrs:{id:"通过commandbuffer和renderpassdescriptor创建commandencoder"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过commandbuffer和renderpassdescriptor创建commandencoder"}},[e._v("#")]),e._v(" 通过commandBuffer和renderpassDescriptor创建commandEncoder")]),e._v(" "),a("h3",{attrs:{id:"为commandencoder配置mtlbuffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为commandencoder配置mtlbuffer"}},[e._v("#")]),e._v(" 为commandEncoder配置MTLBuffer")]),e._v(" "),a("h3",{attrs:{id:"commandbuffer-commit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commandbuffer-commit"}},[e._v("#")]),e._v(" commandBuffer.commit")]),e._v(" "),a("h3",{attrs:{id:"通过device创建library-通过library创建着色函数-着色器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过device创建library-通过library创建着色函数-着色器"}},[e._v("#")]),e._v(" 通过device创建library，通过library创建着色函数（着色器）")]),e._v(" "),a("h3",{attrs:{id:"创建管线描述符renderpipelinedescriptor-并将着色函数运用于管线描述符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建管线描述符renderpipelinedescriptor-并将着色函数运用于管线描述符"}},[e._v("#")]),e._v(" 创建管线描述符renderpipelineDescriptor，并将着色函数运用于管线描述符")]),e._v(" "),a("h3",{attrs:{id:"通过device和管线描述符创建mtlrenderpipelinestate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过device和管线描述符创建mtlrenderpipelinestate"}},[e._v("#")]),e._v(" 通过device和管线描述符创建MTLRenderPipelineState")]),e._v(" "),a("h3",{attrs:{id:"将piplinestate运用于commandencoder"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#将piplinestate运用于commandencoder"}},[e._v("#")]),e._v(" 将piplineState运用于commandEncoder")]),e._v(" "),a("h2",{attrs:{id:"mtllibrary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mtllibrary"}},[e._v("#")]),e._v(" MTLLibrary")]),e._v(" "),a("p",[e._v("运用于着色程序的库")]),e._v(" "),a("h2",{attrs:{id:"opengl的原点在左下角-而metal的原点在左上角"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#opengl的原点在左下角-而metal的原点在左上角"}},[e._v("#")]),e._v(" OpenGL的原点在左下角，而Metal的原点在左上角")]),e._v(" "),a("p",[a("em",[e._v("XMind - Trial Version")])])])}),[],!1,null,null,null);r.default=s.exports}}]);