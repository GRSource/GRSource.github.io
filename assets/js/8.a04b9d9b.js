(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{430:function(o,n,e){o.exports=e.p+"assets/img/RunLoop包含关系.33173292.png"},431:function(o,n,e){o.exports=e.p+"assets/img/CFRunLoop.9ac45099.png"},432:function(o,n,e){o.exports=e.p+"assets/img/CFRunLoopMode.2bd157f7.png"},433:function(o,n,e){o.exports=e.p+"assets/img/CFRunLoopSource.d06ce1ee.png"},434:function(o,n,e){o.exports=e.p+"assets/img/source0.d7c1f84c.png"},435:function(o,n,e){o.exports=e.p+"assets/img/source1.b412af4a.png"},436:function(o,n,e){o.exports=e.p+"assets/img/CFRunLoopTimer.0efb1922.png"},437:function(o,n,e){o.exports=e.p+"assets/img/CFRunLoopObserver.2429eb8e.png"},438:function(o,n,e){o.exports=e.p+"assets/img/CF_OPTIONS.bb477846.png"},439:function(o,n,e){o.exports=e.p+"assets/img/RunLoop执行过程.7aab9f00.png"},440:function(o,n,e){o.exports=e.p+"assets/img/CFRunLoopGetCurrent.45f232e7.png"},441:function(o,n,e){o.exports=e.p+"assets/img/CFRunLoopGetMain.87da6143.png"},442:function(o,n,e){o.exports=e.p+"assets/img/RunLoop执行2.82ea1f00.png"},443:function(o,n,e){o.exports=e.p+"assets/img/常驻线程代码.6f4b389e.png"},558:function(o,n,e){"use strict";e.r(n);var t=e(65),s=Object(t.a)({},(function(){var o=this,n=o.$createElement,t=o._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[t("h1",{attrs:{id:"runloop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runloop"}},[o._v("#")]),o._v(" RunLoop")]),o._v(" "),t("h2",{attrs:{id:"runloop本质"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runloop本质"}},[o._v("#")]),o._v(" RunLoop本质")]),o._v(" "),t("p",[o._v("什么是RunLoop?"),t("br"),o._v("\nRunLoop是通过内部维护的事件循环来对事件/消息进行管理的一个对象。"),t("br"),o._v("\n事件循环：")]),o._v(" "),t("ul",[t("li",[o._v("没有消息需要处理时，休眠以避免资源占用")]),o._v(" "),t("li",[o._v("有消息需要处理时，立刻被唤醒")])]),o._v(" "),t("p",[o._v("为了系统安全，有些指令只能通过系统来调用，有些指令通过用户来调用，所以就区分出了内核态和用户态。"),t("br"),o._v("\n当一个进程在执行用户自己的代码时处于用户态，此时特权级最低，为Ring3，当一个进程因为系统调用陷入内核代码中执行时处于内核态，此时特权级最高Ring0，执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈，内核态的进程执行完后又会切换到Ring3，回到用户态。")]),o._v(" "),t("p",[o._v("用户态切换到内核态的3种方式：")]),o._v(" "),t("ul",[t("li",[o._v("系统调用，比如文件读写、网络数据请求")]),o._v(" "),t("li",[o._v("异常，当cpu在执行用户态下的程序时，发生了一些不可预知的异常，这是会触发进入处理异常的内核相关进程中，也就切换到了内核态。")]),o._v(" "),t("li",[o._v("外围设备的中断，当外围设备发出中断请求信号后，cpu会转到处理中断信号的内核态。")])]),o._v(" "),t("p",[o._v("问1：什么是事件循环？"),t("br"),o._v("\n事件循环可以用来不断处理消息，对他们进行管理，同时当没有消息需要处理时，会从用户态到内核态的切换，由此可以用来进行当前线程的休眠，避免资源占用。当有消息需要处理时，会从内核态切换到用户态，唤醒当前线程。"),t("br"),o._v("\n问2：main函数为什么能一直保持运行而不退出？"),t("br"),o._v("\n在main函数中调用的UIApplication会启动主线程的runloop，而runloop是对事件循环的维护机制，可以做到在有事做的时候做事，没事做的时候会发生用户态到内核态的切换，避免资源的占用，当前线程处于休眠状态。")]),o._v(" "),t("h2",{attrs:{id:"runloop数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runloop数据结构"}},[o._v("#")]),o._v(" RunLoop数据结构")]),o._v(" "),t("p",[o._v("NSRunLoop是对CFRunLoop的封装，提供了面向对象的API，NSRunLoop位于Foundation中，CFRunLoop位于CoreFoundation，我们主要来分析CFRunLoop。")]),o._v(" "),t("p",[o._v("RunLoop的运行模式：")]),o._v(" "),t("ul",[t("li",[o._v("KCFRunLoopDefaultMode，App的默认运行模式，通常主线程是在这个运行模式下运行")]),o._v(" "),t("li",[o._v("UITrackingRunLoopMode，跟踪用户交互事件（用于ScrollView追踪触摸滑动，保证界面滑动时不受其他mode影响）")]),o._v(" "),t("li",[o._v("KCFRunLoopCommonModes，伪模式，不是一种真正的运行模式")]),o._v(" "),t("li",[o._v("UIInitializationRunLoopMode，在刚启动App时进入的第一个Mode，启动完成后就不再使用")]),o._v(" "),t("li",[o._v("GSEventReceiveRunLoopMode，接受系统内部事件，通常用不到")])]),o._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[o._v("WARNING")]),o._v(" "),t("ul",[t("li",[o._v("RunLoop只会运行在一个模式下")]),o._v(" "),t("li",[o._v("要切换模式，就要暂停当前模式，重新启动一个运行模式")])])]),o._v(" "),t("p",[o._v("RunLoop主要有三种数据结构：")]),o._v(" "),t("ul",[t("li",[o._v("CFRunLoop")]),o._v(" "),t("li",[o._v("CFRunLoopMode")]),o._v(" "),t("li",[o._v("Source/Timer/Observer")])]),o._v(" "),t("h3",{attrs:{id:"cfrunloop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cfrunloop"}},[o._v("#")]),o._v(" CFRunLoop")]),o._v(" "),t("p",[o._v("主要包含：pthread、currentMode、modes、commonModes、commonModeItems\n"),t("img",{attrs:{src:e(430),alt:"RunLoop包含关系"}}),o._v(" "),t("img",{attrs:{src:e(431),alt:"CFRunLoop"}}),o._v("\n从上面可以看出一个RunLoop包含一个线程，也就是和线程是一一对应的；以及若干个Mode、若干个commonModeItem，还有一个当前运行的CurrentMode。如果在RunLoop中需要切换Mode，只能退出Loop，再重新指定一个Mode进入。这样做主要是为了分隔开不同组的Source/Timer/Observer，让其互不影响。")]),o._v(" "),t("h3",{attrs:{id:"cfrunloopmode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cfrunloopmode"}},[o._v("#")]),o._v(" CFRunLoopMode")]),o._v(" "),t("p",[o._v("主要包含：name、sources0、source1、observers、timers\n"),t("img",{attrs:{src:e(432),alt:"CFRunLoopMode"}}),o._v("\n从上可以看出一个CFRunLoopMode对象有一个name，若干source0、source1、timer、observer和若干port，其中source，timer，observer数据结果被统称为mode item。上面提到的那几种mode（UITrackingRunLoopMode、GSEventReceiveRunLoopMode、kCFRunLoopDefaultMode、kCFRunLoopCommonMode），其实就是这里的name。")]),o._v(" "),t("p",[o._v("只能通过mode的name字段(也就是字符串)操作内部的Mode，当你传入一个新的mode name但RunLoop内部没有对应mode时，RunLoop会自动帮你创建对应的CFRunLoopModeRef。对于一个RunLoop来说，其内部的mode只能增加不能删除。")]),o._v(" "),t("p",[o._v("source、timer、observer可以再多个mode中注册，但是只有runloop当前的currentMode下的source、timer、observer才可以运行。")]),o._v(" "),t("p",[o._v("Model暴露给外面管理Mode Item的接口：")]),o._v(" "),t("div",{staticClass:"language-C extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[o._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopAddSource")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFRunLoopSourceRef source"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFStringRef modeName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(";")]),o._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopAddObserver")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFRunLoopObserverRef observer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFStringRef modeName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(";")]),o._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopAddTimer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFRunLoopTimerRef timer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFStringRef mode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(";")]),o._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopRemoveSource")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFRunLoopSourceRef source"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFStringRef modeName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(";")]),o._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopRemoveObserver")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFRunLoopObserverRef observer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFStringRef modeName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(";")]),o._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopRemoveTimer")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFRunLoopTimerRef timer"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFStringRef mode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(";")]),o._v("\n\n")])])]),t("p",[o._v("CFRunLoopSource：\n"),t("img",{attrs:{src:e(433),alt:"CFRunLoopSource"}}),o._v("\n__CFRunLoopSource是事件产生的地方。Source有两个版本：Source0和Source1。")]),o._v(" "),t("ul",[t("li",[o._v("source0只包含了一个回调（函数指针），source0是需要手动触发的Source，"),t("strong",[o._v("它并不能主动触发事件，必须要先把它标记为Signal状态。使用时，你需要先调用CFRunLoopSourceSignal(source)，将这个Source标记为待处理，也就是通过uint32_t _bits来实现的")]),o._v("，只有_bits标记为Signaled状态才会被处理。然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件。")]),o._v(" "),t("li",[o._v("source1包含了一个mach_port和一个回调（函数指针），"),t("strong",[o._v("被用于通过内核和其他线程互相发送消息。这种Source能主动唤醒RunLoop的线程")]),o._v("。简单来说就更加偏向于底层。")])]),o._v(" "),t("p",[o._v("source0：\n"),t("img",{attrs:{src:e(434),alt:"source0"}}),o._v("\nsource1：\n"),t("img",{attrs:{src:e(435),alt:"source1"}}),o._v("\nsource1除了多个了getPort。其余的字段含义和source0相同。作用就是当source被添加到mode中的时候，从这个函数中获得具体mach_port_t。")]),o._v(" "),t("p",[o._v("CFRunLoopTimer：\n"),t("img",{attrs:{src:e(436),alt:"CFRunLoopTimer"}}),o._v("\n它和NSTimer是toll-free bridged的("),t("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677",target:"_blank",rel:"noopener noreferrer"}},[o._v("资料可以看这里"),t("OutboundLink")],1),o._v(")，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。根据上面的分析一个timer可能会在多个mode中存在。")]),o._v(" "),t("p",[o._v("CFRunLoopObserver：\n"),t("img",{attrs:{src:e(437),alt:"CFRunLoopObserver"}}),o._v("\nCFRunLoopObserver是观察者，可以观察RunLoop的各种状态，每个Observer都包含了一个回调（也就是上面的CFRunLoopObserverCallBack函数指针），当RunLoop状态发生变化时，观察者就能通过回调接收到这个变化。状态定义在_CF_OPTIONS：\n"),t("img",{attrs:{src:e(438),alt:"CF_OPTIONS"}}),o._v("\n观察对象为：")]),o._v(" "),t("ul",[t("li",[o._v("KCFRunLoopEntry，即将进入runloop")]),o._v(" "),t("li",[o._v("KCFRunLoopBeforeTimers，即将处理timer")]),o._v(" "),t("li",[o._v("KCFRunLoopBeforeSources，即将处理source")]),o._v(" "),t("li",[o._v("KCFRunLoopBeforeWaiting，即将进入休眠")]),o._v(" "),t("li",[o._v("KCFRunLoopAfterWaiting，被唤醒但是还没处理事件")]),o._v(" "),t("li",[o._v("KCFRunLoopExit，runloop已经退出")]),o._v(" "),t("li",[o._v("KCFRunLoopAllActivities")])]),o._v(" "),t("h3",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[o._v("#")]),o._v(" 小结")]),o._v(" "),t("p",[o._v("根据上面的数据结构，总结出如下内容。")]),o._v(" "),t("p",[o._v("一个mode中有多个item，这些item由source、observe、timer组成。对于我们来讲用的最多的应该是observer和timer，常常通过回调来得知当前runloop的状态，进行来优化应用程序（比如监控在waiting状态下，这个时候做一些优化的事情）。其次设置定时器执行定时任务也是很常见的。")]),o._v(" "),t("p",[o._v("一个runloop包含多个mode，但是runloop在一个时间点只会处于一种mode（KCFRunLoopDefaultMode、UITrackingRunLoopMode、）状态下也即是currentMode，如果该当前应用状态在另一种mode下，则该mode下的item（source、observer、timer）就不会工作。")]),o._v(" "),t("p",[o._v('runloop其中有一个commonModes的数组，里面保存的是被标记为common的mode，这种标记为common的mode有种特性，那就是当RunLoop的内容发生变化时，RunLoop都会自动将commonModeItems里的Source/Observer/Timer同步到具有"Common"标记的所有所有Mode里。可以这样理解，runloop中的_commonModeItems由被标记为common的mode下的各个item(source、observer、timer)组成。')]),o._v(" "),t("p",[o._v("Runloop初始化的时候的会把名字为kCFRunLoopDefaultMode、UITrackingRunLoopMode的model加入到common modesls数组里面，标记为common mode。")]),o._v(" "),t("h2",{attrs:{id:"runloop执行过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runloop执行过程"}},[o._v("#")]),o._v(" RunLoop执行过程")]),o._v(" "),t("p",[t("img",{attrs:{src:e(439),alt:"RunLoop执行过程"}})]),o._v(" "),t("ul",[t("li",[o._v("如果指定了一个不存在的mode来运行RunLoop，那么会失败，mode不会被创建，所以这里传入的mode必须是存在的。")]),o._v(" "),t("li",[o._v("如果指定了一个mode，但是这个mode中不包含任何modeItem，那么RunLoop也不会运行，所以必须传入至少包含一个modeItem的mode")]),o._v(" "),t("li",[o._v("在进入runloop之后通知observer，状态为kCFRunLoopEntry")]),o._v(" "),t("li",[o._v("在退出runloop之后通知observer，状态为kCFRunLoopExit")]),o._v(" "),t("li",[o._v("CFRunLoopRun有五个参数：")])]),o._v(" "),t("div",{staticClass:"language-C extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[o._v("/**\n *  运行run loop\n *\n *  @param rl              运行的RunLoop对象\n *  @param rlm             运行的mode\n *  @param seconds         run loop超时时间\n *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止\n *  @param previousMode    上一次运行的mode\n *\n *  @return 返回4种状态\n */")]),o._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[o._v("static")]),o._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[o._v("int32_t")]),o._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("__CFRunLoopRun")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFRunLoopModeRef rlm"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFTimeInterval seconds"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" Boolean stopAfterHandle"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFRunLoopModeRef previousMode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),o._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("{")]),o._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(".")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(".")]),o._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("}")]),o._v("\n")])])]),t("p",[o._v("CFRunLoop是基于pthread来管理的。iOS中不能直接创建RunLoop，只能从系统中获取CFRunLoopGetMain()和CFRunLoopGetCurrent()。")]),o._v(" "),t("div",{staticClass:"language-C extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[o._v("CFRunLoopRef "),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopGetCurrent")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[o._v("void")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[o._v("//获取当前线程的RunLoop对象")]),o._v("\nCFRunLoopRef "),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopGetMain")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[o._v("void")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(";")]),t("span",{pre:!0,attrs:{class:"token comment"}},[o._v("//获取主线程的RunLoop对象")]),o._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[o._v("+")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("NSRunLoop "),t("span",{pre:!0,attrs:{class:"token operator"}},[o._v("*")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),o._v("currentRunLoop\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[o._v("+")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("NSRunLoop "),t("span",{pre:!0,attrs:{class:"token operator"}},[o._v("*")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),o._v("mainRunLoop\n")])])]),t("p",[o._v("获取当前线程RunLoop:\n"),t("img",{attrs:{src:e(440),alt:"CFRunLoopGetCurrent"}}),o._v("\n在CFRunLoopGetCurrent函数内部调用了_CFRunLoopGet0(),传入的参数是当前线程，这里可以看出CFRunLoopGetCurrent函数必须要在线程内部调用，才能获取当前线程的RunLoop。也就是说子线程的RunLoop必须要在子线程内部获取。")]),o._v(" "),t("p",[o._v("获取主线程RunLoop:\n"),t("img",{attrs:{src:e(441),alt:"CFRunLoopGetMain"}}),o._v("\n在CFRunLoopGetMain函数内部也调用了_CFRunLoopGet0(),传入的参数是主线程。可以看出，CFRunLoopGetMain()不管在主线程还是子线程中调用，都可以获取到主线程的RunLoop。")]),o._v(" "),t("ul",[t("li",[o._v("线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary中。")]),o._v(" "),t("li",[o._v("线程刚创建时并没有RunLoop（没有加到对应的runloop字典中），如果你不主动获取，那么它一直都不会有")]),o._v(" "),t("li",[o._v("RunLoop的创建是发生在第一次获取时。一般是获取主线程的时候。")]),o._v(" "),t("li",[o._v("RunLoop的销毁是发生在线程结束时。")]),o._v(" "),t("li",[o._v("只能在一个线程的内部获取其RunLoop（主线程除外），否则这个Runloop就没有注册销毁回调。因为上面讲过Runlopp暴露给外部的创建方式只有CFRunLoopGetMain() 和 CFRunLoopGetCurrent()两种，所以这种情况不用考虑。")])]),o._v(" "),t("div",{staticClass:"language-C extra-class"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopAddCommonMode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(",")]),o._v(" CFStringRef mode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token comment"}},[o._v("//向当前RunLoop的common modes中添加一个mode。")]),o._v("\nCFStringRef "),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopCopyCurrentMode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token comment"}},[o._v("//返回当前运行的mode的name")]),o._v("\nCFArrayRef "),t("span",{pre:!0,attrs:{class:"token function"}},[o._v("CFRunLoopCopyAllModes")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v("(")]),o._v("CFRunLoopRef rl"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[o._v(")")]),t("span",{pre:!0,attrs:{class:"token comment"}},[o._v("//返回当前RunLoop的所有mode")]),o._v("\n")])])]),t("p",[o._v("我们没有办法直接创建一个CFRunLoopMode对象，但是我们可以调用CFRunLoopAddCommonMode传入一个字符串向RunLoop中添加Mode，传入的字符串即为Mode的名字，Mode对象应该是此时在RunLoop内部创建的。"),t("strong",[o._v("特别注意只能通过CFRunLoopAddCommonMode，是CommonMode")]),o._v("。")]),o._v(" "),t("ul",[t("li",[o._v("modeName不能重复，modeName是mode的唯一标识符")]),o._v(" "),t("li",[o._v("添加commonMode会把commonModeItems数组中的所有item(source,observer,time)同步到新添加的mode中。")])]),o._v(" "),t("p",[t("strong",[o._v("observer和timer只能被添加到一个RunLoop的一个或者多个mode中，比如一个timer被添加到主线程的RunLoop中，则不能再把该timer添加到子线程的RunLoop，而source没有这个限制，不管是哪个RunLoop，只要mode中没有，就可以添加。")])]),o._v(" "),t("h3",{attrs:{id:"block"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#block"}},[o._v("#")]),o._v(" Block")]),o._v(" "),t("ul",[t("li",[o._v("block其实在runloop中通过循环链表保存的")]),o._v(" "),t("li",[o._v("如果block可以加入到多个mode下面，但是执行block只有在加入的那个mode下才能执行，或者加入mode用common标记")]),o._v(" "),t("li",[o._v("每次调用_CFRunLoopDoBlocks，会把加入的block遍历执行，然后重置循环链表")])]),o._v(" "),t("h3",{attrs:{id:"autoreleasepool"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepool"}},[o._v("#")]),o._v(" AutoreleasePool")]),o._v(" "),t("p",[o._v("App启动后，苹果在主线程RunLoop里注册了两个Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。")]),o._v(" "),t("p",[o._v("第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。")]),o._v(" "),t("p",[o._v("第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。")]),o._v(" "),t("h3",{attrs:{id:"其他使用案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他使用案例"}},[o._v("#")]),o._v(" 其他使用案例")]),o._v(" "),t("p",[o._v("RunLoop还在手势识别、界面更新(setNeedsLayout/setNeedsDisplay)、定时器、PerformSelctor(延迟执行)、GCD(回调主线程)、网络请求当中发挥了作用。详情参考"),t("a",{attrs:{href:"http://weslyxl.coding.me/2018/03/18/2018/3/RunLoop%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%BA%94%E7%94%A8%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/",target:"_blank",rel:"noopener noreferrer"}},[o._v("这里"),t("OutboundLink")],1)]),o._v(" "),t("h2",{attrs:{id:"runloop事件循环机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runloop事件循环机制"}},[o._v("#")]),o._v(" RunLoop事件循环机制")]),o._v(" "),t("p",[t("img",{attrs:{src:e(442),alt:"RunLoop执行2"}})]),o._v(" "),t("h2",{attrs:{id:"runloop与多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runloop与多线程"}},[o._v("#")]),o._v(" RunLoop与多线程")]),o._v(" "),t("p",[o._v("线程时和RunLoop一一对应的。"),t("br"),o._v("\n自己创建的线程默认是没有RunLoop的。")]),o._v(" "),t("p",[o._v("怎样实现一个常驻线程呢？")]),o._v(" "),t("ol",[t("li",[o._v("为当前线程开启一个RunLoop。")]),o._v(" "),t("li",[o._v("向该RunLoop中添加一个Port/Source等维持RunLoop的事件循环。")]),o._v(" "),t("li",[o._v("启动该RunLoop。")])]),o._v(" "),t("p",[t("img",{attrs:{src:e(443),alt:"常驻线程代码"}})]),o._v(" "),t("p",[o._v("什么是RunLoop，它是怎样做到有事做事，没事休息的？")]),o._v(" "),t("ol",[t("li",[o._v("RunLoop是一个事件循环用已处理我们的事件和消息以及对他们的管理。")]),o._v(" "),t("li",[o._v("是调用CFRunLoopRun之后，会调用系统的mach_msg，同时发生了用户态到内核态的切换，当前线程处于休眠状态，所以做到了有事做事，没事休息。")])]),o._v(" "),t("p",[o._v("RunLoop与线程是怎样的关系？")]),o._v(" "),t("ol",[t("li",[o._v("RunLoop与线程一一对应的关系")]),o._v(" "),t("li",[o._v("子线程默认是没有RunLoop的，我们需要手动创建")])]),o._v(" "),t("p",[o._v("如何退出一个RunLoop？")]),o._v(" "),t("p",[o._v("如果不想退出runloop可以使用run方式启动runloop；如果使用runUntilDate方式启动runloop，可以通过设置超时时间来退出；如果使用runMode：beforeDate方式启动runloop，可以通过设置超时时间或者使用CFRunLoopStop方法来退出。")]),o._v(" "),t("p",[o._v("怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作？")])])}),[],!1,null,null,null);n.default=s.exports}}]);