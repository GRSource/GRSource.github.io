(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{599:function(a,e,r){"use strict";r.r(e);var t=r(65),_=Object(t.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"runloop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#runloop"}},[a._v("#")]),a._v(" RunLoop")]),a._v(" "),r("h2",{attrs:{id:"线程一一对应"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程一一对应"}},[a._v("#")]),a._v(" 线程一一对应")]),a._v(" "),r("h2",{attrs:{id:"mode-item"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mode-item"}},[a._v("#")]),a._v(" Mode Item")]),a._v(" "),r("h3",{attrs:{id:"主要使用的有三类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主要使用的有三类"}},[a._v("#")]),a._v(" 主要使用的有三类")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("Source")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("Source0")]),a._v(" "),r("p",[a._v("不能主动触发")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("只包含回调的函数指针，需要手动触发")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("CFRunLoopSourceSignal(source)")]),a._v(" "),r("p",[a._v("标记为待处理")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("CFRunLoopWakeUp(runloop)")]),a._v(" "),r("p",[a._v("唤醒runloop，来处理事件")])])])])])])])]),a._v(" "),r("li",[r("p",[a._v("Source1")]),a._v(" "),r("p",[a._v("可以主动触发(即主动唤醒runloop的线程)，用于内核和其他线程相互发送消息")]),a._v(" "),r("ul",[r("li",[a._v("包含mach_port")]),a._v(" "),r("li",[a._v("包含回调指针")])])])])]),a._v(" "),r("li",[r("p",[a._v("Timer")]),a._v(" "),r("ul",[r("li",[a._v("包含时间长度")]),a._v(" "),r("li",[a._v("包含回调指针")])])]),a._v(" "),r("li",[r("p",[a._v("Observer")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("包含回调指针，观测点为：")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("entry")]),a._v(" "),r("p",[a._v("即将进入loop")])]),a._v(" "),r("li",[r("p",[a._v("beforeTimers")]),a._v(" "),r("p",[a._v("即将处理Timer")])]),a._v(" "),r("li",[r("p",[a._v("beforeSources")]),a._v(" "),r("p",[a._v("即将处理Source")])]),a._v(" "),r("li",[r("p",[a._v("beforeWaiting")]),a._v(" "),r("p",[a._v("即将进入休眠")])]),a._v(" "),r("li",[r("p",[a._v("AfterWaiting")]),a._v(" "),r("p",[a._v("刚从休眠中唤醒")])]),a._v(" "),r("li",[r("p",[a._v("Exit")]),a._v(" "),r("p",[a._v("即将推出loop")])])])])])])]),a._v(" "),r("h2",{attrs:{id:"系统架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#系统架构"}},[a._v("#")]),a._v(" 系统架构")]),a._v(" "),r("h3",{attrs:{id:"应用层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#应用层"}},[a._v("#")]),a._v(" 应用层")]),a._v(" "),r("ul",[r("li",[a._v("用户解除到的图形应用")])]),a._v(" "),r("h3",{attrs:{id:"应用框架层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#应用框架层"}},[a._v("#")]),a._v(" 应用框架层")]),a._v(" "),r("ul",[r("li",[a._v("包含Cocoa等框架")])]),a._v(" "),r("h3",{attrs:{id:"核心框架层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#核心框架层"}},[a._v("#")]),a._v(" 核心框架层")]),a._v(" "),r("ul",[r("li",[a._v("包含核心框架、OpenGL等")])]),a._v(" "),r("h3",{attrs:{id:"darwin"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#darwin"}},[a._v("#")]),a._v(" Darwin")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("包含系统内核、驱动、Shell等")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("XNU内核")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("IOKit")])]),a._v(" "),r("li",[r("p",[a._v("BSD")]),a._v(" "),r("ul",[r("li",[a._v("提供了诸如进程管理、文件系统和网络等功能")])])]),a._v(" "),r("li",[r("p",[a._v("Mach")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("提供了诸如处理器调度、iPC(进程间通信)等服务，通过消息传递的方式实现对象间通信。")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("Mach消息组成：")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("mach_msg_base_t")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("header")]),a._v(" "),r("ul",[r("li",[a._v("msgh_bits")]),a._v(" "),r("li",[a._v("msgh_size")]),a._v(" "),r("li",[a._v("msgh_remote_port")]),a._v(" "),r("li",[a._v("msgh_local_port")]),a._v(" "),r("li",[a._v("msgh_voucher_port")]),a._v(" "),r("li",[a._v("msgh_id")])])]),a._v(" "),r("li",[r("p",[a._v("body")])])])])])]),a._v(" "),r("li",[r("p",[a._v("通过mach_msg来发送和接收消息")]),a._v(" "),r("ul",[r("li",[a._v("调用mach_msg_trap(系统调用)，进入内核态")])])])])])])])])])])])]),a._v(" "),r("h2",{attrs:{id:"用户态进入内核态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用户态进入内核态"}},[a._v("#")]),a._v(" 用户态进入内核态")]),a._v(" "),r("h3",{attrs:{id:"程序异常"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#程序异常"}},[a._v("#")]),a._v(" 程序异常")]),a._v(" "),r("h3",{attrs:{id:"发生系统调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发生系统调用"}},[a._v("#")]),a._v(" 发生系统调用")]),a._v(" "),r("h3",{attrs:{id:"外围设备的中断"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#外围设备的中断"}},[a._v("#")]),a._v(" 外围设备的中断")]),a._v(" "),r("h2",{attrs:{id:"核心"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#核心"}},[a._v("#")]),a._v(" 核心")]),a._v(" "),r("h3",{attrs:{id:"mach-msg"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mach-msg"}},[a._v("#")]),a._v(" mach_msg()")]),a._v(" "),r("p",[a._v("mach_msg()既可以用来接收消息，又可以用来发送消息")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("接收消息")]),a._v(" "),r("p",[a._v("runloop通过这个函数去接收消息，如果没有别人发送port消息过来，内核就会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。")])]),a._v(" "),r("li",[r("p",[a._v("发送消息")])])]),a._v(" "),r("h2",{attrs:{id:"mode"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mode"}},[a._v("#")]),a._v(" Mode")]),a._v(" "),r("h3",{attrs:{id:"default"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#default"}},[a._v("#")]),a._v(" default")]),a._v(" "),r("h3",{attrs:{id:"tracking"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tracking"}},[a._v("#")]),a._v(" tracking")]),a._v(" "),r("h3",{attrs:{id:"initialization"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#initialization"}},[a._v("#")]),a._v(" initialization")]),a._v(" "),r("p",[a._v("启动时进入的第一个Mode，启动完成后不再使用")]),a._v(" "),r("h3",{attrs:{id:"receive"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#receive"}},[a._v("#")]),a._v(" receive")]),a._v(" "),r("p",[a._v("接收系统事件的内部Mode")]),a._v(" "),r("h3",{attrs:{id:"commonmodes"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#commonmodes"}},[a._v("#")]),a._v(" commonModes")]),a._v(" "),r("h2",{attrs:{id:"app启动-注册两个observer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#app启动-注册两个observer"}},[a._v("#")]),a._v(" App启动，注册两个Observer")]),a._v(" "),r("p",[a._v("主线程中，通常在事件回调、Timer回调会被AutoreleasePool环绕，所以不会出现内存泄漏")]),a._v(" "),r("h3",{attrs:{id:"observer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#observer"}},[a._v("#")]),a._v(" Observer")]),a._v(" "),r("p",[a._v("优先级最高\n回调函数_wrapRunLoopWithAutoreleasePoolHandler()")]),a._v(" "),r("ul",[r("li",[a._v("监听Entry事件，在回调内调用_objc_autoreleasePoolPush()创建自动释放池")])]),a._v(" "),r("h3",{attrs:{id:"observer-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#observer-2"}},[a._v("#")]),a._v(" Observer")]),a._v(" "),r("p",[a._v("回调函数_wrapRunLoopWithAutoreleasePoolHandler()")]),a._v(" "),r("ul",[r("li",[a._v("监听BeforeWaiting，在回调内调用pop()和push，释放旧的池并创建新池")]),a._v(" "),r("li",[a._v("监听Exit，调用pop释放自动释放池")])]),a._v(" "),r("h2",{attrs:{id:"系统"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#系统"}},[a._v("#")]),a._v(" 系统")]),a._v(" "),r("h3",{attrs:{id:"苹果有注册一个source1用来接收系统事件-如触摸、锁屏、摇晃等-无回调指针"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#苹果有注册一个source1用来接收系统事件-如触摸、锁屏、摇晃等-无回调指针"}},[a._v("#")]),a._v(" 苹果有注册一个Source1用来接收系统事件，如触摸、锁屏、摇晃等，无回调指针")]),a._v(" "),r("p",[a._v("我们知道，Source1主要是用来内核和线程间通信的，回调函数__IOHIDEventSystemClientQueueCallback()")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("触摸、锁屏、摇晃等")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("触发IOKit.framework")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("生成IOHIDEvent事件")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("SpringBoard接收")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("用mach port转发给需要的App进程")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("系统Source1的回调来触发_UIApplicationHandleEventQueue（）")]),a._v(" "),r("ul",[r("li",[a._v("_UIApplicationHandleEventQueue()将Event包装成UIEvent进行分发，随后系统将事件标记为待处理")])])])])])])])])])])])])])]),a._v(" "),r("h3",{attrs:{id:"苹果启动时有注册一个observer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#苹果启动时有注册一个observer"}},[a._v("#")]),a._v(" 苹果启动时有注册一个Observer")]),a._v(" "),r("ul",[r("li",[a._v("检测到BeforeWaiting时，触发回调函数来处理被标记为待处理的事件，例如手势事件、界面刷新等")])]),a._v(" "),r("h2",{attrs:{id:"runloop启动前必须至少有一个timer-observer-source"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#runloop启动前必须至少有一个timer-observer-source"}},[a._v("#")]),a._v(" runloop启动前必须至少有一个Timer/Observer/Source")]),a._v(" "),r("h2",{attrs:{id:"autoreleasepool"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepool"}},[a._v("#")]),a._v(" AutoreleasePool")]),a._v(" "),r("h3",{attrs:{id:"主线程创建的对象-没有必要-显示-使用-autoreleasepool-因为应用在启动的时候系统已经为我们主动创建了"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主线程创建的对象-没有必要-显示-使用-autoreleasepool-因为应用在启动的时候系统已经为我们主动创建了"}},[a._v("#")]),a._v(" 主线程创建的对象，没有必要“显示”使用@autoreleasePool，因为应用在启动的时候系统已经为我们主动创建了")]),a._v(" "),r("h3",{attrs:{id:"子线程创建的对象-如果线程暂时不会退出-我们在创建对象的时候必须使用-autoreleasepool-以避免内存达到峰值-因为使用-autoreleasepool之后-对象会被打一个标记-在runloop进入休眠时-会释放-autoreleasepool中的对象-然后创建新池。如果线程执行完就退出-我们没有必要使用autoreleasepool-此时起不到任何作用-线程不会进入休眠-我们的对象会在线程结束时-全部释放掉。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#子线程创建的对象-如果线程暂时不会退出-我们在创建对象的时候必须使用-autoreleasepool-以避免内存达到峰值-因为使用-autoreleasepool之后-对象会被打一个标记-在runloop进入休眠时-会释放-autoreleasepool中的对象-然后创建新池。如果线程执行完就退出-我们没有必要使用autoreleasepool-此时起不到任何作用-线程不会进入休眠-我们的对象会在线程结束时-全部释放掉。"}},[a._v("#")]),a._v(" 子线程创建的对象，如果线程暂时不会退出，我们在创建对象的时候必须使用@autoreleasePool，以避免内存达到峰值，因为使用@autoreleasePool之后，对象会被打一个标记，在runloop进入休眠时，会释放@autoreleasePool中的对象，然后创建新池。如果线程执行完就退出，我们没有必要使用autoreleasePool，此时起不到任何作用，线程不会进入休眠，我们的对象会在线程结束时，全部释放掉。")]),a._v(" "),r("p",[r("em",[a._v("XMind - Trial Version")])])])}),[],!1,null,null,null);e.default=_.exports}}]);