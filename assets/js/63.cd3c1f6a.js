(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{604:function(e,a,_){"use strict";_.r(a);var i=_(65),t=Object(i.a)({},(function(){var e=this,a=e.$createElement,_=e._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"ijkplayer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijkplayer"}},[e._v("#")]),e._v(" ijkPlayer")]),e._v(" "),_("p",[e._v("https://cloud.tencent.com/developer/article/1032547")]),e._v(" "),_("h2",{attrs:{id:"ijkavmovieplayercontroller"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijkavmovieplayercontroller"}},[e._v("#")]),e._v(" IJKAVMoviePlayerController")]),e._v(" "),_("h2",{attrs:{id:"ijkmpmovieplayercontroller"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijkmpmovieplayercontroller"}},[e._v("#")]),e._v(" IJKMPMoviePlayerController")]),e._v(" "),_("h2",{attrs:{id:"ijkffmovieplayercontroller"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijkffmovieplayercontroller"}},[e._v("#")]),e._v(" IJKFFMoviePlayerController")]),e._v(" "),_("h3",{attrs:{id:"ijkffoptions分为五类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijkffoptions分为五类"}},[e._v("#")]),e._v(" IJKFFOptions分为五类")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("kIJKFFOptionCategoryFormat")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("默认值为")]),e._v(" "),_("ul",[_("li",[e._v("auto_convert=0")]),e._v(" "),_("li",[e._v("reconnect=1")]),e._v(" "),_("li",[e._v("timeout=30 * 1000 * 1000")]),e._v(" "),_("li",[e._v('user-agent=@"ijkplayer"')])])])])]),e._v(" "),_("li",[_("p",[e._v("kIJKFFOptionCategoryCodec")])]),e._v(" "),_("li",[_("p",[e._v("kIJKFFOptionCategorySws")])]),e._v(" "),_("li",[_("p",[e._v("kIJKFFOptionCategoryPlayer")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("默认值为")]),e._v(" "),_("ul",[_("li",[e._v("max-fps=30")]),e._v(" "),_("li",[e._v("framedrop=0")]),e._v(" "),_("li",[e._v("video-pictq-size=3")]),e._v(" "),_("li",[e._v("videotoolbox=0")]),e._v(" "),_("li",[e._v("videotoolbox-max-frame-width=960")])])])])]),e._v(" "),_("li",[_("p",[e._v("kIJKFFOptionCategorySwr")])])]),e._v(" "),_("h3",{attrs:{id:"ijkmediaplayer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijkmediaplayer"}},[e._v("#")]),e._v(" IjkMediaPlayer")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("初始化流程")]),e._v(" "),_("p",[e._v("简单来说，就是创建播放器对象，完成音视频解码、渲染的准备工作")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("IjkMediaPlayer对象通过ijkplayer_ios.m类中的ijkmp_ios_create方法创建，同时做了三个动作")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("ijkmp_create创建IjkMediaPlayer")]),e._v(" "),_("ul",[_("li",[e._v("mallocz创建")]),e._v(" "),_("li",[e._v("通过ffp_create方法创建FFPlayer对象")]),e._v(" "),_("li",[e._v("设置消息处理函数msg_loop")])])]),e._v(" "),_("li",[_("p",[e._v("通过SDL_VoutIos_CreateForGLES2方法创建图像渲染对象SDL_Vout，存放到FFPlayer对象当中")])]),e._v(" "),_("li",[_("p",[e._v("通过ffpipeline_create_from_ios方法创建平台相关的IJKFF_Pipeline对象，包括视频解码以及音频输出部分，存放到FFPlayer对象当中")])])])])])]),e._v(" "),_("li",[_("p",[e._v("主要持有ffplayer和msg_loop，所以不难看出IjkMediaPlayer的核心是ffmpeg中的ffplay.c")])]),e._v(" "),_("li",[_("p",[e._v("将IjkMediaPlayer对象传入ijkplayer.c的ijkmp_prepare_async进行播放")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("ijkplayer.c当中调用ijkmp_prepare_async_l")]),e._v(" "),_("ul",[_("li",[e._v("调用ff_ffplay.c当中的ffp_prepare_async_l。ff_ffplay.c应该是对ffmpeg中的ffplay.c的重新")])])])])])]),e._v(" "),_("h3",{attrs:{id:"ijksdlglview"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijksdlglview"}},[e._v("#")]),e._v(" IJKSDLGLView")]),e._v(" "),_("h3",{attrs:{id:"ijkaudiokit-sharedinstance-setupaudiosession"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijkaudiokit-sharedinstance-setupaudiosession"}},[e._v("#")]),e._v(" [[IJKAudioKit sharedInstance] setupAudioSession];")]),e._v(" "),_("h3",{attrs:{id:"ijknotificationmanager"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijknotificationmanager"}},[e._v("#")]),e._v(" IJKNotificationManager")]),e._v(" "),_("h2",{attrs:{id:"音视频同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#音视频同步"}},[e._v("#")]),e._v(" 音视频同步")]),e._v(" "),_("p",[e._v("对于播放器来说，音视频同步是一个关键点，同时也是一个难点，同步效果的好坏，直接决定着播放器的质量。通常音视频同步的解决方案就是选择一个参考时钟，播放时读取音视频帧上的时间戳，同时参考当前时钟参考时钟上的时间来安排播放。              如果音视频帧的播放时间大于当前参考时钟上的时间，则不急于播放该帧，直到参考时钟达到该帧的时间戳；如果音视频帧的时间戳小于当前参考时钟上的时间，则需要“尽快”播放该帧或丢弃，以便播放进度追上参考时钟。")]),e._v(" "),_("h3",{attrs:{id:"选取视频时间戳作为参考时钟源"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#选取视频时间戳作为参考时钟源"}},[e._v("#")]),e._v(" 选取视频时间戳作为参考时钟源")]),e._v(" "),_("h3",{attrs:{id:"选取音频时间戳作为参考时钟源"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#选取音频时间戳作为参考时钟源"}},[e._v("#")]),e._v(" 选取音频时间戳作为参考时钟源")]),e._v(" "),_("h3",{attrs:{id:"选取外部时间作为参考时钟源"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#选取外部时间作为参考时钟源"}},[e._v("#")]),e._v(" 选取外部时间作为参考时钟源")]),e._v(" "),_("h2",{attrs:{id:"音视频解码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#音视频解码"}},[e._v("#")]),e._v(" 音视频解码")]),e._v(" "),_("p",[e._v("ijkplayer在视频解码上支持软解和硬解两种方式，可在起播前配置优先使用的解码方式，播放过程中不可切换。iOS平台上硬解使用VideoToolbox，Android平台上使用MediaCodec。ijkplayer中的音频解码只支持软解，暂不支持硬解。")]),e._v(" "),_("h3",{attrs:{id:"subtitle-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#subtitle-queue"}},[e._v("#")]),e._v(" subtitle queue")]),e._v(" "),_("h3",{attrs:{id:"video-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#video-queue"}},[e._v("#")]),e._v(" video queue")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("ffplay.c中video_thread，支持软解和硬解")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("调用ffpipenode.c中的ffpipenode_run_sync")]),e._v(" "),_("p",[e._v("ffpipenode_run_sync中调用的是IJKFF_Pipenode对象中的func_run_sync")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("func_run_sync")]),e._v(" "),_("p",[e._v("func_run_sync取决于播放前配置的软硬解，假设为软解，则调用")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("软解")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("调用ffplay.c中的ffp_video_thread")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("get_video_frame")]),e._v(" "),_("p",[e._v("获取解码前的AVFrame")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("decoder_decode_frame")]),e._v(" "),_("p",[e._v("该方法中从解码前的video queue中取出一帧数据，送入decoder进行解码，解码后的数据在ffplay_video_thread中送入pictq")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("存入pictq")]),e._v(" "),_("p",[e._v("FrameQueue结构体类型")])])])])])])])])])]),e._v(" "),_("li",[_("p",[e._v("硬解")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("调用ffpipenode_ios_videotoolbox_vdec.c中的videotoolbox_video_thread")]),e._v(" "),_("ul",[_("li",[e._v("videotoolbox_async_decode_frame")])])])])])])])])])])])]),e._v(" "),_("h3",{attrs:{id:"audio-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#audio-queue"}},[e._v("#")]),e._v(" audio queue")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("ffplay.c中的audio_thread，仅支持软解")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("packet_queue_get")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("avcodec_send_packet和avcodec_receive_frame")]),e._v(" "),_("ul",[_("li",[e._v("frame_queue_push")])])])])])])])]),e._v(" "),_("h2",{attrs:{id:"ffmpeg"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ffmpeg"}},[e._v("#")]),e._v(" ffmpeg")]),e._v(" "),_("h3",{attrs:{id:"ffplay-c代码流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ffplay-c代码流程"}},[e._v("#")]),e._v(" ffplay.c代码流程")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("开始播放")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("ffp_prepare_async_1")]),e._v(" "),_("p",[e._v("创建了音频输出对象")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("stream_open")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("stream_open的操作：1.创建存音视频解码前数据的videooq/audioq；2.创建存放音视频解码后数据的pictq/sampq；3.启动读数据线程read_thread；4.启动视频显示线程video_refresh_thread")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("read_thread")]),e._v(" "),_("p",[e._v("数据读取的整个过程都是由ffmpeg内部完成的，接收到网络过来的数据后，ffmpeg根据其封装格式，完成了解复用的动作，我们得到的，是音视频分离开的解码前的数据")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("avformat_alloc_context")]),e._v(" "),_("p",[e._v("创建上下文结构体，这个结构体是最上层的结构体，表示输入上下文")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("avformat_open_input")]),e._v(" "),_("p",[e._v("打开文件，主要是探测协议类型，如果是网络文件则创建网络链接等")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("avformat_find_stream_info")]),e._v(" "),_("p",[e._v("探测媒体类型，可得到当前文件的封装格式，音视频编码参数等信息")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("stream_component_open")]),e._v(" "),_("p",[e._v("打开视频、音频解码器。在此会打开相应解码器，并创建相应的解码线程。同时也调用了audio_open打开了audio output设备。")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("av_read_frame")]),e._v(" "),_("p",[e._v("读取媒体数据，得到的是音视频分离的解码前数据")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("packet_queue_put")]),e._v(" "),_("p",[e._v("将音视频数据AVPacket分别送入相应的queue中。")])])])])])])])])])])])]),e._v(" "),_("li",[_("p",[e._v("ic->interrupt_callback.callback = decode_interrupt_cb;\nic->interrupt_callback.opaque = is;")]),e._v(" "),_("p",[e._v("设置中断函数，如果出错或者退出，就可以立刻退出")])])])])])])])])])])])]),e._v(" "),_("li",[_("p",[e._v("iOS源码分析视频解码方式的选择，在stream_component_open方法中")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("打开解码器avcodec_open2")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("通过ffpipeline_open_video_decoder创建IJKFF_Pipenode，其最终调用的是ffpipeline_ios.c中的func_open_video_decoder来创建IJKFF_Pipenode的")]),e._v(" "),_("ul",[_("li",[_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("IJKFF_Pipenode* node = NULL;\n")])])])])])])])])]),e._v(" "),_("p",[e._v('IJKFF_Pipeline_Opaque *opaque = pipeline->opaque;\nif (ffp->videotoolbox) {\nnode = ffpipenode_create_video_decoder_from_ios_videotoolbox(ffp);\nif (!node)\nALOGE("vtb fail!!! switch to ffmpeg decode!!!! \\n");\n}\nif (node == NULL) {\nnode = ffpipenode_create_video_decoder_from_ffplay(ffp);\nffp->stat.vdec_type = FFP_PROPV_DECODER_AVCODEC;\nopaque->is_videotoolbox_open = false;\n} else {\nffp->stat.vdec_type = FFP_PROPV_DECODER_VIDEOTOOLBOX;\nopaque->is_videotoolbox_open = true;\n}\nffp_notify_msg2(ffp, FFP_MSG_VIDEO_DECODER_OPEN, opaque->is_videotoolbox_open);\nreturn node;')]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[e._v("  \t\t- 如果配置了ffp->videotoolbox，会优先去尝试打开硬件编码器ffpipenode_create_video_decoder_from_ios_videotoolbox，如果硬件编码器打开失败，则会自动切换至软解ffpipenode_create_video_decoder_from_ffplay\n\n  \t\t\t- ffp->videotoolbox需要在起播前通过如下方法配置：\n")])])])])]),e._v(" "),_("p",[e._v("ijkmp_set_option_int(_mediaPlayer, IJKMP_OPT_CATEGORY_PLAYER,")]),e._v(" "),_("p",[e._v('"videotoolbox", 1);')]),e._v(" "),_("h2",{attrs:{id:"目录结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[e._v("#")]),e._v(" 目录结构")]),e._v(" "),_("h3",{attrs:{id:"tools-初始化项目工程脚本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tools-初始化项目工程脚本"}},[e._v("#")]),e._v(" tools  初始化项目工程脚本")]),e._v(" "),_("h3",{attrs:{id:"config-编译ffmpeg使用的配置文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#config-编译ffmpeg使用的配置文件"}},[e._v("#")]),e._v(" config  编译ffmpeg使用的配置文件")]),e._v(" "),_("h3",{attrs:{id:"extra-存放编译ijkplayer所需的依赖源文件-如ffmpeg、openssl等"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#extra-存放编译ijkplayer所需的依赖源文件-如ffmpeg、openssl等"}},[e._v("#")]),e._v(" extra  存放编译ijkplayer所需的依赖源文件，如ffmpeg、openssl等")]),e._v(" "),_("h3",{attrs:{id:"ijkmedia-核心代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ijkmedia-核心代码"}},[e._v("#")]),e._v(" ijkmedia  核心代码")]),e._v(" "),_("ul",[_("li",[e._v("ijkplayer  播放器数据下载及解码相关")]),e._v(" "),_("li",[e._v("ijksdl音视频数据渲染相关")])]),e._v(" "),_("h3",{attrs:{id:"ios-ios平台上的上层接口封装以及平台相关方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ios-ios平台上的上层接口封装以及平台相关方法"}},[e._v("#")]),e._v(" ios  iOS平台上的上层接口封装以及平台相关方法")]),e._v(" "),_("h3",{attrs:{id:"android-android平台上的上层接口封装以及平台相关方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#android-android平台上的上层接口封装以及平台相关方法"}},[e._v("#")]),e._v(" android  android平台上的上层接口封装以及平台相关方法")]),e._v(" "),_("h2",{attrs:{id:"opengl-es"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#opengl-es"}},[e._v("#")]),e._v(" OpenGL ES")]),e._v(" "),_("h2",{attrs:{id:"picture-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#picture-queue"}},[e._v("#")]),e._v(" picture queue")]),e._v(" "),_("h3",{attrs:{id:"video-refresh-thread视频渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#video-refresh-thread视频渲染"}},[e._v("#")]),e._v(" video_refresh_thread视频渲染")]),e._v(" "),_("p",[e._v("iOS平台上采用OpenGL渲染解码后的YUV图像，渲染线程为video_refresh_thread，最后渲染图像的方法为video_image_display2")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("frame_queue_peek_last读取帧")]),e._v(" "),_("p",[e._v("从pictq对象中读取当前需要显示的视频帧")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("SDL_VoutDisplayYUVOverlay进行绘制")]),e._v(" "),_("ul",[_("li",[e._v("实际上调用的是vout_display_overlay进行绘制，该方法就是调用OpenGL绘制图像。")])])])])])]),e._v(" "),_("h2",{attrs:{id:"sample-queue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sample-queue"}},[e._v("#")]),e._v(" sample queue")]),e._v(" "),_("h3",{attrs:{id:"sdl-audio-callback音频输出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sdl-audio-callback音频输出"}},[e._v("#")]),e._v(" sdl_audio_callback音频输出")]),e._v(" "),_("p",[e._v("在stream_component_open中调用了audio_open打开了audio output设备，audio_open中配置了音频输出的相关参数SDL_AudioSpec，并通过SDL_AoutOpenAudio设置给了Audio Output，iOS平台即为AudioQueue。AudioQueue模块在工作过程中，通过不断的callback来获取pcm数据进行播放。")]),e._v(" "),_("ul",[_("li",[e._v("sdl_audio_callback")])]),e._v(" "),_("h2",{attrs:{id:"audioqueue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#audioqueue"}},[e._v("#")]),e._v(" AudioQueue")]),e._v(" "),_("p",[_("em",[e._v("XMind - Trial Version")])])])}),[],!1,null,null,null);a.default=t.exports}}]);