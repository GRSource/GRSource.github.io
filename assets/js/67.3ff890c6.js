(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{610:function(a,t,r){"use strict";r.r(t);var s=r(65),v=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[a._v("#")]),a._v(" 架构")]),a._v(" "),r("h2",{attrs:{id:"模块设计原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块设计原则"}},[a._v("#")]),a._v(" 模块设计原则")]),a._v(" "),r("h3",{attrs:{id:"越底层的模块-应该越稳定-越抽象-越具有高复用度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#越底层的模块-应该越稳定-越抽象-越具有高复用度"}},[a._v("#")]),a._v(" 越底层的模块，应该越稳定，越抽象，越具有高复用度")]),a._v(" "),r("h3",{attrs:{id:"不要让稳定的模块依赖不稳定的模块-减少依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#不要让稳定的模块依赖不稳定的模块-减少依赖"}},[a._v("#")]),a._v(" 不要让稳定的模块依赖不稳定的模块，减少依赖")]),a._v(" "),r("h3",{attrs:{id:"提升模块的复用度-自完备性有时候要优于代码复用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#提升模块的复用度-自完备性有时候要优于代码复用"}},[a._v("#")]),a._v(" 提升模块的复用度，自完备性有时候要优于代码复用")]),a._v(" "),r("h3",{attrs:{id:"每个模块只做好一件事情-不要让common出现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#每个模块只做好一件事情-不要让common出现"}},[a._v("#")]),a._v(" 每个模块只做好一件事情，不要让Common出现")]),a._v(" "),r("h3",{attrs:{id:"按照你架构的层数从上到下依赖-不要出现下层模块依赖上层模块的现象-业务模块之间也尽量不要耦合"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#按照你架构的层数从上到下依赖-不要出现下层模块依赖上层模块的现象-业务模块之间也尽量不要耦合"}},[a._v("#")]),a._v(" 按照你架构的层数从上到下依赖，不要出现下层模块依赖上层模块的现象，业务模块之间也尽量不要耦合")]),a._v(" "),r("h2",{attrs:{id:"解耦规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#解耦规则"}},[a._v("#")]),a._v(" 解耦规则")]),a._v(" "),r("h3",{attrs:{id:"公共模块下沉"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#公共模块下沉"}},[a._v("#")]),a._v(" 公共模块下沉")]),a._v(" "),r("h3",{attrs:{id:"面向接口调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#面向接口调用"}},[a._v("#")]),a._v(" 面向接口调用")]),a._v(" "),r("ul",[r("li",[a._v("模块间代码调用就会出现依赖，我们可以依赖于接口编程")])]),a._v(" "),r("h3",{attrs:{id:"面向协议编程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#面向协议编程"}},[a._v("#")]),a._v(" 面向协议编程")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("对于一些统一的调用，比如页面跳转使用接口就不太方便，我们可以通过URL跳转协议来满足需求")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("缺点")]),a._v(" "),r("ul",[r("li",[a._v("对于UIImage这种对象，或者带特殊字符的URL都会发生解析错误，可以使用URL Encode，但无形中增加了调用成本")])])])])])]),a._v(" "),r("h3",{attrs:{id:"ctmediator解耦方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ctmediator解耦方案"}},[a._v("#")]),a._v(" CTMediator解耦方案")]),a._v(" "),r("ul",[r("li",[a._v("基于Runtime来实现动态调用，避免模块注册，同时也避免产生反向依赖")]),a._v(" "),r("li",[a._v("通过Category暴露出更友好的接口，避免参数的构造和传递")]),a._v(" "),r("li",[a._v("在target-action之上构建openURL的处理")])]),a._v(" "),r("h2",{attrs:{id:"组件化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[a._v("#")]),a._v(" 组件化")]),a._v(" "),r("h3",{attrs:{id:"随着项目的增大-业务逻辑越来越复杂-业务之间的依赖关系更强-我们需要通过组件化让代码进行解耦。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#随着项目的增大-业务逻辑越来越复杂-业务之间的依赖关系更强-我们需要通过组件化让代码进行解耦。"}},[a._v("#")]),a._v(" 随着项目的增大，业务逻辑越来越复杂，业务之间的依赖关系更强，我们需要通过组件化让代码进行解耦。")]),a._v(" "),r("h3",{attrs:{id:"组件组成部分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组件组成部分"}},[a._v("#")]),a._v(" 组件组成部分")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("项目主工程")])]),a._v(" "),r("li",[r("p",[a._v("业务组件")])]),a._v(" "),r("li",[r("p",[a._v("基础工具类组件")])]),a._v(" "),r("li",[r("p",[a._v("中间件组件")])]),a._v(" "),r("li",[r("p",[a._v("基础UI组件")])]),a._v(" "),r("li",[r("p",[a._v("业务工具组件")]),a._v(" "),r("ul",[r("li",[a._v("这类组件是为各个业务组件提供基础功能的组件。这类组件可能会依赖到其他的组件。例如：网络请求组件，图片缓存组件，jspatch组件等")])])])]),a._v(" "),r("h3",{attrs:{id:"组件化主要使用私有化cocoapods进行划分-然后在各个子项目中实现自己的mvc、mvvm等模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组件化主要使用私有化cocoapods进行划分-然后在各个子项目中实现自己的mvc、mvvm等模式"}},[a._v("#")]),a._v(" 组件化主要使用私有化CocoaPods进行划分，然后在各个子项目中实现自己的MVC、MVVM等模式")]),a._v(" "),r("h2",{attrs:{id:"设计原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计原则"}},[a._v("#")]),a._v(" 设计原则")]),a._v(" "),r("h3",{attrs:{id:"单一职责原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[a._v("#")]),a._v(" 单一职责原则")]),a._v(" "),r("h3",{attrs:{id:"开闭原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[a._v("#")]),a._v(" 开闭原则")]),a._v(" "),r("ul",[r("li",[a._v("业务的增加我们不应该修改原有的功能，而是通过实现其接口来增加功能")])]),a._v(" "),r("h3",{attrs:{id:"依赖倒置原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则"}},[a._v("#")]),a._v(" 依赖倒置原则")]),a._v(" "),r("ul",[r("li",[a._v("针对接口编程，通过继承接口或者实现接口来编程")])]),a._v(" "),r("h3",{attrs:{id:"接口隔离原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[a._v("#")]),a._v(" 接口隔离原则")]),a._v(" "),r("h3",{attrs:{id:"迪米特法则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则"}},[a._v("#")]),a._v(" 迪米特法则")]),a._v(" "),r("ul",[r("li",[a._v("一个类应该只和它的成员变量，输入输出交互，不应该引用其他类")])]),a._v(" "),r("h3",{attrs:{id:"里氏替换原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[a._v("#")]),a._v(" 里氏替换原则")]),a._v(" "),r("ul",[r("li",[a._v("子类可以实现父类的抽象方法和增加自己的方法，不能重写父类的非抽象方法")])]),a._v(" "),r("p",[r("em",[a._v("XMind - Trial Version")])])])}),[],!1,null,null,null);t.default=v.exports}}]);