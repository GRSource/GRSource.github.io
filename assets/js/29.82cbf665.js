(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{567:function(n,t,a){"use strict";a.r(t);var i=a(65),r=Object(i.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"向量和矩阵"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#向量和矩阵"}},[n._v("#")]),n._v(" 向量和矩阵")]),n._v(" "),a("h2",{attrs:{id:"向量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#向量"}},[n._v("#")]),n._v(" 向量")]),n._v(" "),a("p",[n._v("向量的第四个分量w为齐次坐标，从齐次得到3D向量，仅需要把x、y、z、w都除以w即可。")]),n._v(" "),a("p",[n._v("点乘：")]),n._v(" "),a("p",[n._v("v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ")]),n._v(" "),a("p",[n._v("叉乘：")]),n._v(" "),a("p",[n._v("$$\n\\left[\n\\begin{matrix}\nAx \\\nAy  \\\nAz\n\\end{matrix}\n\\right] X")]),n._v(" "),a("p",[n._v("\\left[\n\\begin{matrix}\nBx \\\nBy  \\\nBz \\\n\\end{matrix}\n\\right] =\n\\left[\n\\begin{matrix}\nAy⋅Bz-Az⋅By \\\nAz⋅Bx-Ax⋅Bz  \\\nAx⋅By-Ay⋅Bx \\\n\\end{matrix}\n\\right]\n$$")]),n._v(" "),a("p",[n._v("a x b两个向量叉乘，可以获得垂直a，b的一个向量，但这个向量有两个方向，应该如何判断？")]),n._v(" "),a("p",[n._v("通过将a的头与b的尾相接，并检查a到b是顺时针还是逆时针，能够确定a x b的方向。在左手坐标系中，如果a和b呈顺时针，那么a x b指向您。如果a x b呈逆时针，那么a x b远离您。")]),n._v(" "),a("p",[n._v("而在右手坐标系中，如果a x b 呈顺时针方向，那么a x b远离您，如果a x b呈逆时针方向，那么a x b指向您。")]),n._v(" "),a("h2",{attrs:{id:"矩阵"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#矩阵"}},[n._v("#")]),n._v(" 矩阵")]),n._v(" "),a("p",[n._v("矩阵相乘不遵守交换律，在进行矩阵的组合变换时，应该先进行缩放、再进行旋转、最后才位移，否则它们会互相影响。在创建组合变换矩阵时，先写位移矩阵、再写旋转矩阵、最后写缩放矩阵，如对某个顶点进行缩放和位移操作：")]),n._v(" "),a("p",[n._v("变换矩阵 = 位移矩阵 ⋅ 缩放矩阵")]),n._v(" "),a("p",[n._v("向量变换后的结果 = 变换矩阵 ⋅ 原始向量")]),n._v(" "),a("p",[n._v("$$\n\\left[\n\\begin{matrix}\n1 & 0 & 0 & 0 \\\n0 & 1 & 0 & 0 \\\n0 & 0 & 1 & 0 \\\n0 & 0 & 0 & 1\n\\end{matrix}\n\\right] \\tag{单位矩阵}\n$$")]),n._v(" "),a("p",[n._v("$$\n\\left[\n\\begin{matrix}\nS1 & 0 & 0 & 0 \\\n0 & S2 & 0 & 0 \\\n0 & 0 & S3 & 0 \\\n0 & 0 & 0 & 1\n\\end{matrix}\n\\right] \\tag{缩放矩阵}\n$$")]),n._v(" "),a("p",[n._v("$$\n\\left[\n\\begin{matrix}\n1 & 0 & 0 & T1 \\\n0 & 1 & 0 & T2 \\\n0 & 0 & 1 & T3 \\\n0 & 0 & 0 & 1\n\\end{matrix}\n\\right] \\tag{位移矩阵}\n$$")]),n._v(" "),a("p",[n._v("$$\n\\left[\n\\begin{matrix}\n1 & cotθ & 0 & 0 \\\n0 & 1 & 0 & 0 \\\n0 & 0 & 1 & 0 \\\n0 & 0 & 0 & 1\n\\end{matrix}\n\\right] \\tag{x轴剪切矩阵}\n$$")]),n._v(" "),a("p",[n._v("$$\n\\left[\n\\begin{matrix}\n1 & 0 & 0 & 0 \\\n0 & cosθ & -sinθ & 0 \\\n0 & sinθ & cosθ & 0 \\\n0 & 0 & 0 & 1\n\\end{matrix}\n\\right] \\tag{沿x轴旋转矩阵}\n$$")]),n._v(" "),a("p",[n._v("$$\n\\left[\n\\begin{matrix}\ncosθ & 0 & sinθ & 0 \\\n0 & 1 & 0 & 0 \\\n-sinθ & 0 & cosθ & 0 \\\n0 & 0 & 0 & 1\n\\end{matrix}\n\\right] \\tag{沿y轴旋转矩阵}\n$$")]),n._v(" "),a("p",[n._v("$$\n\\left[\n\\begin{matrix}\ncosθ & -sinθ & 0 & 0 \\\nsinθ & cosθ & 0 & 0 \\\n0 & 0 & 1 & 0 \\\n0 & 0 & 0 & 1\n\\end{matrix}\n\\right] \\tag{沿z轴旋转矩阵}\n$$")]),n._v(" "),a("p",[n._v("右手坐标系，θ>0时表示逆时针旋转，θ<0时表示顺时针旋转")])])}),[],!1,null,null,null);t.default=r.exports}}]);