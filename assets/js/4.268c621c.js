(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{489:function(t,a,s){t.exports=s.p+"assets/img/同步串行.50e39822.png"},490:function(t,a,s){t.exports=s.p+"assets/img/异步串行.a1ba5973.png"},491:function(t,a,s){t.exports=s.p+"assets/img/同步并行.809da159.png"},492:function(t,a,s){t.exports=s.p+"assets/img/异步并行.39c5d78a.png"},493:function(t,a,s){t.exports=s.p+"assets/img/线程和队列对应关系.23efc116.png"},494:function(t,a,s){t.exports=s.p+"assets/img/dispatch_group_notify.036aa881.png"},495:function(t,a,s){t.exports=s.p+"assets/img/dispatch_group_wait.52f1578f.png"},496:function(t,a,s){t.exports=s.p+"assets/img/dispatch_group_enter.fcf6fd08.png"},497:function(t,a,s){t.exports=s.p+"assets/img/dispatch_block_t.e8726b66.png"},498:function(t,a,s){t.exports=s.p+"assets/img/dispatch_block_wait.0f8f337e.png"},499:function(t,a,s){t.exports=s.p+"assets/img/dispatch_block_notify.921aa88c.png"},500:function(t,a,s){t.exports=s.p+"assets/img/dispatch_block_cancel.3c7645a7.png"},501:function(t,a,s){t.exports=s.p+"assets/img/dispatch_after.35a98b20.png"},502:function(t,a,s){t.exports=s.p+"assets/img/dispatch_apply.f6e4cf41.png"},503:function(t,a,s){t.exports=s.p+"assets/img/dispatch_once.a8b31eb5.png"},504:function(t,a,s){t.exports=s.p+"assets/img/dispatch_barrier_async.5fd2ebaf.png"},505:function(t,a,s){t.exports=s.p+"assets/img/多读单写.6b4915c7.png"},506:function(t,a,s){t.exports=s.p+"assets/img/dispatch_set_target_queue.5b15be8c.png"},507:function(t,a,s){t.exports=s.p+"assets/img/dispatch_set_target_queue2.1168d719.png"},508:function(t,a,s){t.exports=s.p+"assets/img/NSThread.ebfa4ff1.png"},568:function(t,a,s){"use strict";s.r(a);var e=s(65),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"多线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[t._v("#")]),t._v(" 多线程")]),t._v(" "),e("h2",{attrs:{id:"gcd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gcd"}},[t._v("#")]),t._v(" GCD")]),t._v(" "),e("p",[t._v("同步/异步和串行/并行，有四种组合")]),t._v(" "),e("ul",[e("li",[t._v("dispatch_sync(serial_queue, ^{//任务});     //同步串行")]),t._v(" "),e("li",[t._v("dispatch_async(serial_queue, ^{//任务});    //异步串行")]),t._v(" "),e("li",[t._v("dispatch_sync(concurrent_queue, ^{//任务}); //同步并行")]),t._v(" "),e("li",[t._v("dispatch_async(concurrent_queue, ^{//任务});//异步并行")])]),t._v(" "),e("h3",{attrs:{id:"同步串行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步串行"}},[t._v("#")]),t._v(" 同步串行")]),t._v(" "),e("div",{staticClass:"language-Objective-C extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("- (void)viewDidLoad {\n  dispatch_sync(dispatch_get_main_queue(), ^{\n      [self doSomething];\n  });\n}\n")])])]),e("p",[t._v("上面会发生死锁，死锁原因："),e("br"),t._v("\n由队列引起的循环等待，而不是线程引起的循环等待。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(489),alt:"同步串行"}})]),t._v(" "),e("h3",{attrs:{id:"异步串行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步串行"}},[t._v("#")]),t._v(" 异步串行")]),t._v(" "),e("div",{staticClass:"language-Objective-C extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("- (void)viewDidLoad {\n  dispatch_async(dispatch_get_main_queue(), ^{\n      [self doSomething];\n  });\n}\n")])])]),e("p",[e("img",{attrs:{src:s(490),alt:"异步串行"}})]),t._v(" "),e("p",[t._v("没有问题")]),t._v(" "),e("h3",{attrs:{id:"同步并行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步并行"}},[t._v("#")]),t._v(" 同步并行")]),t._v(" "),e("p",[e("img",{attrs:{src:s(491),alt:"同步并行"}})]),t._v(" "),e("h3",{attrs:{id:"异步并行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步并行"}},[t._v("#")]),t._v(" 异步并行")]),t._v(" "),e("div",{staticClass:"language-Objective-C extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('- (void)viewDidLoad {\n    [super viewDidLoad];\n    // Do any additional setup after loading the view.\n\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        NSLog(@"1");\n        [self performSelector:@selector(printLog) withObject:nil afterDelay:0];\n        NSLog(@"3");\n    });\n}\n\n- (void)printLog {\n    NSLog(@"2");\n}\n')])])]),e("p",[t._v("上面的代码将只打印1和3，performSelecter:afterDelay: 来实现延迟执行，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。内部创建了RunLoop，但是没有调用run方法。所以不会执行。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(492),alt:"异步并行"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch和线程之间的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch和线程之间的关系"}},[t._v("#")]),t._v(" dispatch和线程之间的关系")]),t._v(" "),e("p",[t._v("dispatch_queue_t queue = dispatch_queue_create(label, attr);"),e("br"),t._v("\nlabel起标识作用"),e("br"),t._v("\nattr值有两个DISPATCH_QUEUE_CONCURRENT 和 DISPATCH_QUEUE_SERAIL（或者NULL）")]),t._v(" "),e("ol",[e("li",[t._v("无论attr的值是concurrent还是serial，当在主线程中调用dispatch_sync(queue, block)的时候，block代码将在主线程中执行。")]),t._v(" "),e("li",[t._v("当调用dispatch_async(queue, block)的时候，block代码将在新的线程中执行。如果queue为mainQueue，则还是主线程中执行。"),e("br"),t._v("\n（1），当queue的attr是 serail的时候，多次dispatch_async(queue, block2),这些block将在同一个线程中执行。"),e("br"),t._v("\n（2）， 当queue的attr是concurrent的时候，多次dispatch_async(queue, block2),这些block将在不同的线程中执行。")])]),t._v(" "),e("p",[t._v("图解：\n"),e("img",{attrs:{src:s(493),alt:"线程和队列对应关系"}})]),t._v(" "),e("h2",{attrs:{id:"dispatch-group"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-group"}},[t._v("#")]),t._v(" Dispatch Group")]),t._v(" "),e("h3",{attrs:{id:"dispatch-group-notify"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-group-notify"}},[t._v("#")]),t._v(" dispatch_group_notify")]),t._v(" "),e("p",[t._v("当我们想在gcd queue中所有的任务执行完毕之后做一些特定事情的时候，也就是队列的同步问题，如果队列是串行的话，那将该操作最后添加到队列中即可，如果队列是并行队列的话，这时候就可以利用dispatch_group来实现了，dispatch_group能很方便的解决同步问题。dispatch_group_create可以创建一个group对象，然后可以添加block到该组里面\n"),e("img",{attrs:{src:s(494),alt:"dispatch_group_notify"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-group-wait"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-group-wait"}},[t._v("#")]),t._v(" dispatch_group_wait")]),t._v(" "),e("p",[e("img",{attrs:{src:s(495),alt:"dispatch_group_wait"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-group-enter-dispatch-group-leave"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-group-enter-dispatch-group-leave"}},[t._v("#")]),t._v(" dispatch_group_enter&dispatch_group_leave")]),t._v(" "),e("p",[t._v("如果我们不想使用dispatch_group_async异步的将任务丢到group中去执行，这时候就需要用到dispatch_group_enter跟dispatch_group_leave方法，这两个方法要配对出现。\n"),e("img",{attrs:{src:s(496),alt:"dispatch_group_enter"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-block-t"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-block-t"}},[t._v("#")]),t._v(" dispatch_block_t")]),t._v(" "),e("p",[t._v("添加到gcd队列中执行的任务是以block的形式添加的，block封装了需要执行的功能，block带来的开发效率提升就不用说了，gcd跟block可以说是一对好基友，能够很好的配合使用。\n"),e("img",{attrs:{src:s(497),alt:"dispatch_block_t"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-block-wait"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-block-wait"}},[t._v("#")]),t._v(" dispatch_block_wait")]),t._v(" "),e("p",[t._v("当需要等待前面的任务执行完毕时，我们可以使用dispatch_block_wait这个接口，设置等待时间DISPATCH_TIME_FOREVER会一直等待知道前面的任务完成。用法跟dispatch_group_wait类似\n"),e("img",{attrs:{src:s(498),alt:"dispatch_block_wait"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-block-notify"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-block-notify"}},[t._v("#")]),t._v(" dispatch_block_notify")]),t._v(" "),e("p",[t._v("dispatch_block_notify当观察的某个block执行结束之后立即通知提交另一特定的block到指定的queue中执行，该函数有三个参数，第一个参数是需要观察的block，第二个参数是被通知block提交执行的queue，第三个参数是当需要被通知执行的block\n"),e("img",{attrs:{src:s(499),alt:"dispatch_block_notify"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-block-cancel"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-block-cancel"}},[t._v("#")]),t._v(" dispatch_block_cancel")]),t._v(" "),e("p",[t._v("可以取消提交到队列的block\n"),e("img",{attrs:{src:s(500),alt:"dispatch_block_cancel"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-after"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-after"}},[t._v("#")]),t._v(" dispatch_after")]),t._v(" "),e("p",[t._v("来延迟执行的GCD方法，因为在主线程中我们不能用sleep来延迟方法的调用，所以用它来是最合适的。\n"),e("img",{attrs:{src:s(501),alt:"dispatch_after"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-apply"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-apply"}},[t._v("#")]),t._v(" dispatch_apply")]),t._v(" "),e("p",[t._v("dispatch_apply类似一个for循环，会在指定的dispatch queue中运行block任务n次，如果队列是并发队列，则会并发执行block任务，dispatch_apply是一个同步调用，block任务执行n次后才返回。\n"),e("img",{attrs:{src:s(502),alt:"dispatch_apply"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-once"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-once"}},[t._v("#")]),t._v(" dispatch_once")]),t._v(" "),e("p",[t._v("整个程序运行中只会执行一次，使用dispatch_once可以简化代码并且彻底保证线程安全，开发者根本无须担心加锁或者同步。所有问题都由GCD在底层处理。由于每次调用时都必须使用完全相同的标记，所以标记要声明成static。所以用在单例模式上是最好的。\n"),e("img",{attrs:{src:s(503),alt:"dispatch_once"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-barrier-async"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-barrier-async"}},[t._v("#")]),t._v(" dispatch_barrier_async")]),t._v(" "),e("p",[t._v("dispatch_barrier_async用于等待前面的任务执行完毕后自己才执行，而它后面的任务需要等待它完成之后才执行。一个典型的例子就是数据的读写，通常为了防止文件读写导致冲突，我们会创建一个串行的队列，所有的文件操作都是通过这个队列来执行，比如FMDB，这样就可以避免读写冲突。不过其实这样效率是有提升的空间的，当没有数据更新时，读操作其实是可以并行进行的，而写操作需要串行的执行。\n"),e("img",{attrs:{src:s(504),alt:"dispatch_barrier_async"}})]),t._v(" "),e("p",[t._v("多读单写实现："),e("br"),t._v(" "),e("img",{attrs:{src:s(505),alt:"多读单写"}})]),t._v(" "),e("h3",{attrs:{id:"dispatch-set-target-queue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-set-target-queue"}},[t._v("#")]),t._v(" dispatch_set_target_queue")]),t._v(" "),e("ol",[e("li",[t._v("系统的Global Queue是可以指定优先级的，那我们可以用到dispatch_set_target_queue这个方法来指定自己创建队列的优先级\n"),e("img",{attrs:{src:s(506),alt:"dispatch_set_target_queue"}})]),t._v(" "),e("li",[t._v("dispatch_set_target_queue除了用来设置队列的优先级之外，还能够创建队列的层次体系，当我们想让不同队列中的任务同步的执行时，我们可以创建一个串行队列，然后将这些队列的target指向新创建的队列即可。\n"),e("img",{attrs:{src:s(507),alt:"dispatch_set_target_queue2"}})])]),t._v(" "),e("h2",{attrs:{id:"nsoperation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nsoperation"}},[t._v("#")]),t._v(" NSOperation")]),t._v(" "),e("p",[t._v("NSOperation是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。")]),t._v(" "),e("ul",[e("li",[t._v("使用子类NSInvocationOperation")]),t._v(" "),e("li",[t._v("使用子类NSBlockOperation")]),t._v(" "),e("li",[t._v("自定义继承自NSOperation的子类，通过实现内部相应的方法来封装操作。")])]),t._v(" "),e("p",[t._v("任务执行状态：")]),t._v(" "),e("ul",[e("li",[t._v("isReady")]),t._v(" "),e("li",[t._v("isExecuting")]),t._v(" "),e("li",[t._v("isFinished")]),t._v(" "),e("li",[t._v("isCancelled")])]),t._v(" "),e("p",[t._v("如果只重写main方法，底层控制变更任务执行完成状态，以及任务退出。isExecuting 和 isFinished，当main执行完之后，这个操作就结束了。\n如果重写了start方法，自行控制任务状态。")]),t._v(" "),e("p",[t._v("问：系统是怎样移除一个isFinished = YES的NSOperation的？"),e("br"),t._v("\n通过KVO移除NSOperationQueue中的NSOperation")]),t._v(" "),e("h2",{attrs:{id:"nsthread"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nsthread"}},[t._v("#")]),t._v(" NSThread")]),t._v(" "),e("p",[t._v("启动流程：\n"),e("img",{attrs:{src:s(508),alt:"NSThread"}}),t._v("\nStart方法："),e("br"),t._v("\n判断状态  --  创建pthread  ---\x3e  调用线程main函数 ---\x3e  退出"),e("br"),t._v("\nmain函数实现：\n异常判断 --\x3e调用target的SEL")]),t._v(" "),e("h2",{attrs:{id:"多线程与锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多线程与锁"}},[t._v("#")]),t._v(" 多线程与锁")])])}),[],!1,null,null,null);a.default=i.exports}}]);