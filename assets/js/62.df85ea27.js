(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{603:function(a,t,_){"use strict";_.r(t);var s=_(65),e=Object(s.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"ios细节"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ios细节"}},[a._v("#")]),a._v(" iOS细节")]),a._v(" "),_("h2",{attrs:{id:"self和super的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#self和super的区别"}},[a._v("#")]),a._v(" self和super的区别")]),a._v(" "),_("h3",{attrs:{id:"self是对象指针"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#self是对象指针"}},[a._v("#")]),a._v(" self是对象指针")]),a._v(" "),_("h3",{attrs:{id:"super是结构体"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#super是结构体"}},[a._v("#")]),a._v(" super是结构体")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("struct objc_super")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("id receiver;")]),a._v(" "),_("ul",[_("li",[a._v("消息接收者为self")])])]),a._v(" "),_("li",[_("p",[a._v("Class super_class")]),a._v(" "),_("ul",[_("li",[a._v("父类对象指针")])])])])]),a._v(" "),_("li",[_("p",[a._v("表示从父类开始查找方法，但是消息的接收者仍然是self")])])]),a._v(" "),_("h3",{attrs:{id:"我们到父类中打印self-发现当前类的self和父类的self的地址是相同的-因为当前类self本来就是一层一层通过父类传递下来的-最终创建者是oc底层代码calloc开辟的内存空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#我们到父类中打印self-发现当前类的self和父类的self的地址是相同的-因为当前类self本来就是一层一层通过父类传递下来的-最终创建者是oc底层代码calloc开辟的内存空间"}},[a._v("#")]),a._v(" 我们到父类中打印self，发现当前类的self和父类的self的地址是相同的，因为当前类self本来就是一层一层通过父类传递下来的，最终创建者是OC底层代码calloc开辟的内存空间")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("self创建流程")]),a._v(" "),_("ul",[_("li",[a._v("通过class_ro_t取得实例大小")]),a._v(" "),_("li",[a._v("通过calloc开辟内存空间")]),a._v(" "),_("li",[a._v("初始化isa指针")])])])]),a._v(" "),_("h3",{attrs:{id:"self-class-和-super-class-结果都是当前类名"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#self-class-和-super-class-结果都是当前类名"}},[a._v("#")]),a._v(" [self class]和[super class]结果都是当前类名")]),a._v(" "),_("ul",[_("li",[a._v("因为self和"),_("code",[a._v("super")]),a._v("对象地址(对象地址里面存了isa指针、自定义的基本数据类型、其他自定义的对象指针)相同，所以等价于[self class]和["),_("code",[a._v("self")]),a._v(" class]，都是通过相同的isa指针到类对象当中查找对于的“class”方法(先查找缓存、然后查找class_rw_t，然后通过superclass指针到父类中查找)，依次查找父类直到NSObject。")])]),a._v(" "),_("h2",{attrs:{id:"category"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#category"}},[a._v("#")]),a._v(" Category")]),a._v(" "),_("h3",{attrs:{id:"分类可以添加"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分类可以添加"}},[a._v("#")]),a._v(" 分类可以添加")]),a._v(" "),_("ul",[_("li",[a._v("protocol")]),a._v(" "),_("li",[a._v("property(settter/getter)")]),a._v(" "),_("li",[a._v("function")])]),a._v(" "),_("h3",{attrs:{id:"运行时附加到宿主类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行时附加到宿主类"}},[a._v("#")]),a._v(" 运行时附加到宿主类")]),a._v(" "),_("h2",{attrs:{id:"返回类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#返回类型"}},[a._v("#")]),a._v(" 返回类型")]),a._v(" "),_("h3",{attrs:{id:"id"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#id"}},[a._v("#")]),a._v(" id")]),a._v(" "),_("ul",[_("li",[a._v("表示任意类型")])]),a._v(" "),_("h3",{attrs:{id:"instancetype"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#instancetype"}},[a._v("#")]),a._v(" instancetype")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("建议使用instancetype作为alloc和init的返回值而不要使用id作为返回值，因为instancetype会做类型判断，而id不会做类型判断，在使用id调用方法时可能是任意的，因为其他类可能包含同名方法。")])]),a._v(" "),_("li",[_("p",[a._v("提高OC代码的类型安全性")])]),a._v(" "),_("li",[_("p",[a._v("仅用于返回值的类型")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("返回值的类型为何用instancetype而不用id?")]),a._v(" "),_("ul",[_("li",[a._v("instancetype表示返回的是与当前类相关的对象，编译器会做类型检查，类型更安全")])])]),a._v(" "),_("li",[_("p",[a._v("返回值的类型为何用instancetype而不用具体的类名，具体的类名不是类型更安全吗？")]),a._v(" "),_("ul",[_("li",[a._v("如果在子类中调用该方法或者子类重写了该方法，那么该方法返回的类型是父类的实例，而不是具体的子类实例")])])])])])]),a._v(" "),_("h2",{attrs:{id:"extension"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#extension"}},[a._v("#")]),a._v(" Extension")]),a._v(" "),_("h3",{attrs:{id:"编译时附加到宿主类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编译时附加到宿主类"}},[a._v("#")]),a._v(" 编译时附加到宿主类")]),a._v(" "),_("h3",{attrs:{id:"扩展可以添加"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#扩展可以添加"}},[a._v("#")]),a._v(" 扩展可以添加")]),a._v(" "),_("ul",[_("li",[a._v("protocol")]),a._v(" "),_("li",[a._v("property")]),a._v(" "),_("li",[a._v("function")])]),a._v(" "),_("h2",{attrs:{id:"self-alloc-init-和-myobject-alloc-init-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#self-alloc-init-和-myobject-alloc-init-区别"}},[a._v("#")]),a._v(" [[self alloc] init]和[[MyObject alloc]init]区别")]),a._v(" "),_("h3",{attrs:{id:"如果在子类的init中调用父类的init方法-如果父类中使用-self-class-时-编译器可以确定初始化类型为子类-那么可以调用子类的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果在子类的init中调用父类的init方法-如果父类中使用-self-class-时-编译器可以确定初始化类型为子类-那么可以调用子类的方法"}},[a._v("#")]),a._v(" 如果在子类的init中调用父类的init方法，如果父类中使用[self class]时，编译器可以确定初始化类型为子类，那么可以调用子类的方法")]),a._v(" "),_("h3",{attrs:{id:"如果父类中使用具体的类名进行的初始化-那么在调用父类的初始化方法时-会初始化成父类对象-调用子类方法时会发生崩溃"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果父类中使用具体的类名进行的初始化-那么在调用父类的初始化方法时-会初始化成父类对象-调用子类方法时会发生崩溃"}},[a._v("#")]),a._v(" 如果父类中使用具体的类名进行的初始化，那么在调用父类的初始化方法时，会初始化成父类对象，调用子类方法时会发生崩溃")]),a._v(" "),_("h3",{attrs:{id:"通常单例返回值是instancetype-而内部初始化使用-self-alloc-使用-self-alloc-可以保证在子类当中进行初始化时返回的仍然是子类对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通常单例返回值是instancetype-而内部初始化使用-self-alloc-使用-self-alloc-可以保证在子类当中进行初始化时返回的仍然是子类对象"}},[a._v("#")]),a._v(" 通常单例返回值是instancetype，而内部初始化使用[self alloc]，使用[self alloc]可以保证在子类当中进行初始化时返回的仍然是子类对象")]),a._v(" "),_("h2",{attrs:{id:"properties"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#properties"}},[a._v("#")]),a._v(" properties")]),a._v(" "),_("h3",{attrs:{id:"优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),_("ul",[_("li",[a._v("自动生成getter和setter")]),a._v(" "),_("li",[a._v("直观的确定附加信息")])]),a._v(" "),_("h2",{attrs:{id:"关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关键字"}},[a._v("#")]),a._v(" 关键字")]),a._v(" "),_("h3",{attrs:{id:"读写权限"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读写权限"}},[a._v("#")]),a._v(" 读写权限")]),a._v(" "),_("ul",[_("li",[a._v("readwrite(默认)")]),a._v(" "),_("li",[a._v("readonly")])]),a._v(" "),_("h3",{attrs:{id:"原子性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[a._v("#")]),a._v(" 原子性")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("atomic(默认)")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("只是setter/getter线程安全，意思是只保证了数据的完整性，不至于崩溃，但是无法保证多个线程读写的线程安全，如果在多个线程进行读写操作，那么结果是不确定的。")]),a._v(" "),_("ul",[_("li",[a._v('dispatch_async(queue1, ^{\nfor (int i = 0; i < 10000; i++) {\nself.intSource++;\n}\nNSLog(@"++%d", self.intSource);\n});')])])])]),a._v(" "),_("p",[a._v('dispatch_async(queue2, ^{\nfor (int i = 0; i < 10000; i++) {\nself.intSource++;\n}\nNSLog(@"--%d", self.intSource);\n});')])]),a._v(" "),_("li",[_("p",[a._v("nonatomic")])])]),a._v(" "),_("h3",{attrs:{id:"引用计数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[a._v("#")]),a._v(" 引用计数")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("strong")]),a._v(" "),_("ul",[_("li",[a._v("引用计数+1，iOS默认是strong类型，所有的赋值操作默认都是strong")])])]),a._v(" "),_("li",[_("p",[a._v("assign")]),a._v(" "),_("ul",[_("li",[a._v("即可修饰基本数据类型，也可修饰对象")]),a._v(" "),_("li",[a._v("不改变引用计数，但是在原对象释放后，assign对象不会释放")])])]),a._v(" "),_("li",[_("p",[a._v("weak/__weak")]),a._v(" "),_("ul",[_("li",[a._v("只能修饰对象")]),a._v(" "),_("li",[a._v("不改变原对象的引用计数，在原对象释放后，weak变量会被自动置为nil。weak对象本身引用计数会+1，原对象引用计数不变")]),a._v(" "),_("li",[a._v("对weak变量进行strong操作后，如果原对象被释放，那么weak变量置为nil，但是strong变量仍然存在，因为weak置为nil后，strong变量的引用计数只是从2变为1，有时候我们需要在block当中对weak变量进行strong，是因为多线程情况下，如果原对象被释放，如果想要block中的weak仍然存在，只能进行strong操作，对于单线程则没必要")])])]),a._v(" "),_("li",[_("p",[a._v("copy")]),a._v(" "),_("ul",[_("li",[a._v("对于不可变的对象进行copy操作是浅拷贝，只是增加了引用计数，和strong没区别")]),a._v(" "),_("li",[a._v("对于可变对象进行copy操作是深拷贝，copy之后是两个不同的对象")])])]),a._v(" "),_("li",[_("p",[a._v("mutableCopy")]),a._v(" "),_("ul",[_("li",[a._v("操作均是深拷贝，拷贝之后是不同的对象")])])])]),a._v(" "),_("h3",{attrs:{id:"block"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block"}},[a._v("#")]),a._v(" __block")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("对被截获变量进行赋值操作需要使用__block")])]),a._v(" "),_("li",[_("p",[a._v("使用")]),a._v(" "),_("ul",[_("li",[a._v("局部基本变量或者对象")])])]),a._v(" "),_("li",[_("p",[a._v("__block修饰的变量变成了对象")])]),a._v(" "),_("li",[_("p",[a._v("会增加原对象的引用计数+1，自己的引用计数也会+1")])]),a._v(" "),_("li",[_("p",[a._v("__block结构体内部会有一个__forwarding指针，__forwarding存在的意义是让任何使用了__block变量的block都能通过__forwarding指针访问__block变量")])])]),a._v(" "),_("h3",{attrs:{id:"nil"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nil"}},[a._v("#")]),a._v(" nil")]),a._v(" "),_("ul",[_("li",[a._v("将对象置为nil实际上只是将原对象引用计数-1")]),a._v(" "),_("li",[a._v("向nil对象发送消息不会crash，但是向一个dealloc之后的对象发送消息会crash，这就是为什么weak修饰的变量，在原对象释放后runtime要自动置为nil的原因")])]),a._v(" "),_("h3",{attrs:{id:"unsafe-unretained-unowned"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#unsafe-unretained-unowned"}},[a._v("#")]),a._v(" __unsafe_unretained/unowned")]),a._v(" "),_("ul",[_("li",[a._v("不会增加原对象的引用计数，但是依旧会增加自身的引用计数，和weak一样")]),a._v(" "),_("li",[a._v("和__weak不同的是，__unsafe_unretained不会使用弱引用表管理，所以需要进行手动置为nil，否则会造成内存泄漏，因为此时__unsafe_unretained指向一个已经释放的对象")])]),a._v(" "),_("h3",{attrs:{id:"property-nonatomic-copy-people-obj22"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#property-nonatomic-copy-people-obj22"}},[a._v("#")]),a._v(" @property (nonatomic, copy) People *obj22;")]),a._v(" "),_("ul",[_("li",[a._v("property中的copy应该默认实现了NSCopying协议，协议内容只是引用计数+1，所以不会crash")]),a._v(" "),_("li",[a._v("如果是我们自己调用[obj copy]，则必须实现NSCopying协议，否则会crash，数组、字典、字符串默认都实现了NSCopying和NSMutableCopying")])]),a._v(" "),_("h2",{attrs:{id:"block理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block理解"}},[a._v("#")]),a._v(" block理解")]),a._v(" "),_("h3",{attrs:{id:"通过block源码-我们可以发现-对于局部变量-block会将其当做参数传入block结构体"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通过block源码-我们可以发现-对于局部变量-block会将其当做参数传入block结构体"}},[a._v("#")]),a._v(" 通过block源码，我们可以发现，对于局部变量，block会将其当做参数传入block结构体")]),a._v(" "),_("ul",[_("li",[a._v("如果局部变量是基本数据类型，在block初始化之后改变其值时，我们在block内部无法获取最新值，因为基本数据类型在block初始化期间已经确定")]),a._v(" "),_("li",[a._v("如果局部变量时指针类型，在block之后改变其指向的值时，block内部可以获取到新的值，因为block传入的参数是指针")])]),a._v(" "),_("h3",{attrs:{id:"如果是静态局部变量-block会将它的指针当做参数传入block结构体"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果是静态局部变量-block会将它的指针当做参数传入block结构体"}},[a._v("#")]),a._v(" 如果是静态局部变量，block会将它的指针当做参数传入block结构体")]),a._v(" "),_("ul",[_("li",[a._v("所以我们在block初始化之后改变其值时，block获取的到值是改变后的值")])]),a._v(" "),_("h3",{attrs:{id:"如果是全局变量或者静态全局变量-block不会将它当做参数传入block-而是会直接使用-因为是全局的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果是全局变量或者静态全局变量-block不会将它当做参数传入block-而是会直接使用-因为是全局的"}},[a._v("#")]),a._v(" 如果是全局变量或者静态全局变量，block不会将它当做参数传入block，而是会直接使用，因为是全局的")]),a._v(" "),_("ul",[_("li",[a._v("不管全局变量是基本数据类型还是指针类型，我们都可以在block初始化之后改变它的值，而使block内部取值发生变量")])]),a._v(" "),_("h3",{attrs:{id:"外部变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#外部变量"}},[a._v("#")]),a._v(" 外部变量")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("外部变量使用__block修饰")]),a._v(" "),_("ul",[_("li",[a._v("在block内部操作外部变量不会增加外部变量的引用计数，原因在于外部变量会存储于__block结构体的__forwarding指针内，后续传递到block结构体内部的是__block结构体，而不是外部变量本身。所以不会增加它的引用计数，如果在内部进行赋值，则会增加引用计数")])])]),a._v(" "),_("li",[_("p",[a._v("外部变量不使用__block修饰")]),a._v(" "),_("ul",[_("li",[a._v("在block内部操作外部变量，会增加2次外部变量的引用计数(weak变量除外)，原因在于外部对象会以指针形式作为参数传入结构体block_impl_0的构造函数，这是第一次引用计数+1，然后在构造函数内会将外部变量指针存储到结构体当中，这是第二次引用计数+1")])])])]),a._v(" "),_("h3",{attrs:{id:"impl-isa-nsconcretestackblock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#impl-isa-nsconcretestackblock"}},[a._v("#")]),a._v(" impl.isa = &_NSConcreteStackBlock;")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("栈block")]),a._v(" "),_("ul",[_("li",[a._v("__block int a = 10;")])])])]),a._v(" "),_("h3",{attrs:{id:"impl-isa-nsconcretestackblock-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#impl-isa-nsconcretestackblock-2"}},[a._v("#")]),a._v(" impl.isa = &_NSConcreteStackBlock;")]),a._v(" "),_("ul",[_("li",[a._v("堆block")])]),a._v(" "),_("h3",{attrs:{id:"impl-isa-nsconcretestackblock-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#impl-isa-nsconcretestackblock-3"}},[a._v("#")]),a._v(" impl.isa = &_NSConcreteStackBlock;")]),a._v(" "),_("ul",[_("li",[a._v("全局block")])]),a._v(" "),_("h3",{attrs:{id:"如果block中使用了成员变量-那么会将self指针当做参数传递给block结构体-此时block结构体引用了self。如果再将block当做self的成员变量-那么self又引用了block-会形成循环引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果block中使用了成员变量-那么会将self指针当做参数传递给block结构体-此时block结构体引用了self。如果再将block当做self的成员变量-那么self又引用了block-会形成循环引用"}},[a._v("#")]),a._v(" 如果block中使用了成员变量，那么会将self指针当做参数传递给block结构体，此时block结构体引用了self。如果再将block当做self的成员变量，那么self又引用了block，会形成循环引用")]),a._v(" "),_("h3",{attrs:{id:"单线程中使用-unsafe-unretained-unowned-weak效果是一样的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单线程中使用-unsafe-unretained-unowned-weak效果是一样的"}},[a._v("#")]),a._v(" 单线程中使用__unsafe_unretained/unowned/__weak效果是一样的")]),a._v(" "),_("h2",{attrs:{id:"变量和常量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量和常量"}},[a._v("#")]),a._v(" 变量和常量")]),a._v(" "),_("h3",{attrs:{id:"static和auto变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#static和auto变量"}},[a._v("#")]),a._v(" static和auto变量")]),a._v(" "),_("ul",[_("li",[a._v("不难看出，二者都是变量，所以可以赋值多次")]),a._v(" "),_("li",[a._v("但是static只会初始化一次(即只会在第一次定义时有效，多次定义无效)，但是static是可以多次赋值的，意思就是static int a = 10;只会调用一次，但是可以对a进行多次赋值。")])]),a._v(" "),_("h3",{attrs:{id:"const常量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#const常量"}},[a._v("#")]),a._v(" const常量")]),a._v(" "),_("ul",[_("li",[a._v("只能赋值一次")])]),a._v(" "),_("h2",{attrs:{id:"常见的crash"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的crash"}},[a._v("#")]),a._v(" 常见的crash")]),a._v(" "),_("h3",{attrs:{id:"_1-向dealloc对象发送消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-向dealloc对象发送消息"}},[a._v("#")]),a._v(" 1.向dealloc对象发送消息")]),a._v(" "),_("h3",{attrs:{id:"_2-调用一个没有实现的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-调用一个没有实现的方法"}},[a._v("#")]),a._v(" 2.调用一个没有实现的方法")]),a._v(" "),_("h3",{attrs:{id:"_3-向数组或者字典插入nil"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-向数组或者字典插入nil"}},[a._v("#")]),a._v(" 3.向数组或者字典插入nil")]),a._v(" "),_("h2",{attrs:{id:"多线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[a._v("#")]),a._v(" 多线程")]),a._v(" "),_("h3",{attrs:{id:"gcd"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gcd"}},[a._v("#")]),a._v(" GCD")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("并发队列")]),a._v(" "),_("p",[a._v("提交到队列中的任务可以并发执行")]),a._v(" "),_("ul",[_("li",[a._v("dispatch_get_global_queue")]),a._v(" "),_("li",[a._v('dispatch_queue_create("com.apple.root.default-qos", DISPATCH_QUEUE_CONCURRENT);')])])]),a._v(" "),_("li",[_("p",[a._v("串行队列")]),a._v(" "),_("ul",[_("li",[a._v("dispatch_get_main_queue")]),a._v(" "),_("li",[a._v('dispatch_queue_create("com.apple.root.default-qos", DISPATCH_QUEUE_SERIAL);')])])]),a._v(" "),_("li",[_("p",[a._v("sync")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("不开启新线程")]),a._v(" "),_("ul",[_("li",[a._v("交出当前任务的时间片交给串行队列或者并行队列，如果是串行队列，这串行执行任务，如果是并行队列，则每个任务使用一定的CPU时间片同时执行。")]),a._v(" "),_("li",[a._v('例如dispatch_sync(dispatch_queue_create("com.apple", NULL), ^{')])])])]),a._v(" "),_("p",[a._v("});")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v('  \t- 首先调用者交出当前线程的时间片，然后交给串行队列串行执行\n\n  - dispatch_sync(dispatch_queue_create("com.apple", DISPATCH_QUEUE_CONCURRENT), ^{\n')])])]),_("p",[a._v("});")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("  \t- 首先调用者交出当前线程的时间片，然后交给并发队列并发执行\n")])])])]),a._v(" "),_("li",[_("p",[a._v("async")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("如果是并发队列，则会开启新线程，执行顺序不确定，例如")]),a._v(" "),_("ul",[_("li",[_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("dispatch_async(dispatch_get_global_queue(0, 0), ^{\n")])])])])])])]),a._v(" "),_("p",[a._v("});")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("  \t- 开启新线程，不会交出主线程的时间片，并且并发的在子线程中执行任务\n")])])]),_("ul",[_("li",[_("p",[a._v("如果是我们自己创建串行队列，也会开启新线程，串行执行scope任务，例如")]),a._v(" "),_("ul",[_("li",[a._v('dispatch_queue_t queue_serial = dispatch_queue_create("com.apple.root.default-qos", NULL);\ndispatch_async(queue_serial, ^{')])])])]),a._v(" "),_("p",[a._v("});")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("  \t- 开启新线程，不会交出主线程时间片，并且在子线程中串行的执行任务\n")])])]),_("ul",[_("li",[_("p",[a._v("如果是主队列，则不会开启新线程，例如")]),a._v(" "),_("ul",[_("li",[a._v("dispatch_async(dispatch_get_main_queue(), ^{")])])])]),a._v(" "),_("p",[a._v("});")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("  \t- 不会开启新线程，将任务交到主线程中串行执行\n")])])])]),a._v(" "),_("li",[_("p",[a._v("队列和线程是两个概念，线程总是被动开启")])]),a._v(" "),_("li",[_("p",[a._v("dispatch_barrier_async")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("特性")]),a._v(" "),_("ul",[_("li",[a._v("之前添加的任务执行完成后才会执行dispatch_barrier_async的任务，然后执行dispatch_barrier_async之后的任务，dispatch_barrier_async就是一个任务执行的分界线")]),a._v(" "),_("li",[a._v("通常dispatch_barrier_async都是添加自己创建的并发队列")]),a._v(" "),_("li",[a._v("如果添加串行队列，那么就会在新线程中串行执行任务，相当于dispatch_sync")]),a._v(" "),_("li",[a._v("如果添加全局并发队列是不可取的，因为苹果会在全局队列中添加自己的任务")])])]),a._v(" "),_("li",[_("p",[a._v("通常用于数据库的多读单写操作")])])])]),a._v(" "),_("li",[_("p",[a._v("dispatch_barrier_sync同步执行")])]),a._v(" "),_("li",[_("p",[a._v("dispatch_group_async(只有异步)")]),a._v(" "),_("ul",[_("li",[a._v("dispatch_group_async(group, concurrent_queue, ^{")])]),a._v(" "),_("p",[a._v("});")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("  - 将任务添加到异步队列中并发执行\n")])])]),_("ul",[_("li",[a._v("dispatch_group_notify(group, dispatch_get_main_queue(), ^{")])]),a._v(" "),_("p",[a._v("});")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("  - 等待上面任务执行完后再执行当前任务\n  - dispatch_group_notify也是异步的\n")])])])]),a._v(" "),_("li",[_("p",[a._v("取消gcd")]),a._v(" "),_("ul",[_("li",[a._v("dispatch_block_cancel(block)")]),a._v(" "),_("li",[a._v("外部变量")])])]),a._v(" "),_("li",[_("p",[a._v("挂起")]),a._v(" "),_("ul",[_("li",[a._v("dispatch_suspend(queue)")])])]),a._v(" "),_("li",[_("p",[a._v("恢复")]),a._v(" "),_("ul",[_("li",[a._v("dispatch_resume(queue)")])])]),a._v(" "),_("li",[_("p",[a._v("缺点")]),a._v(" "),_("ul",[_("li",[a._v("线程爆炸")]),a._v(" "),_("li",[a._v("死锁")]),a._v(" "),_("li",[a._v("优先级反转")])])])]),a._v(" "),_("h3",{attrs:{id:"nsoperation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsoperation"}},[a._v("#")]),a._v(" NSOperation")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("优点")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("可以添加任务依赖")])]),a._v(" "),_("li",[_("p",[a._v("可以控制任务状态")]),a._v(" "),_("ul",[_("li",[a._v("isReady")]),a._v(" "),_("li",[a._v("isExcuting")]),a._v(" "),_("li",[a._v("isFinished")]),a._v(" "),_("li",[a._v("isCancelled")])])]),a._v(" "),_("li",[_("p",[a._v("可以设置最大并发量")])])])]),a._v(" "),_("li",[_("p",[a._v("重写main方法")]),a._v(" "),_("ul",[_("li",[a._v("底层控制变更任务执行完成状态，以及任务退出")])])]),a._v(" "),_("li",[_("p",[a._v("重写start方法")]),a._v(" "),_("ul",[_("li",[a._v("自行控制任务状态")])])])]),a._v(" "),_("h3",{attrs:{id:"nsthread"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsthread"}},[a._v("#")]),a._v(" NSThread")]),a._v(" "),_("h3",{attrs:{id:"同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[a._v("#")]),a._v(" 同步")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("原子操作")])]),a._v(" "),_("li",[_("p",[a._v("锁")])]),a._v(" "),_("li",[_("p",[a._v("条件")])]),a._v(" "),_("li",[_("p",[a._v("selector")])]),a._v(" "),_("li",[_("p",[a._v("缺点")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("优先级反转")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("低中高三个线程依次执行，在低优先级的线程释放同步资源前，中高线程需要等待，在低优先级的线程释放同步资源后，高优先级的任务还需要等待中优先级的任务执行完才能拿到资源，这就是优先级反转")])]),a._v(" "),_("li",[_("p",[a._v("解决办法")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("优先级继承")]),a._v(" "),_("ul",[_("li",[a._v("将低优先级的任务提升到高优先级的水平，让其先执行完释放同步资源后再恢复其优先级，此时高优先级的任务可以获得同步资源继续执行")])])]),a._v(" "),_("li",[_("p",[a._v("优先级天花板")]),a._v(" "),_("ul",[_("li",[a._v("将访问共享资源的线程提升到最高优先级，同时却会带来一个问题，会阻塞高优先级的任务")])])])])])])]),a._v(" "),_("li",[_("p",[a._v("死锁")])]),a._v(" "),_("li",[_("p",[a._v("性能问题")])]),a._v(" "),_("li",[_("p",[a._v("线程饥饿")]),a._v(" "),_("ul",[_("li",[a._v("线程一直被高优先级的线程抢占锁和时间片")])])])])])]),a._v(" "),_("h3",{attrs:{id:"通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通信"}},[a._v("#")]),a._v(" 通信")]),a._v(" "),_("ul",[_("li",[a._v("source")]),a._v(" "),_("li",[a._v("selector")]),a._v(" "),_("li",[a._v("变量")]),a._v(" "),_("li",[a._v("条件变量")]),a._v(" "),_("li",[a._v("socket")]),a._v(" "),_("li",[a._v("共享内存")])]),a._v(" "),_("h3",{attrs:{id:"优点-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),_("ul",[_("li",[a._v("共享内存")]),a._v(" "),_("li",[a._v("相比进程更加轻量级")])]),a._v(" "),_("h3",{attrs:{id:"缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),_("ul",[_("li",[a._v("资源竞争")]),a._v(" "),_("li",[a._v("线程上下文切换开销")])]),a._v(" "),_("h2",{attrs:{id:"锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[a._v("#")]),a._v(" 锁")]),a._v(" "),_("h3",{attrs:{id:"自旋锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[a._v("#")]),a._v(" 自旋锁")]),a._v(" "),_("p",[a._v("自旋锁加锁的时候，等待锁的线程处于忙等状态，并且占用着CPU的资源")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("当预计线程等待锁的时间很短，或者加锁的代码（临界区）经常被调用，但竞争情况很少发生，再或者CPU资源不紧张，拥有多核处理器的时候使用自旋锁比较合适。")])]),a._v(" "),_("li",[_("p",[a._v("OSSpinLock   --  deprecated: 10.0")]),a._v(" "),_("ul",[_("li",[a._v("非线程安全，因为有潜在的优先级反转问题")])])]),a._v(" "),_("li",[_("p",[a._v("os_unfair_lock")])])]),a._v(" "),_("h3",{attrs:{id:"互斥锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁"}},[a._v("#")]),a._v(" 互斥锁")]),a._v(" "),_("p",[a._v("互斥锁加锁的时候，等待锁的线程处于休眠状态，不会占用CPU资源")]),a._v(" "),_("ul",[_("li",[a._v("NSLock")]),a._v(" "),_("li",[a._v("@synchronized")])]),a._v(" "),_("h3",{attrs:{id:"dispatch-semaphore"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dispatch-semaphore"}},[a._v("#")]),a._v(" dispatch_semaphore")]),a._v(" "),_("h3",{attrs:{id:"nscondition"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nscondition"}},[a._v("#")]),a._v(" NSCondition")]),a._v(" "),_("h3",{attrs:{id:"nsconditionlock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsconditionlock"}},[a._v("#")]),a._v(" NSConditionLock")]),a._v(" "),_("h3",{attrs:{id:"nsrecursivelock"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsrecursivelock"}},[a._v("#")]),a._v(" NSRecursiveLock")]),a._v(" "),_("h3",{attrs:{id:"使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[a._v("#")]),a._v(" 使用场景")]),a._v(" "),_("ul",[_("li",[a._v("常规和 while 循环加锁使用 pthread_mutex。")]),a._v(" "),_("li",[a._v("队列（dispatch_get_global_queue）并发线程数控制，使用 dispatch_semaphore。")])]),a._v(" "),_("h3",{attrs:{id:"死锁的必要条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁的必要条件"}},[a._v("#")]),a._v(" 死锁的必要条件")]),a._v(" "),_("ul",[_("li",[a._v("互斥")]),a._v(" "),_("li",[a._v("不剥夺")]),a._v(" "),_("li",[a._v("循环等待")]),a._v(" "),_("li",[a._v("请求且保持")])]),a._v(" "),_("h3",{attrs:{id:"预防死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#预防死锁"}},[a._v("#")]),a._v(" 预防死锁")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("破坏不剥夺条件")]),a._v(" "),_("ul",[_("li",[a._v("在线程拿到资源后，如果再还需要再去申请新的资源无法申请到，那么就释放所有资源")])])]),a._v(" "),_("li",[_("p",[a._v("破坏请求且保持")]),a._v(" "),_("ul",[_("li",[a._v("一次性申请所有资源")])])]),a._v(" "),_("li",[_("p",[a._v("破坏循环等待条件")]),a._v(" "),_("ul",[_("li",[a._v("对资源进行排号，若线程获得序号高的资源想要再获取序号低的资源，就需要先释放序号高的资源")])])])]),a._v(" "),_("h3",{attrs:{id:"解锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解锁"}},[a._v("#")]),a._v(" 解锁")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("抢占资源")]),a._v(" "),_("ul",[_("li",[a._v("从一个或多个线程中抢占足够数量的资源，分配给死锁线程")])])]),a._v(" "),_("li",[_("p",[a._v("终止线程")]),a._v(" "),_("ul",[_("li",[a._v("将一个或多个死锁线程终止")])])])]),a._v(" "),_("h2",{attrs:{id:"swift指针"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#swift指针"}},[a._v("#")]),a._v(" Swift指针")]),a._v(" "),_("h3",{attrs:{id:"unsafepointer类似于const-pointee"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#unsafepointer类似于const-pointee"}},[a._v("#")]),a._v(" UnsafePointer"),_("Pointee",[a._v("类似于const Pointee *")])],1),a._v(" "),_("h3",{attrs:{id:"unsafemutablepointer类似于pointee"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#unsafemutablepointer类似于pointee"}},[a._v("#")]),a._v(" UnsafeMutablePointer"),_("Pointee",[a._v("类似于Pointee *")])],1),a._v(" "),_("h3",{attrs:{id:"unsaferawpointer类似于const-void"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#unsaferawpointer类似于const-void"}},[a._v("#")]),a._v(" UnsafeRawPointer类似于const void *")]),a._v(" "),_("h3",{attrs:{id:"unsafemutablerawpointer类似于void"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#unsafemutablerawpointer类似于void"}},[a._v("#")]),a._v(" UnsafeMutableRawPointer类似于void *")]),a._v(" "),_("h2",{attrs:{id:"urlsession"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#urlsession"}},[a._v("#")]),a._v(" URLSession")]),a._v(" "),_("h3",{attrs:{id:"大文件下载-存cache文件夹"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#大文件下载-存cache文件夹"}},[a._v("#")]),a._v(" 大文件下载，存cache文件夹")]),a._v(" "),_("ul",[_("li",[a._v("URLSessionDownloadTask")])]),a._v(" "),_("h3",{attrs:{id:"小文件下载-存内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#小文件下载-存内存"}},[a._v("#")]),a._v(" 小文件下载，存内存")]),a._v(" "),_("ul",[_("li",[a._v("URLSessionDataTask")])]),a._v(" "),_("h2",{attrs:{id:"runloop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#runloop"}},[a._v("#")]),a._v(" RunLoop")]),a._v(" "),_("h3",{attrs:{id:"内核态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内核态"}},[a._v("#")]),a._v(" 内核态")]),a._v(" "),_("ul",[_("li",[a._v("I/O指令、清内存、设置时钟")]),a._v(" "),_("li",[a._v("中断、异常、陷入")]),a._v(" "),_("li",[a._v("线程管理")]),a._v(" "),_("li",[a._v("系统调用")]),a._v(" "),_("li",[a._v("用户内存地址的转换(逻辑---\x3e物理映射)")])]),a._v(" "),_("h3",{attrs:{id:"source0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#source0"}},[a._v("#")]),a._v(" source0")]),a._v(" "),_("ul",[_("li",[a._v("UIEvent(触摸、滑动)、performSelector等等，需要手动触发")])]),a._v(" "),_("h3",{attrs:{id:"source1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#source1"}},[a._v("#")]),a._v(" source1")]),a._v(" "),_("ul",[_("li",[a._v("处理系统内核的mach_msg事件")])]),a._v(" "),_("h3",{attrs:{id:"runloop状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#runloop状态"}},[a._v("#")]),a._v(" RunLoop状态")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("kCFRunLoopEntry")]),a._v(" "),_("ul",[_("li",[a._v("准备启动RunLoop")])])]),a._v(" "),_("li",[_("p",[a._v("kCFRunLoopBeforeTimers")]),a._v(" "),_("ul",[_("li",[a._v("将要处理Timer")])])]),a._v(" "),_("li",[_("p",[a._v("kCFRunLoopBeforeSources")]),a._v(" "),_("ul",[_("li",[a._v("将要处理Sources")])])]),a._v(" "),_("li",[_("p",[a._v("KCFRunLoopBeforeWaiting")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("将要进入休眠")]),a._v(" "),_("ul",[_("li",[a._v("释放autorelease对象")]),a._v(" "),_("li",[a._v("图像的绘制")])])])])]),a._v(" "),_("li",[_("p",[a._v("KCFRunLoopAfterWaiting")]),a._v(" "),_("ul",[_("li",[a._v("将要唤醒")])])]),a._v(" "),_("li",[_("p",[a._v("KCFRunLoopExit")]),a._v(" "),_("ul",[_("li",[a._v("RunLoop将要退出")])])])]),a._v(" "),_("h3",{attrs:{id:"多个model"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多个model"}},[a._v("#")]),a._v(" 多个model")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("Source(输入源)")]),a._v(" "),_("ul",[_("li",[a._v("I/O事件")])])]),a._v(" "),_("li",[_("p",[a._v("Timer(定时源)")]),a._v(" "),_("ul",[_("li",[a._v("performSelector")])])]),a._v(" "),_("li",[_("p",[a._v("Observer")])])]),a._v(" "),_("h3",{attrs:{id:"一个线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一个线程"}},[a._v("#")]),a._v(" 一个线程")]),a._v(" "),_("h3",{attrs:{id:"退出机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#退出机制"}},[a._v("#")]),a._v(" 退出机制")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("移除input sources或者timer")]),a._v(" "),_("ul",[_("li",[a._v("并不能保证退出，系统可能会添加输入源")])])]),a._v(" "),_("li",[_("p",[a._v("设置超时时间或者添加一个定时源")])]),a._v(" "),_("li",[_("p",[a._v("强制退出线程")]),a._v(" "),_("ul",[_("li",[a._v("并不能让RunLoop，还可能会造成内存泄漏")])])]),a._v(" "),_("li",[_("p",[a._v("CFRunLoopStop")]),a._v(" "),_("ul",[_("li",[a._v("系统会重复调用runMode:beforeDate:所以也不能退出RunLoop")])])])]),a._v(" "),_("h2",{attrs:{id:"对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[a._v("#")]),a._v(" 对象")]),a._v(" "),_("h3",{attrs:{id:"用户创建的对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#用户创建的对象"}},[a._v("#")]),a._v(" 用户创建的对象")]),a._v(" "),_("ul",[_("li",[a._v("alloc")]),a._v(" "),_("li",[a._v("new")]),a._v(" "),_("li",[a._v("copy")]),a._v(" "),_("li",[a._v("mutableCopy")])]),a._v(" "),_("h3",{attrs:{id:"系统创建的对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统创建的对象"}},[a._v("#")]),a._v(" 系统创建的对象")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("[NSArray array]/[NSMutableArray array]")]),a._v(" "),_("ul",[_("li",[_("ul",[_("li",[_("p",[a._v("(id) array {//系统内部的MRC实现\nreturn [[[NSMutableArray alloc] init] autorelease];\n}")]),a._v(" "),_("ul",[_("li",[a._v("在MRC下，我们在return一个对象时，通常要使用autorelease进行释放，如果我们要保留array返回的对象不进行释放，那么需要retain操作，显然这种情况下即调用autorelease又调用retain有点多余，所以在ARC下系统为我们做了优化")])])])])]),a._v(" "),_("li",[_("ul",[_("li",[_("p",[a._v("(id) array {//系统内部的ARC实现\nNSMutableArray *arr = [[NSMutableArray alloc] init];\nobjc_autoreleaseReturnValue(arr);\n}")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("在ARC下，对象的赋值操作默认是strong(保留)，如果在array当中直接调用autorelease，那么在赋值时又要调用retain，非常多余，所以有了objc_autoreleaseReturnValue，这个函数的作用是如果返回值被强引用，即需要retain，那么不调用autorelease，而是设置全局数据结构中的标志位，如果返回值被弱引用(即不需要retain)，那么将调用autorelease，在一个事件循环后释放。")]),a._v(" "),_("ul",[_("li",[a._v("向后兼容")])])]),a._v(" "),_("li",[_("p",[a._v("如果恰好返回值被弱引用(即返回值包含autorelease)，此时我们如果再需要进行强引用会直接retain吗？显然直接retain会影响效率，系统会去检测标志位，若标志位已经置位，则直接返回对象，否则进行retain操作")])])])])])])])]),a._v(" "),_("li",[_("p",[a._v("[NSDictionary dict]/[NSMutableDictionary dict]")])]),a._v(" "),_("li",[_("p",[a._v("...")])])]),a._v(" "),_("h2",{attrs:{id:"autoreleasepool"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepool"}},[a._v("#")]),a._v(" autoreleasePool")]),a._v(" "),_("h3",{attrs:{id:"哪些对象会被注册到autoreleasepool"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哪些对象会被注册到autoreleasepool"}},[a._v("#")]),a._v(" 哪些对象会被注册到autoreleasePool？")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("系统创建的对象")])]),a._v(" "),_("li",[_("p",[a._v("__autoreleasing对象")])]),a._v(" "),_("li",[_("p",[a._v("访问附有__weak修饰符的变量时，实际上必定要访问注册到Autoreleasepool的对象，即会自动加入Autoreleasepool")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("如何理解？")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("其实__weak变量的底层就是autorelease，所以也会被加入到autoreleasePool，这里可以引申出一个细节问题，在block中使用weakSelf时，如果需要延长self的使用寿命是否需要strongSelf？如果是同一个线程那么不需要strongSelf也能保证block中的weakSelf执行完毕，如果是多线程那么必须要在block中strongSelf才能保证block中的self执行完毕，分析一下")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("block单线程执行")]),a._v(" "),_("ul",[_("li",[a._v("如果是单线程执行block，那么必然在初始化weakSelf时，self是没有被释放的，不然也没有在block中调用的意义，我们知道weak变量是通过autorelease进行释放的，所以如果是单线程，那么在block执行完之前，runloop不会进入休眠，此时weakSelf也不会被释放，所以可以保证block中的weakSelf不为nil")])])]),a._v(" "),_("li",[_("p",[a._v("block多线程执行")]),a._v(" "),_("ul",[_("li",[a._v("多线程执行block时，如果原对象被释放，恰好runloop即将进入休眠时，weakSelf可能已经为nil，如果要保证block中self不为nil，则必须在block初始化(即block内部调用strong)时进行一次strong操作")])])])])])])])])]),a._v(" "),_("li",[_("p",[a._v("id指针会默认附加__autoreleasing")]),a._v(" "),_("ul",[_("li",[a._v("经过验证这句话是错的，后续再验证")])])]),a._v(" "),_("li",[_("p",[a._v("指向对象的指针(即双指针id *, NSError **)也会默认附加__autoreleasing")]),a._v(" "),_("ul",[_("li",[a._v("未验证")])])])]),a._v(" "),_("h3",{attrs:{id:"每一个-autoreleasepool-都会在左花括号时创建autoreleasepoolpush-并在右花括号时调用autoreleasepoolpop进行释放-主线程的autoreleasepool总是在创建和销毁-这是因为runloop的存在"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#每一个-autoreleasepool-都会在左花括号时创建autoreleasepoolpush-并在右花括号时调用autoreleasepoolpop进行释放-主线程的autoreleasepool总是在创建和销毁-这是因为runloop的存在"}},[a._v("#")]),a._v(" 每一个@autoreleasePool{}都会在左花括号时创建autoreleasePoolPush，并在右花括号时调用autoreleasePoolPop进行释放，主线程的autoreleasePool总是在创建和销毁，这是因为runloop的存在")]),a._v(" "),_("h3",{attrs:{id:"主线程和gcd"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主线程和gcd"}},[a._v("#")]),a._v(" 主线程和GCD")]),a._v(" "),_("ul",[_("li",[a._v("主线程会注册两个observer，第一个observer监视runloop的entry(entry只会调用一次)，用来创建第一个自动释放池，并将其优先级设置为最高。第二个observer监视BeforeWaiting(即将进入休眠)，此时释放旧池创建新池(第二个observer第一次释放的旧池是第一个observer创建的)，并将第二个observer的优先级设置为最低以保证释放尺子发生在其他所有回调之后，往后依次重复该行为。")])]),a._v(" "),_("h3",{attrs:{id:"nsoperation-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsoperation-2"}},[a._v("#")]),a._v(" NSOperation")]),a._v(" "),_("ul",[_("li",[a._v("NSOperation的start方法中已经创建了autoreleasePool，如果重写start方法则需要创建自己的autoreleasePool")])]),a._v(" "),_("h3",{attrs:{id:"nsthread-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsthread-2"}},[a._v("#")]),a._v(" NSThread")]),a._v(" "),_("ul",[_("li",[a._v("会在init当中创建autoreleasePool")])]),a._v(" "),_("h3",{attrs:{id:"每一个autoreleasepool是由autoreleasepoolpage组成的双向链表-通过autorelease操作将对象插入到链表当中-在pop时对其中的所有对象进行一次release操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#每一个autoreleasepool是由autoreleasepoolpage组成的双向链表-通过autorelease操作将对象插入到链表当中-在pop时对其中的所有对象进行一次release操作"}},[a._v("#")]),a._v(" 每一个autoreleasePool是由AutoreleasePoolPage组成的双向链表，通过autorelease操作将对象插入到链表当中，在pop时对其中的所有对象进行一次release操作")]),a._v(" "),_("h3",{attrs:{id:"如果没有其他事件阻止runloop进入休眠-那么在viewwillappear时runloop还未进入休眠-此时autorelease对象还未被释放-在viewdidappear时runloop即将进入休眠-此时autorelease对象在调用viewdidappear前已经被系统的observer释放"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果没有其他事件阻止runloop进入休眠-那么在viewwillappear时runloop还未进入休眠-此时autorelease对象还未被释放-在viewdidappear时runloop即将进入休眠-此时autorelease对象在调用viewdidappear前已经被系统的observer释放"}},[a._v("#")]),a._v(" 如果没有其他事件阻止runloop进入休眠，那么在viewWillAppear时runloop还未进入休眠，此时autorelease对象还未被释放，在viewDidAppear时runloop即将进入休眠，此时autorelease对象在调用viewDidAppear前已经被系统的observer释放")]),a._v(" "),_("h3",{attrs:{id:"main函数的autoreleasepool和主线程的autoreleasepool是否是同一个"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#main函数的autoreleasepool和主线程的autoreleasepool是否是同一个"}},[a._v("#")]),a._v(" main函数的autoreleasepool和主线程的autoreleasepool是否是同一个？")]),a._v(" "),_("ul",[_("li",[a._v("应该不是，main函数的autoreleasepool应该是对系统资源的释放，而主线程的autoreleasepool是动态创建和销毁的")])]),a._v(" "),_("h3",{attrs:{id:"如果子线程没有创建runloop-那么autorelease对象何时释放"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果子线程没有创建runloop-那么autorelease对象何时释放"}},[a._v("#")]),a._v(" 如果子线程没有创建runloop，那么autorelease对象何时释放？")]),a._v(" "),_("ul",[_("li",[a._v("这句话本身就是错误的，autoreleasePool的释放和runloop没有任何关系，只是我们可以监听runloop的状态来调用drain方法")])]),a._v(" "),_("h3",{attrs:{id:"主线程的autoreleasepool是每次执行事件循环时-系统监听并自动释放-子线程如果创建autoreleasepool-系统也会自动创建监听吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主线程的autoreleasepool是每次执行事件循环时-系统监听并自动释放-子线程如果创建autoreleasepool-系统也会自动创建监听吗"}},[a._v("#")]),a._v(" 主线程的autoreleasepool是每次执行事件循环时，系统监听并自动释放，子线程如果创建autoreleasepool，系统也会自动创建监听吗？")]),a._v(" "),_("ul",[_("li",[a._v("子线程不会监听，因为子线程的runloop本身就不会自动开启，都是每次drain时释放")])]),a._v(" "),_("h3",{attrs:{id:"autoreleasepool为何能降低for循环的内存峰值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#autoreleasepool为何能降低for循环的内存峰值"}},[a._v("#")]),a._v(" autoreleasePool为何能降低for循环的内存峰值？")]),a._v(" "),_("ul",[_("li",[a._v("如果在for循环当中使用非用户创建的对象或者__autoreleasing对象，那么这些对象将在runloop即将进入休眠时才释放，这会造成内存瞬时峰值，所以想要降低峰值，我们可以在for循环当中使用@autoreleasePool，以便在每次循环时就释放对象，而不需要等待runloop休眠时才释放")])]),a._v(" "),_("h3",{attrs:{id:"底层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#底层"}},[a._v("#")]),a._v(" 底层")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("1.objc_autoreleasePoolPush()")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("AutoreleasePoolPage::push();")]),a._v(" "),_("ul",[_("li",[a._v("返回哨兵对象")])])])])]),a._v(" "),_("li",[_("p",[a._v("2.atautoreleasepoolobj;")]),a._v(" "),_("ul",[_("li",[a._v("哨兵对象")])])]),a._v(" "),_("li",[_("p",[a._v("3.objc_autoreleasePoolPop()")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("AutoreleasePoolPage::pop(ctxt);")]),a._v(" "),_("ul",[_("li",[a._v("根据哨兵对象，将哨兵对象之后的所有page内的autorelease对象全部release")])])])])]),a._v(" "),_("li",[_("p",[a._v("AutoreleasePoolPage")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("每页空间为4096字节")]),a._v(" "),_("ul",[_("li",[a._v("每页最多存储(4096-56)/8 = 505个对象，第一页因为有哨兵对象(即atautoreleasepoolobj对象)，所以第一页只能存储504个对象")])])]),a._v(" "),_("li",[_("p",[a._v("next")]),a._v(" "),_("ul",[_("li",[a._v("指向下次新添加的autorelease对象的位置(即指向还未存储的位置)")])])]),a._v(" "),_("li",[_("p",[a._v("parent")]),a._v(" "),_("ul",[_("li",[a._v("指向上一页")])])]),a._v(" "),_("li",[_("p",[a._v("child")]),a._v(" "),_("ul",[_("li",[a._v("指向下一页")])])]),a._v(" "),_("li",[_("p",[a._v("每个page自身占用56个字节")])])])]),a._v(" "),_("li",[_("p",[a._v("autoreleasePool")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("AutoreleasePoolPage")]),a._v(" "),_("ul",[_("li",[a._v("只有第一个page有哨兵指针")])])]),a._v(" "),_("li",[_("p",[a._v("AutoreleasePoolPage")])]),a._v(" "),_("li",[_("p",[a._v("AutoreleasePoolPage")])]),a._v(" "),_("li",[_("p",[a._v("...")])])])])]),a._v(" "),_("h2",{attrs:{id:"对象释放时机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象释放时机"}},[a._v("#")]),a._v(" 对象释放时机")]),a._v(" "),_("h3",{attrs:{id:"局部变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#局部变量"}},[a._v("#")]),a._v(" 局部变量")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("自己创建的对象")]),a._v(" "),_("ul",[_("li",[a._v("作用域结束即释放")])])]),a._v(" "),_("li",[_("p",[a._v("系统创建的对象")]),a._v(" "),_("ul",[_("li",[a._v("在下一个事件循环时释放(autorelease)")])])]),a._v(" "),_("li",[_("p",[a._v("自己创建的__autoreleasing对象")]),a._v(" "),_("ul",[_("li",[a._v("在下一个事件循环时释放(autorelease)")])])])]),a._v(" "),_("h3",{attrs:{id:"成员变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#成员变量"}},[a._v("#")]),a._v(" 成员变量")]),a._v(" "),_("ul",[_("li",[a._v("dealloc时释放")])]),a._v(" "),_("h3",{attrs:{id:"malloc对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#malloc对象"}},[a._v("#")]),a._v(" malloc对象")]),a._v(" "),_("ul",[_("li",[a._v("需要调用free释放")])]),a._v(" "),_("h2",{attrs:{id:"ui响应链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ui响应链"}},[a._v("#")]),a._v(" UI响应链")]),a._v(" "),_("h3",{attrs:{id:"事件传递"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事件传递"}},[a._v("#")]),a._v(" 事件传递")]),a._v(" "),_("ul",[_("li",[_("ul",[_("li",[a._v("(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\nif (self.hidden || !self.userInteractionEnabled || self.alpha < 0.01 || ![self pointInside:point withEvent:event]) {\nreturn nil;\n} else {\nfor (UIView *subview in [self.subviews reverseObjectEnumerator]) {\nUIView *hitView = [subview hitTest:[subview convertPoint:point fromView:self] withEvent:event];\nif (hitView) {\nreturn hitView;\n}\n}\n}\nreturn self;\n}//系统内部实现机制")])])]),a._v(" "),_("li",[_("p",[a._v("(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event {\nreturn YES;\n}")]),a._v(" "),_("ul",[_("li",[a._v("hitTest用来查找在点击范围内最上层的view，查找到view之后就要判断是否能响应点击事件，如果查找到的view不能响应该事件，那么就会交给nextResponder进行响应，一层一层传递，直到AppDelegate，如果最后无人能响应事件，那么丢弃该事件")])])]),a._v(" "),_("li",[_("p",[a._v("通过逐层遍历子视图找到范围内的view(UIView/UIWindow)")])])]),a._v(" "),_("h3",{attrs:{id:"事件响应"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事件响应"}},[a._v("#")]),a._v(" 事件响应")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("事件响应对象可以是AppDelegate/UIApplication/UIWindow/UIViewController/UIView")])]),a._v(" "),_("li",[_("p",[a._v("在view或者UIViewController被添加到其他对象当中时，会自动指定nextResponder指针")])]),a._v(" "),_("li",[_("p",[a._v("找到View后，如果当前view不能处理事件，就通过nextResponder指针向父view或者父VC传递，注意self.view的nextResponder是VC，而VC的nextResponder是self.view的superview，直到找到一个能响应事件的对象为止，找到能响应事件的对象后，就将事件交给该对象处理。")])]),a._v(" "),_("li",[_("p",[a._v("默认情况下普通的UIView都不能响应事件，系统内部只是将事件交给下一响应者，对于UIButton，就不是直接交给下一响应者了，而是实现其内部方法，因为Button能响应事件。")]),a._v(" "),_("ul",[_("li",[_("ul",[_("li",[a._v("(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event\n{\n[[self nextResponder] touchesBegan:touches withEvent:event];\n}//这是系统内部实现机制，系统会直接调用这个方法，注意这不是代理方法，是给系统调用的")])])])])])]),a._v(" "),_("h2",{attrs:{id:"组件化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[a._v("#")]),a._v(" 组件化")]),a._v(" "),_("h3",{attrs:{id:"url-block方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#url-block方式"}},[a._v("#")]),a._v(" url-block方式")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("1.即启动时注册组件，将url和block对应，保存到内存当中")])]),a._v(" "),_("li",[_("p",[a._v("2.调用时，通过url查找对应的block进行调用")])]),a._v(" "),_("li",[_("p",[a._v("缺点")]),a._v(" "),_("ul",[_("li",[a._v("组件多了可能会有内存问题")]),a._v(" "),_("li",[a._v("url无法传递非常规参数，例如UIImage、NSData")])])])]),a._v(" "),_("h3",{attrs:{id:"protocol-class方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#protocol-class方式"}},[a._v("#")]),a._v(" protocol-class方式")]),a._v(" "),_("ul",[_("li",[a._v("1.启动时注册类和协议，将类和协议一一对应保存到内存当中")]),a._v(" "),_("li",[a._v("2.调用时，根据协议查找对应的类和方法，实际上此方法和url-block类似，只是不同的封装而已，和url-block不同的是，这种方式可以自由传递各种类型的参数")])]),a._v(" "),_("h3",{attrs:{id:"target-action方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#target-action方式"}},[a._v("#")]),a._v(" target-action方式")]),a._v(" "),_("ul",[_("li",[a._v("0.假如A组件需要调用B组件")]),a._v(" "),_("li",[a._v("1.通过中间件的单例进行调用封装B组件的category(中间件的category)中的方法")]),a._v(" "),_("li",[a._v("2.类名以及方法名写在category当中")]),a._v(" "),_("li",[a._v("3.中间件拿到类名和方法名后进行动态调用")]),a._v(" "),_("li",[a._v("4.对于一些频繁的调用，我们可以存到中间件的单例当中以便下次继续调用")])]),a._v(" "),_("h2",{attrs:{id:"oc消息转发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oc消息转发"}},[a._v("#")]),a._v(" OC消息转发")]),a._v(" "),_("h3",{attrs:{id:"resolveinstancemethod"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#resolveinstancemethod"}},[a._v("#")]),a._v(" resolveInstanceMethod")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("返回值为YES")]),a._v(" "),_("ul",[_("li",[a._v("打印成功的信息")])])]),a._v(" "),_("li",[_("p",[a._v("返回值为NO")]),a._v(" "),_("ul",[_("li",[a._v("打印失败的信息")])])]),a._v(" "),_("li",[_("p",[a._v("无论我们设置返回值为YES还是NO均可以，只会影响打印结果，不会有任何异常，而且无论设置YES还是NO，系统都会再次查找缓存，当缓存中有时，停止消息转发，当缓存中没有该方法时，进行下一步。所以我们可以在resolveInstanceMethod当中动态添加方法的实现，系统查找到动态方法后，会停止消息转发")])])]),a._v(" "),_("h3",{attrs:{id:"forwardingtargetforselector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#forwardingtargetforselector"}},[a._v("#")]),a._v(" forwardingTargetForSelector")]),a._v(" "),_("ul",[_("li",[a._v("设置接收消息的对象，如果为nil，则去获取方法签名")])]),a._v(" "),_("h3",{attrs:{id:"methodsignatureforselector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#methodsignatureforselector"}},[a._v("#")]),a._v(" methodSignatureForSelector")]),a._v(" "),_("ul",[_("li",[a._v("设置方法签名")])]),a._v(" "),_("h3",{attrs:{id:"forwardinvocation-nsinvocation-aninvocation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#forwardinvocation-nsinvocation-aninvocation"}},[a._v("#")]),a._v(" forwardInvocation:(NSInvocation *)anInvocation")]),a._v(" "),_("ul",[_("li",[a._v("调用anInvocation的invoke")])]),a._v(" "),_("h3",{attrs:{id:"doesnotrecognizeselector"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#doesnotrecognizeselector"}},[a._v("#")]),a._v(" doesNotRecognizeSelector")]),a._v(" "),_("ul",[_("li",[a._v("未找到方法的实现，程序崩溃")])]),a._v(" "),_("h2",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[a._v("#")]),a._v(" 设计模式")]),a._v(" "),_("h3",{attrs:{id:"单例模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[a._v("#")]),a._v(" 单例模式")]),a._v(" "),_("h3",{attrs:{id:"工厂模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[a._v("#")]),a._v(" 工厂模式")]),a._v(" "),_("ul",[_("li",[a._v("NSArray")])]),a._v(" "),_("h3",{attrs:{id:"适配器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[a._v("#")]),a._v(" 适配器模式")]),a._v(" "),_("ul",[_("li",[a._v("例如[super viewdidLoad]")])]),a._v(" "),_("h3",{attrs:{id:"桥接模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#桥接模式"}},[a._v("#")]),a._v(" 桥接模式")]),a._v(" "),_("ul",[_("li",[a._v("子类重写父类方法，父类不需要实现")])]),a._v(" "),_("h3",{attrs:{id:"外观模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#外观模式"}},[a._v("#")]),a._v(" 外观模式")]),a._v(" "),_("ul",[_("li",[a._v("统一的访问接口")])]),a._v(" "),_("h3",{attrs:{id:"中介者"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#中介者"}},[a._v("#")]),a._v(" 中介者")]),a._v(" "),_("ul",[_("li",[a._v("组件化")])]),a._v(" "),_("h3",{attrs:{id:"观察者"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#观察者"}},[a._v("#")]),a._v(" 观察者")]),a._v(" "),_("h3",{attrs:{id:"迭代器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[a._v("#")]),a._v(" 迭代器")]),a._v(" "),_("h3",{attrs:{id:"装饰模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#装饰模式"}},[a._v("#")]),a._v(" 装饰模式")]),a._v(" "),_("ul",[_("li",[a._v("Category")])]),a._v(" "),_("h3",{attrs:{id:"责任链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#责任链"}},[a._v("#")]),a._v(" 责任链")]),a._v(" "),_("ul",[_("li",[a._v("UI响应链")])]),a._v(" "),_("h3",{attrs:{id:"模板方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模板方法"}},[a._v("#")]),a._v(" 模板方法")]),a._v(" "),_("ul",[_("li",[a._v("drawRect")])]),a._v(" "),_("h3",{attrs:{id:"策略模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#策略模式"}},[a._v("#")]),a._v(" 策略模式")]),a._v(" "),_("ul",[_("li",[a._v("例如验证UITextField是邮箱还是密码，将算法封装")])]),a._v(" "),_("h3",{attrs:{id:"命令模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#命令模式"}},[a._v("#")]),a._v(" 命令模式")]),a._v(" "),_("ul",[_("li",[a._v("NSInvocation")])]),a._v(" "),_("h3",{attrs:{id:"代理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代理"}},[a._v("#")]),a._v(" 代理")]),a._v(" "),_("h2",{attrs:{id:"第三方库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三方库"}},[a._v("#")]),a._v(" 第三方库")]),a._v(" "),_("h3",{attrs:{id:"afnetworking"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#afnetworking"}},[a._v("#")]),a._v(" AFNetworking")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("模块")]),a._v(" "),_("ul",[_("li",[a._v("会话")]),a._v(" "),_("li",[a._v("网络监听模块")]),a._v(" "),_("li",[a._v("网络安全模块")]),a._v(" "),_("li",[a._v("请求序列化")]),a._v(" "),_("li",[a._v("响应序列化")]),a._v(" "),_("li",[a._v("UIKit集成模块")])])])]),a._v(" "),_("h2",{attrs:{id:"load和initialize"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#load和initialize"}},[a._v("#")]),a._v(" load和initialize")]),a._v(" "),_("h3",{attrs:{id:"load"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#load"}},[a._v("#")]),a._v(" load")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("在runtime加载类或者分类时调用")])]),a._v(" "),_("li",[_("p",[a._v("每个类的load有且只会调用一次")])]),a._v(" "),_("li",[_("p",[a._v("先调用父类的load、再调用子类的load、最后调用分类的load")])]),a._v(" "),_("li",[_("p",[a._v("不会被子类或者分类覆盖，必执行")])]),a._v(" "),_("li",[_("p",[a._v("使用")]),a._v(" "),_("ul",[_("li",[a._v("hook")]),a._v(" "),_("li",[a._v("组件化通信")])])])]),a._v(" "),_("h3",{attrs:{id:"initialize"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#initialize"}},[a._v("#")]),a._v(" initialize")]),a._v(" "),_("ul",[_("li",[a._v("在类第一次接收到消息时调用(任何消息)")]),a._v(" "),_("li",[a._v("在子类没有覆写initialize时，父类的initialize可能会调用多次")]),a._v(" "),_("li",[a._v("基于objc_msgSend，分类会覆盖原类的initialize，但不会覆盖原类的父类的initialize")]),a._v(" "),_("li",[a._v("可以被分类覆盖")])]),a._v(" "),_("h2",{attrs:{id:"组件化-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#组件化-2"}},[a._v("#")]),a._v(" 组件化")]),a._v(" "),_("h3",{attrs:{id:"方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方案"}},[a._v("#")]),a._v(" 方案")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("项目的业务线超过2条以上，需要独立拆分")])]),a._v(" "),_("li",[_("p",[a._v("项目人员太多，防止对同一块代码修改")])]),a._v(" "),_("li",[_("p",[a._v("url-block")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("启动时注册组件提供的服务")])]),a._v(" "),_("li",[_("p",[a._v("通过url进行通信")])]),a._v(" "),_("li",[_("p",[a._v("步骤")]),a._v(" "),_("ul",[_("li",[a._v("app启动时register服务url-block")]),a._v(" "),_("li",[a._v("通过openURL执行block")])])]),a._v(" "),_("li",[_("p",[a._v("缺点")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("依赖中间件")]),a._v(" "),_("ul",[_("li",[a._v("如果组件越多，那么中间件就越复杂")])])]),a._v(" "),_("li",[_("p",[a._v("内存需要维护映射表")])]),a._v(" "),_("li",[_("p",[a._v("组件分散注册")])]),a._v(" "),_("li",[_("p",[a._v("参数传递限制")])])])])])]),a._v(" "),_("li",[_("p",[a._v("protocol-class")]),a._v(" "),_("ul",[_("li",[a._v("启动时将protocol-class注册到单例当中")]),a._v(" "),_("li",[a._v("openprotocol时，可以对注册协议的组件发送消息，实现各种类型数据的传递")]),a._v(" "),_("li",[a._v("缺点和url-block类似，不过可以发送更多类型的数据")])])]),a._v(" "),_("li",[_("p",[a._v("url-controller")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("启动时对每个组件创建一个单例类型的connector，注册到总线单例当中")])]),a._v(" "),_("li",[_("p",[a._v("通过openurl传递url和参数，去总线当中查找connector，找到connctor后，动态生成相应的页面，传递参数，发送消息")])]),a._v(" "),_("li",[_("p",[a._v("优点")]),a._v(" "),_("ul",[_("li",[a._v("可以解决url-block占用内存的问题")]),a._v(" "),_("li",[a._v("解决了参数传递的问题")])])]),a._v(" "),_("li",[_("p",[a._v("缺点")]),a._v(" "),_("ul",[_("li",[a._v("组件会依赖connector，所以依旧会有依赖中间件的问题")])])])])]),a._v(" "),_("li",[_("p",[a._v("target-action")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("首先组件将需要对外暴露的功能进行一层封装，就是target，所以不会对组件有入侵")])]),a._v(" "),_("li",[_("p",[a._v("调用者通常只需要依赖中间件，而中间件又是通过runtime来调用组件服务，所以使得两个组件间进行了解耦。")])]),a._v(" "),_("li",[_("p",[a._v("虽然调用者依赖中间件，但是代码不是侵入式的，我们可以对中间件采用装饰者设计模式为调用者提供服务")])]),a._v(" "),_("li",[_("p",[a._v("缺点")]),a._v(" "),_("ul",[_("li",[a._v("代码量比较大")]),a._v(" "),_("li",[a._v("基于通用性以及高内聚的原则，可能还要去model化")])])])])])]),a._v(" "),_("h3",{attrs:{id:"实施"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实施"}},[a._v("#")]),a._v(" 实施")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("壳工程")])]),a._v(" "),_("li",[_("p",[a._v("第三方库以及公共库组件")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("公共组件")]),a._v(" "),_("ul",[_("li",[a._v("埋点组件")]),a._v(" "),_("li",[a._v("工具组件")]),a._v(" "),_("li",[a._v("性能监控组件")]),a._v(" "),_("li",[a._v("定位组件")]),a._v(" "),_("li",[a._v("图片处理组件")]),a._v(" "),_("li",[a._v("UIKit封装及扩展组件")]),a._v(" "),_("li",[a._v("业务生命周期及通信组件")])])]),a._v(" "),_("li",[_("p",[a._v("网络组件")]),a._v(" "),_("ul",[_("li",[a._v("基于AFNetworking进行封装，提供json转model、缓存功能")]),a._v(" "),_("li",[a._v("DNS加速组件")])])]),a._v(" "),_("li",[_("p",[a._v("持久化组件")]),a._v(" "),_("ul",[_("li",[a._v("FMDB进行封装组件")])])]),a._v(" "),_("li",[_("p",[a._v("第三方业务组件")]),a._v(" "),_("ul",[_("li",[a._v("分享组件")]),a._v(" "),_("li",[a._v("推送组件")])])])])]),a._v(" "),_("li",[_("p",[a._v("独立业务组件")]),a._v(" "),_("ul",[_("li",[a._v("User组件，保存用户信息，登录，登出状态")]),a._v(" "),_("li",[a._v("各种业务组件")])])])]),a._v(" "),_("h2",{attrs:{id:"内存管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[a._v("#")]),a._v(" 内存管理")]),a._v(" "),_("h3",{attrs:{id:"栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[a._v("#")]),a._v(" 栈")]),a._v(" "),_("ul",[_("li",[a._v("指针通常在栈内存")])]),a._v(" "),_("h3",{attrs:{id:"堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[a._v("#")]),a._v(" 堆")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("方式")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("arc")])]),a._v(" "),_("li",[_("p",[a._v("mrc")]),a._v(" "),_("ul",[_("li",[a._v("release操作实际上就是将指针内的引用计数-1，当引用计数为0时，释放对象")])])]),a._v(" "),_("li",[_("p",[a._v("autoreleasepool")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("autorelease操作不会改变引用计数，是将对象加入autoreleasePool，在pool释放时进行release操作")]),a._v(" "),_("ul",[_("li",[a._v("instancetype")])])])])])])]),a._v(" "),_("li",[_("p",[a._v("实例")]),a._v(" "),_("ul",[_("li",[a._v("NSTaggedPointerString")]),a._v(" "),_("li",[a._v("NSCFString")])])]),a._v(" "),_("li",[_("p",[a._v("对象通常在堆内存创建")]),a._v(" "),_("ul",[_("li",[a._v("如果有指针指向堆内存对象，那么指针当中的某些标记位会标记引用计数，如果引用计数为0，那么对象会被释放，但是指针不一定会置为nil，通常可以手动置为nil，也可以等待栈的返回(即超出作用域)")])])])]),a._v(" "),_("h3",{attrs:{id:"全局-静态存储区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#全局-静态存储区"}},[a._v("#")]),a._v(" 全局/静态存储区")]),a._v(" "),_("ul",[_("li",[a._v("static指针/static基本类型的数据")])]),a._v(" "),_("h3",{attrs:{id:"常量区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常量区"}},[a._v("#")]),a._v(" 常量区")]),a._v(" "),_("ul",[_("li",[a._v("NSCFConstantString")])]),a._v(" "),_("h3",{attrs:{id:"代码区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代码区"}},[a._v("#")]),a._v(" 代码区")]),a._v(" "),_("h2",{attrs:{id:"客户端整体架构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#客户端整体架构"}},[a._v("#")]),a._v(" 客户端整体架构")]),a._v(" "),_("h3",{attrs:{id:"独立于app的通用层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#独立于app的通用层"}},[a._v("#")]),a._v(" 独立于App的通用层")]),a._v(" "),_("ul",[_("li",[a._v("页面的时长统计")]),a._v(" "),_("li",[a._v("崩溃统计")]),a._v(" "),_("li",[a._v("网络等第三方库")])]),a._v(" "),_("h3",{attrs:{id:"通用业务层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通用业务层"}},[a._v("#")]),a._v(" 通用业务层")]),a._v(" "),_("ul",[_("li",[a._v("公司通用的业务组件，比如某种按钮、某些界面的封装")])]),a._v(" "),_("h3",{attrs:{id:"中间层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#中间层"}},[a._v("#")]),a._v(" 中间层")]),a._v(" "),_("ul",[_("li",[a._v("协调和解耦的作用")])]),a._v(" "),_("h3",{attrs:{id:"业务层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#业务层"}},[a._v("#")]),a._v(" 业务层")]),a._v(" "),_("ul",[_("li",[a._v("业务A、B、C等等")])]),a._v(" "),_("h2",{attrs:{id:"野指针"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#野指针"}},[a._v("#")]),a._v(" 野指针")]),a._v(" "),_("p",[a._v("指针指向的对象被释放，但是指针未置为nil")]),a._v(" "),_("h3",{attrs:{id:"产生原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#产生原因"}},[a._v("#")]),a._v(" 产生原因")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("assign/__unsafe_unretained")]),a._v(" "),_("ul",[_("li",[a._v("assign指针不会增加对象的引用计数，但是在原对象引用计数为0被释放后，该指针依旧指向对象的内存地址，当再通过assign指针访问对象的属性或者方法时，可能会崩溃，也可能不会崩溃，崩溃是因为对象的内存释放后，该块内存地址被其他对象覆写，通过指针访问不到相应的属性或者方法。不会崩溃是因为如果内存没被覆写，依旧可以通过assign指针进行访问")])])]),a._v(" "),_("li",[_("p",[a._v("访问被释放的block")])]),a._v(" "),_("li",[_("p",[a._v("向已经释放的对象发送消息可能崩溃，也可能不崩溃，如果被释放的对象所占用的内存还未被其他对象覆写，那么可能不会发生崩溃，即使被其他对象覆写，如果其他对象也有同样的方法，也可能不会崩溃，而且会得不到自己想要的值，这种不安全的访问，我们怎么才能通过调试去发现呢？系统为我们提供了工具进行调试")])])]),a._v(" "),_("h3",{attrs:{id:"定位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定位"}},[a._v("#")]),a._v(" 定位")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("用户层")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("采集用户的辅助信息")]),a._v(" "),_("ul",[_("li",[a._v("采集设备信息，用户行为等等以便重现问题")])])])])]),a._v(" "),_("li",[_("p",[a._v("调试层")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("Zombie Object")]),a._v(" "),_("ul",[_("li",[a._v("打开僵尸对象调试以后，被释放的对象内存不会被覆写，但是我们也无法成功调用该内存的方法，因为僵尸对象会直接抛异常。")])])]),a._v(" "),_("li",[_("p",[a._v("Malloc Scribble")]),a._v(" "),_("ul",[_("li",[a._v("对已经释放的内存进行数据填充，从而保证野指针访问是必然崩溃的")])])])])])]),a._v(" "),_("h2",{attrs:{id:"oom判定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oom判定"}},[a._v("#")]),a._v(" OOM判定")]),a._v(" "),_("h3",{attrs:{id:"排除法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#排除法"}},[a._v("#")]),a._v(" 排除法")]),a._v(" "),_("ul",[_("li",[a._v("是否是debug")]),a._v(" "),_("li",[a._v("是否是普通的crash")]),a._v(" "),_("li",[a._v("是否是主动退出")]),a._v(" "),_("li",[a._v("是否调用了exit")]),a._v(" "),_("li",[a._v("是否是watchDog杀死")])]),a._v(" "),_("h3",{attrs:{id:"为何使用排除法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为何使用排除法"}},[a._v("#")]),a._v(" 为何使用排除法？")]),a._v(" "),_("ul",[_("li",[a._v("因为当发生OOM时，memory warning方法可能未调用，因为恰好此时主线程在忙于其他事情，导致可能没经历过memory warning就发生OOM")])]),a._v(" "),_("h2",{attrs:{id:"防止crash"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#防止crash"}},[a._v("#")]),a._v(" 防止crash")]),a._v(" "),_("h3",{attrs:{id:"signal"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#signal"}},[a._v("#")]),a._v(" Signal")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("案例")]),a._v(" "),_("ul",[_("li",[a._v("野指针")]),a._v(" "),_("li",[a._v("释放不存在的内存空间")])])]),a._v(" "),_("li",[_("p",[a._v("防止crash")]),a._v(" "),_("ul",[_("li",[a._v("捕获信号后进行忽略")])])]),a._v(" "),_("li",[_("p",[a._v("抓取")]),a._v(" "),_("ul",[_("li",[a._v("捕获后获取线程调用栈，上传服务器")])])])]),a._v(" "),_("h3",{attrs:{id:"nsexception"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsexception"}},[a._v("#")]),a._v(" NSException")]),a._v(" "),_("p",[a._v("应用级异常，它是未被捕获的Objective-C异常，导致程序向自身发送了SIGABRT信号而崩溃，对于未捕获的Objective-C异常，是可以通过try catch来捕获的，或者通过NSSetUncaughtExceptionHandler()机制来捕获。")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("案例")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("unrecognized selector sent to instance")]),a._v(" "),_("ul",[_("li",[a._v("采用消息转发")])])]),a._v(" "),_("li",[_("p",[a._v("KVC的key为nil")]),a._v(" "),_("ul",[_("li",[a._v("对setValue:forKey:进行拦截")])])]),a._v(" "),_("li",[_("p",[a._v("未移除KVO")])]),a._v(" "),_("li",[_("p",[a._v("NSArray/NSMutableArray")]),a._v(" "),_("ul",[_("li",[a._v("初始化或插入nil")])])]),a._v(" "),_("li",[_("p",[a._v("NSNotificationCenter")]),a._v(" "),_("ul",[_("li",[a._v("未移除通知中心本身不会crash，但是如果对象被释放了，接收到通知可能会崩溃")])])])])]),a._v(" "),_("li",[_("p",[a._v("防止crash")]),a._v(" "),_("ul",[_("li",[a._v("trycatch")]),a._v(" "),_("li",[a._v("NSSetUncaughtExceptionHandler")])])]),a._v(" "),_("li",[_("p",[a._v("抓取")]),a._v(" "),_("ul",[_("li",[a._v("直接上传")])])])]),a._v(" "),_("h3",{attrs:{id:"oom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oom"}},[a._v("#")]),a._v(" OOM")]),a._v(" "),_("ul",[_("li",[a._v("排除法")])]),a._v(" "),_("h3",{attrs:{id:"watchdog杀死"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#watchdog杀死"}},[a._v("#")]),a._v(" watchDog杀死")]),a._v(" "),_("ul",[_("li",[a._v("监控runloop的状态")])]),a._v(" "),_("h2",{attrs:{id:"ns-enum和ns-options"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ns-enum和ns-options"}},[a._v("#")]),a._v(" NS_ENUM和NS_OPTIONS")]),a._v(" "),_("h3",{attrs:{id:"推荐使用这两个宏来定义枚举-而不是使用c类型的枚举-优点是简洁、类型直观"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#推荐使用这两个宏来定义枚举-而不是使用c类型的枚举-优点是简洁、类型直观"}},[a._v("#")]),a._v(" 推荐使用这两个宏来定义枚举，而不是使用C类型的枚举，优点是简洁、类型直观")]),a._v(" "),_("h2",{attrs:{id:"ns-designated-initializer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ns-designated-initializer"}},[a._v("#")]),a._v(" NS_DESIGNATED_INITIALIZER")]),a._v(" "),_("h3",{attrs:{id:"如果类的某个初始化方法指定了ns-designated-initializer-那么其他初始化方法不能调用父类进行初始化-必须调用当前类指定的初始化方法进行初始化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果类的某个初始化方法指定了ns-designated-initializer-那么其他初始化方法不能调用父类进行初始化-必须调用当前类指定的初始化方法进行初始化"}},[a._v("#")]),a._v(" 如果类的某个初始化方法指定了NS_DESIGNATED_INITIALIZER，那么其他初始化方法不能调用父类进行初始化，必须调用当前类指定的初始化方法进行初始化")]),a._v(" "),_("ul",[_("li",[a._v("designated 初始化方法是提供所有的参数")]),a._v(" "),_("li",[a._v("secondary 初始化方法是一个或多个参数")])]),a._v(" "),_("h2",{attrs:{id:"堆和栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈"}},[a._v("#")]),a._v(" 堆和栈")]),a._v(" "),_("h3",{attrs:{id:"栈内存高地址向下增长"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈内存高地址向下增长"}},[a._v("#")]),a._v(" 栈内存高地址向下增长")]),a._v(" "),_("h3",{attrs:{id:"堆内存低地址向上增长"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆内存低地址向上增长"}},[a._v("#")]),a._v(" 堆内存低地址向上增长")]),a._v(" "),_("h2",{attrs:{id:"new调用流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#new调用流程"}},[a._v("#")]),a._v(" new调用流程")]),a._v(" "),_("h3",{attrs:{id:"_1-callalloc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-callalloc"}},[a._v("#")]),a._v(" 1.callAlloc")]),a._v(" "),_("p",[a._v("内部调用alloc")]),a._v(" "),_("ul",[_("li",[a._v("alloc")])]),a._v(" "),_("h3",{attrs:{id:"_2-init"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-init"}},[a._v("#")]),a._v(" 2.init")]),a._v(" "),_("h2",{attrs:{id:"object-getclass-id-obj-调用流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#object-getclass-id-obj-调用流程"}},[a._v("#")]),a._v(" object_getClass(id obj)调用流程")]),a._v(" "),_("p",[a._v("获取类对象的指针")]),a._v(" "),_("h3",{attrs:{id:"obj-getisa"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#obj-getisa"}},[a._v("#")]),a._v(" obj->getIsa();")]),a._v(" "),_("p",[a._v("这里的获取到的isa实际上是类对象指针")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("objc_object::ISA(bool authenticated)")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("isa_t::getDecodedClass(bool authenticated)")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("isa_t::getClass(bool authenticated)")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("bits &= ISA_MASK;")]),a._v(" "),_("ul",[_("li",[a._v("bits当中存放的是真正的64位二进制，其中包含了内存管理信息和类对象地址等等")]),a._v(" "),_("li",[a._v("其中ISA_MASK是0x0000000ffffffff8ULL(掩码)，通过与运算之后可以取得33位真正的类对象地址，即shiftcls")])])]),a._v(" "),_("li",[_("p",[a._v("与之相对应的是setClass，它们都是union isa_t当中的方法，不难看出setClass是将类对象地址存放到bits当中")])])])])])])])])]),a._v(" "),_("h2",{attrs:{id:"objc-init初始化流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#objc-init初始化流程"}},[a._v("#")]),a._v(" _objc_init初始化流程")]),a._v(" "),_("h3",{attrs:{id:"_1-初始化一系列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-初始化一系列"}},[a._v("#")]),a._v(" 1.初始化一系列")]),a._v(" "),_("ul",[_("li",[a._v("environ_init();\ntls_init();\nstatic_init();\nruntime_init();\nexception_init();\n#if "),_("strong",[a._v("OBJC2")]),a._v("\ncache_t::init();\n#endif"),_("br"),a._v("\n_imp_implementationWithBlock_init();")])]),a._v(" "),_("h3",{attrs:{id:"_2-map-images"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-map-images"}},[a._v("#")]),a._v(" 2.map_images")]),a._v(" "),_("ul",[_("li",[a._v("将类信息加入到class_rw_t")])]),a._v(" "),_("h3",{attrs:{id:"_3-load-images"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-load-images"}},[a._v("#")]),a._v(" 3.load_images")]),a._v(" "),_("ul",[_("li",[a._v("1.将category信息加入到class_rw_t")]),a._v(" "),_("li",[a._v("2.调用+load方法")])]),a._v(" "),_("h3",{attrs:{id:"_4-unmap-image"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-unmap-image"}},[a._v("#")]),a._v(" 4.unmap_image")]),a._v(" "),_("ul",[_("li",[a._v("释放一些资源")])]),a._v(" "),_("h2",{attrs:{id:"method-t结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#method-t结构"}},[a._v("#")]),a._v(" method_t结构")]),a._v(" "),_("h3",{attrs:{id:"static-const-uint32-t-smallmethodlistflag-0x80000000"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#static-const-uint32-t-smallmethodlistflag-0x80000000"}},[a._v("#")]),a._v(" static const uint32_t smallMethodListFlag = 0x80000000;")]),a._v(" "),_("h3",{attrs:{id:"struct-big"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#struct-big"}},[a._v("#")]),a._v(" struct big {")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("    SEL name;\n    const char *types;\n    MethodListIMP imp;\n};\n")])])]),_("ul",[_("li",[a._v("可见方法的名称、方法类型、方法的实现都存放在method_t的big当中")])]),a._v(" "),_("h2",{attrs:{id:"category-t结构-运行时确定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#category-t结构-运行时确定"}},[a._v("#")]),a._v(" category_t结构(运行时确定)")]),a._v(" "),_("h3",{attrs:{id:"char-name"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#char-name"}},[a._v("#")]),a._v(" char *name;")]),a._v(" "),_("ul",[_("li",[a._v("分类名称")])]),a._v(" "),_("h3",{attrs:{id:"classref-t-cls"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#classref-t-cls"}},[a._v("#")]),a._v(" classref_t cls;")]),a._v(" "),_("ul",[_("li",[a._v("类对象，即isa指针")])]),a._v(" "),_("h3",{attrs:{id:"wrappedptr-method-list-t-ptrauthstrip-instancemethods"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#wrappedptr-method-list-t-ptrauthstrip-instancemethods"}},[a._v("#")]),a._v(" WrappedPtr<method_list_t, PtrauthStrip> instanceMethods;")]),a._v(" "),_("ul",[_("li",[a._v("实例方法列表")])]),a._v(" "),_("h3",{attrs:{id:"wrappedptr-method-list-t-ptrauthstrip-classmethods"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#wrappedptr-method-list-t-ptrauthstrip-classmethods"}},[a._v("#")]),a._v(" WrappedPtr<method_list_t, PtrauthStrip> classMethods;")]),a._v(" "),_("ul",[_("li",[a._v("类方法列表")])]),a._v(" "),_("h3",{attrs:{id:"struct-protocol-list-t-protocols"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#struct-protocol-list-t-protocols"}},[a._v("#")]),a._v(" struct protocol_list_t *protocols;")]),a._v(" "),_("ul",[_("li",[a._v("协议列表")])]),a._v(" "),_("h3",{attrs:{id:"struct-property-list-t-instanceproperties"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#struct-property-list-t-instanceproperties"}},[a._v("#")]),a._v(" struct property_list_t *instanceProperties;")]),a._v(" "),_("ul",[_("li",[a._v("实例属性的列表")])]),a._v(" "),_("h3",{attrs:{id:"struct-property-list-t-classproperties"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#struct-property-list-t-classproperties"}},[a._v("#")]),a._v(" struct property_list_t *_classProperties;")]),a._v(" "),_("ul",[_("li",[a._v("类属性的列表")])]),a._v(" "),_("h2",{attrs:{id:"class-ro-t结构-与宿主类相关-编译时确定-只读"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#class-ro-t结构-与宿主类相关-编译时确定-只读"}},[a._v("#")]),a._v(" class_ro_t结构(与宿主类相关，编译时确定，只读)")]),a._v(" "),_("h3",{attrs:{id:"实例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实例"}},[a._v("#")]),a._v(" 实例")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("uint32_t flags;")])]),a._v(" "),_("li",[_("p",[a._v("uint32_t instanceStart;")])]),a._v(" "),_("li",[_("p",[a._v("uint32_t instanceSize;")])]),a._v(" "),_("li",[_("p",[a._v("uint32_t reserved;")])]),a._v(" "),_("li",[_("p",[a._v("union {\nconst uint8_t * ivarLayout;\nClass nonMetaclass;\n};")])]),a._v(" "),_("li",[_("p",[a._v("explicit_atomic<const char *> name;")])]),a._v(" "),_("li",[_("p",[a._v("void *baseMethodList;")]),a._v(" "),_("ul",[_("li",[a._v("方法列表(不包括category中的方法)")])])]),a._v(" "),_("li",[_("p",[a._v("protocol_list_t * baseProtocols;")]),a._v(" "),_("ul",[_("li",[a._v("协议列表(不包括category中的协议)")])])]),a._v(" "),_("li",[_("p",[a._v("const ivar_list_t * ivars;")]),a._v(" "),_("ul",[_("li",[a._v("变量列表")])])]),a._v(" "),_("li",[_("p",[a._v("const uint8_t * weakIvarLayout;")])]),a._v(" "),_("li",[_("p",[a._v("property_list_t *baseProperties;")]),a._v(" "),_("ul",[_("li",[a._v("属性列表(不包括category中的属性)")])])])]),a._v(" "),_("h2",{attrs:{id:"class-rw-t结构-运行时确定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#class-rw-t结构-运行时确定"}},[a._v("#")]),a._v(" class_rw_t结构(运行时确定)")]),a._v(" "),_("h3",{attrs:{id:"实例-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实例-2"}},[a._v("#")]),a._v(" 实例")]),a._v(" "),_("ul",[_("li",[a._v("uint32_t flags;")]),a._v(" "),_("li",[a._v("uint16_t witness;")]),a._v(" "),_("li",[a._v("explicit_atomic<uintptr_t> ro_or_rw_ext;")]),a._v(" "),_("li",[a._v("Class firstSubclass;")]),a._v(" "),_("li",[a._v("Class nextSiblingClass;")])]),a._v(" "),_("h3",{attrs:{id:"方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("method_array_t methods();")]),a._v(" "),_("ul",[_("li",[a._v("方法列表")])])]),a._v(" "),_("li",[_("p",[a._v("property_array_t properties();")]),a._v(" "),_("ul",[_("li",[a._v("属性列表")])])]),a._v(" "),_("li",[_("p",[a._v("protocol_array_t protocols();")]),a._v(" "),_("ul",[_("li",[a._v("协议列表")])])]),a._v(" "),_("li",[_("p",[a._v("class_ro_t *ro();")]),a._v(" "),_("ul",[_("li",[a._v("调用ro()函数得到class_ro_t，实际其相关信息存储在ro_or_rw_ext当中")])])])]),a._v(" "),_("h3",{attrs:{id:"运行时会将class-ro-t中的方法、属性、协议添加到class-rw-t当中"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行时会将class-ro-t中的方法、属性、协议添加到class-rw-t当中"}},[a._v("#")]),a._v(" 运行时会将class_ro_t中的方法、属性、协议添加到class_rw_t当中")]),a._v(" "),_("h2",{attrs:{id:"class-data-bits-t结构-8字节"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#class-data-bits-t结构-8字节"}},[a._v("#")]),a._v(" class_data_bits_t结构(8字节)")]),a._v(" "),_("h3",{attrs:{id:"唯一实例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#唯一实例"}},[a._v("#")]),a._v(" 唯一实例")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("uintptr_t bits;")]),a._v(" "),_("ul",[_("li",[a._v("前3位不清楚")]),a._v(" "),_("li",[a._v("class_rw_t (44位)")])])])]),a._v(" "),_("h3",{attrs:{id:"方法-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法-2"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("class_rw_t* data();")]),a._v(" "),_("ul",[_("li",[a._v("实际最后是通过取中间44位得到class_rw_t")])])])]),a._v(" "),_("h2",{attrs:{id:"cache-t结构-16字节"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-t结构-16字节"}},[a._v("#")]),a._v(" Cache_t结构(16字节)")]),a._v(" "),_("p",[a._v("方法缓存，在调用函数时，先查找方法缓存，查找不到时再查找bits当中的class_rw_t，再查找不到时到父类当中查找")]),a._v(" "),_("h3",{attrs:{id:"explicit-atomic-uintptr-t-bucketsandmaybemask"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#explicit-atomic-uintptr-t-bucketsandmaybemask"}},[a._v("#")]),a._v(" explicit_atomic<uintptr_t> _bucketsAndMaybeMask;")]),a._v(" "),_("h3",{attrs:{id:"union"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#union"}},[a._v("#")]),a._v(" union {")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[a._v("    struct {\n        explicit_atomic<mask_t>    _maybeMask;\n")])])]),_("p",[a._v("#if "),_("strong",[a._v("LP64")]),a._v("\nuint16_t                   _flags;\n#endif\nuint16_t                   _occupied;\n};\nexplicit_atomic<preopt_cache_t *> _originalPreoptCache;\n};")]),a._v(" "),_("h2",{attrs:{id:"objc-class-class-40字节"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#objc-class-class-40字节"}},[a._v("#")]),a._v(" objc_class/Class(40字节)")]),a._v(" "),_("p",[a._v("objc_class类型的结构体指针，objc_class包含isa指针，并且当中存储了创建对象或者类对象所需要的信息")]),a._v(" "),_("h3",{attrs:{id:"objc1版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#objc1版本"}},[a._v("#")]),a._v(" Objc1版本")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("Class isa")]),a._v(" "),_("p",[a._v("元类对象的指针")])]),a._v(" "),_("li",[_("p",[a._v("Class super_class")]),a._v(" "),_("p",[a._v("父类对象的指针")])]),a._v(" "),_("li",[_("p",[a._v("char *name")]),a._v(" "),_("p",[a._v("类名")])]),a._v(" "),_("li",[_("p",[a._v("long instance_size")]),a._v(" "),_("p",[a._v("实例的总大小")])]),a._v(" "),_("li",[_("p",[a._v("struct objc_ivar_list *ivars")]),a._v(" "),_("p",[a._v("实例变量列表")])]),a._v(" "),_("li",[_("p",[a._v("struct objc_method_list **methodLists")]),a._v(" "),_("p",[a._v("方法列表")])]),a._v(" "),_("li",[_("p",[a._v("struct objc_cache *cache")]),a._v(" "),_("p",[a._v("缓存")])]),a._v(" "),_("li",[_("p",[a._v("struct objc_protocol_list *protocols")]),a._v(" "),_("p",[a._v("遵守的协议列表")])])]),a._v(" "),_("h3",{attrs:{id:"objc2版本"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#objc2版本"}},[a._v("#")]),a._v(" Objc2版本")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("属性")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("isa_t isa;")]),a._v(" "),_("ul",[_("li",[a._v("8字节，指向元类对象的isa指针")])])]),a._v(" "),_("li",[_("p",[a._v("Class super_class;")]),a._v(" "),_("ul",[_("li",[a._v("8字节，指向父类")])])]),a._v(" "),_("li",[_("p",[a._v("cache_t cache;")]),a._v(" "),_("ul",[_("li",[a._v("16字节，方法缓存")])])]),a._v(" "),_("li",[_("p",[a._v("class_data_bits_t bits;")]),a._v(" "),_("ul",[_("li",[a._v("8字节，我们可以通过isa指针偏移32字节得到class_data_bits_t")])])])])])]),a._v(" "),_("h2",{attrs:{id:"objc-object"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#objc-object"}},[a._v("#")]),a._v(" objc_object")]),a._v(" "),_("p",[a._v("对象")]),a._v(" "),_("h3",{attrs:{id:"属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[a._v("#")]),a._v(" 属性")]),a._v(" "),_("ul",[_("li",[a._v("isa_t isa;")])]),a._v(" "),_("h3",{attrs:{id:"方法-3"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法-3"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("Class getIsa();")]),a._v(" "),_("ul",[_("li",[a._v("获取类对象指针")])])]),a._v(" "),_("li",[_("p",[a._v("isaBits();")]),a._v(" "),_("ul",[_("li",[a._v("获取isa的64个比特位")])])])]),a._v(" "),_("h2",{attrs:{id:"union-isa-t"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#union-isa-t"}},[a._v("#")]),a._v(" union isa_t")]),a._v(" "),_("h3",{attrs:{id:"存放了64位bits"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存放了64位bits"}},[a._v("#")]),a._v(" 存放了64位bits")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("64bits组成(从低位到高位)")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("nonpointer(1)")]),a._v(" "),_("ul",[_("li",[a._v("0表示是纯的isa指针")]),a._v(" "),_("li",[a._v("1表示非纯的isa指针，里面包含内存管理信息")])])]),a._v(" "),_("li",[_("p",[a._v("has_assoc(1)")]),a._v(" "),_("ul",[_("li",[a._v("是否有关联对象")])])]),a._v(" "),_("li",[_("p",[a._v("has_cxx_dtor(1)")]),a._v(" "),_("ul",[_("li",[a._v("是否有析构函数")])])]),a._v(" "),_("li",[_("p",[a._v("shiftcls(33)")]),a._v(" "),_("ul",[_("li",[a._v("存储类对象指针")])])]),a._v(" "),_("li",[_("p",[a._v("magic(6)")]),a._v(" "),_("ul",[_("li",[a._v("判断是否真对象还是未初始化的空间")])])]),a._v(" "),_("li",[_("p",[a._v("weakly_referenced(1)")]),a._v(" "),_("ul",[_("li",[a._v("是否有弱引用指针")])])]),a._v(" "),_("li",[_("p",[a._v("unused(1)")])]),a._v(" "),_("li",[_("p",[a._v("has_sidetable_rc(1)")]),a._v(" "),_("ul",[_("li",[a._v("是否有散列表引用计数")])])]),a._v(" "),_("li",[_("p",[a._v("extra_rc(19)")]),a._v(" "),_("ul",[_("li",[a._v("存储引用计数")])])])])])]),a._v(" "),_("h3",{attrs:{id:"其中33位类对象地址-其余31位为内存相关的信息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其中33位类对象地址-其余31位为内存相关的信息"}},[a._v("#")]),a._v(" 其中33位类对象地址，其余31位为内存相关的信息")]),a._v(" "),_("h3",{attrs:{id:"通过setclass方法将类对象地址存到bits的shiftcls当中-通过getclass将类对象地址从bits当中取出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通过setclass方法将类对象地址存到bits的shiftcls当中-通过getclass将类对象地址从bits当中取出"}},[a._v("#")]),a._v(" 通过setClass方法将类对象地址存到bits的shiftcls当中，通过getClass将类对象地址从bits当中取出")]),a._v(" "),_("h2",{attrs:{id:"init调用流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#init调用流程"}},[a._v("#")]),a._v(" init调用流程")]),a._v(" "),_("h3",{attrs:{id:"objc-rootinit-self"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#objc-rootinit-self"}},[a._v("#")]),a._v(" _objc_rootInit(self)")]),a._v(" "),_("p",[a._v("其中self为指向对象的指针（即objc_object指针），无任何操作，函数返回值为self")]),a._v(" "),_("h2",{attrs:{id:"alloc调用流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#alloc调用流程"}},[a._v("#")]),a._v(" alloc调用流程")]),a._v(" "),_("h3",{attrs:{id:"objc-rootalloc-self"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#objc-rootalloc-self"}},[a._v("#")]),a._v(" _objc_rootAlloc(self)")]),a._v(" "),_("p",[a._v("其中self为指向类对象指针")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("callAlloc")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("allocWithZone")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("_objc_rootAllocWithZone")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("_class_createInstanceFromZone")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("instanceSize")]),a._v(" "),_("p",[a._v("获取实例大小")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("size = alignedInstanceSize()")]),a._v(" "),_("p",[a._v("获取对其后的字节数")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("data()->ro()->instanceSize")]),a._v(" "),_("p",[a._v("获取实例大小")]),a._v(" "),_("ul",[_("li",[a._v("通过data()方法取得class_rw_t")]),a._v(" "),_("li",[a._v("从ro()方法中获取class_ro_t")]),a._v(" "),_("li",[a._v("从class_ro_t中取得instanceSize")])])]),a._v(" "),_("li",[_("p",[a._v("(x + size_t(15)) & ~size_t(15)")]),a._v(" "),_("p",[a._v("将获取到的实例大小按照16字节对齐")])])])]),a._v(" "),_("li",[_("p",[a._v("if (size < 16) size = 16;")]),a._v(" "),_("p",[a._v("当字节小于16时，开辟16字节空间")]),a._v(" "),_("ul",[_("li",[a._v("规定对象的占用的最小内存大小：如果小于16字节，就开辟16字节")])])]),a._v(" "),_("li",[_("p",[a._v("实例的大小由isa指针、基本数据类型、其他指针组成")])])])]),a._v(" "),_("li",[_("p",[a._v("calloc")]),a._v(" "),_("p",[a._v("开辟内存空间")])]),a._v(" "),_("li",[_("p",[a._v("initInstanceIsa")]),a._v(" "),_("p",[a._v("初始化isa指针，将isa指针绑定到对象")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("什么是isa指针？")]),a._v(" "),_("ul",[_("li",[a._v("isa指针存储了类对象或者元类对象地址，还有其它内存管理相关的内容")])])]),a._v(" "),_("li",[_("p",[a._v("什么是super_class指针？")]),a._v(" "),_("ul",[_("li",[a._v("super_class指针表明当前类对象的父类或者当前元类对象的父元类")])])]),a._v(" "),_("li",[_("p",[a._v("newisa.setClass(cls, this);")]),a._v(" "),_("ul",[_("li",[a._v("将类对象绑定到对象")])])]),a._v(" "),_("li",[_("p",[a._v("newisa.extra_rc = 1;")]),a._v(" "),_("ul",[_("li",[a._v("设置引用计数为1")])])])])])])])])])])])])])]),a._v(" "),_("h3",{attrs:{id:"通过分析alloc之后的对象p-我们发现创建的新的p的地址会比之前大-而-p的地址会变小且每次增长8个字节-可以证明对象开辟在堆空间-所以它的地址是向上增长-而指针存储在栈空间-它的地址是向下增长的。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通过分析alloc之后的对象p-我们发现创建的新的p的地址会比之前大-而-p的地址会变小且每次增长8个字节-可以证明对象开辟在堆空间-所以它的地址是向上增长-而指针存储在栈空间-它的地址是向下增长的。"}},[a._v("#")]),a._v(" 通过分析alloc之后的对象p，我们发现创建的新的p的地址会比之前大，而&p的地址会变小且每次增长8个字节，可以证明对象开辟在堆空间，所以它的地址是向上增长，而指针存储在栈空间，它的地址是向下增长的。")]),a._v(" "),_("h2",{attrs:{id:"alloc对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#alloc对比"}},[a._v("#")]),a._v(" alloc对比")]),a._v(" "),_("h3",{attrs:{id:"每次alloc生成的地址相同-init后不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#每次alloc生成的地址相同-init后不同"}},[a._v("#")]),a._v(" 每次alloc生成的地址相同，init后不同")]),a._v(" "),_("ul",[_("li",[a._v("[NSString alloc]")]),a._v(" "),_("li",[a._v("[NSMutableString alloc]")]),a._v(" "),_("li",[a._v("[NSArray alloc]")]),a._v(" "),_("li",[a._v("[NSMutableArray alloc]")]),a._v(" "),_("li",[a._v("[NSDictionary alloc]")]),a._v(" "),_("li",[a._v("[NSMutableDictionary alloc]")])]),a._v(" "),_("h3",{attrs:{id:"每次开辟的地址变大-说明开辟在堆区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#每次开辟的地址变大-说明开辟在堆区"}},[a._v("#")]),a._v(" 每次开辟的地址变大，说明开辟在堆区")]),a._v(" "),_("ul",[_("li",[a._v("[NSObject alloc]")])]),a._v(" "),_("h2",{attrs:{id:"nsstring的子类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsstring的子类"}},[a._v("#")]),a._v(" NSString的子类")]),a._v(" "),_("h3",{attrs:{id:"nscfconstantstring-常量区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nscfconstantstring-常量区"}},[a._v("#")]),a._v(" __NSCFConstantString(常量区)")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("创建方式")]),a._v(" "),_("ul",[_("li",[a._v('@"..."')]),a._v(" "),_("li",[a._v('CFSTR("...")')]),a._v(" "),_("li",[a._v("[NSString stringWithString:]")])])]),a._v(" "),_("li",[_("p",[a._v("编译时常量")])]),a._v(" "),_("li",[_("p",[a._v("程序结束时释放")])])]),a._v(" "),_("h3",{attrs:{id:"nstaggedpointerstring-栈区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nstaggedpointerstring-栈区"}},[a._v("#")]),a._v(" NSTaggedPointerString(栈区)")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("地址分析0xab1957fd0bebaf35")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("a(1010)")]),a._v(" "),_("ul",[_("li",[a._v("1表示这是一个Tagged Pointer")]),a._v(" "),_("li",[a._v("010表示这是一个NSTaggedPointerString类")])])]),a._v(" "),_("li",[_("p",[a._v("5(0101)")]),a._v(" "),_("ul",[_("li",[a._v("表示字符的长度")])])]),a._v(" "),_("li",[_("p",[a._v("中间的56位二进制是真正的数据值")]),a._v(" "),_("ul",[_("li",[a._v("1.如果采用ascii编码(8位编码)，那么最多存储7个字符")]),a._v(" "),_("li",[a._v("2.如果采用6位编码，最多存储9个字符")]),a._v(" "),_("li",[a._v("3.如果采用5位编码，最多存储11个字符")]),a._v(" "),_("li",[a._v("4.当字符数超过11位时，那么数据就会存储到堆区，类型为__NSCFString")])])])])]),a._v(" "),_("li",[_("p",[a._v("创建方式")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("[NSString stringWithFormat:]")]),a._v(" "),_("ul",[_("li",[a._v("短字符(长度小于等于11)")])])])])]),a._v(" "),_("li",[_("p",[a._v("本身就是存储的值，无需释放")])])]),a._v(" "),_("h3",{attrs:{id:"nscfstring-堆区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nscfstring-堆区"}},[a._v("#")]),a._v(" __NSCFString(堆区)")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("创建方式")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("[NSString stringWithFormat:]")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("长字符(长度大于11)")]),a._v(" "),_("ul",[_("li",[_("p",[a._v('NSString *str =  [NSString stringWithFormat:@"https://ityongzhen.github.io/"];')]),a._v(" "),_("ul",[_("li",[a._v("str的引用计数为2")])])])])])])]),a._v(" "),_("li",[_("p",[a._v("NSMutableString")])]),a._v(" "),_("li",[_("p",[a._v('NSString *str =  [[NSString alloc] initWithFormat:@"https://ityongzhen.github.io/"];')]),a._v(" "),_("ul",[_("li",[a._v("str引用计数为1")])])])])]),a._v(" "),_("li",[_("p",[a._v("运行时NSString的子类")])]),a._v(" "),_("li",[_("p",[a._v("出了方法作用域，在runloop结束时被autoreleasepool释放")])])]),a._v(" "),_("h2",{attrs:{id:"nsnumber子类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nsnumber子类"}},[a._v("#")]),a._v(" NSNumber子类")]),a._v(" "),_("h3",{attrs:{id:"nscfnumber"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nscfnumber"}},[a._v("#")]),a._v(" __NSCFNumber")]),a._v(" "),_("ul",[_("li",[a._v("短数据存储实际值")]),a._v(" "),_("li",[a._v("长数据存储指针，长短的界限暂时还不确定")])]),a._v(" "),_("h2",{attrs:{id:"nszone"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nszone"}},[a._v("#")]),a._v(" NSZone")]),a._v(" "),_("h3",{attrs:{id:"系统自带nszone-它使用c结构存储了对象的内存管理信息-不过在系统的zone中开辟大量内存时-开销会很大-因为系统的zone内存在使用期间已经碎片化了-此时我们可以创建自己的zone-这样开辟内存开销小-并且可以一次性释放zone内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#系统自带nszone-它使用c结构存储了对象的内存管理信息-不过在系统的zone中开辟大量内存时-开销会很大-因为系统的zone内存在使用期间已经碎片化了-此时我们可以创建自己的zone-这样开辟内存开销小-并且可以一次性释放zone内存"}},[a._v("#")]),a._v(" 系统自带NSZone，它使用C结构存储了对象的内存管理信息，不过在系统的Zone中开辟大量内存时，开销会很大，因为系统的Zone内存在使用期间已经碎片化了，此时我们可以创建自己的Zone，这样开辟内存开销小，并且可以一次性释放Zone内存")]),a._v(" "),_("h2",{attrs:{id:"size"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#size"}},[a._v("#")]),a._v(" size")]),a._v(" "),_("h3",{attrs:{id:"sizeof"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sizeof"}},[a._v("#")]),a._v(" sizeof")]),a._v(" "),_("ul",[_("li",[a._v("获取指针的大小，通常跟操作系统有关，64位系统通常返回8字节")])]),a._v(" "),_("h3",{attrs:{id:"class-getinstancesize"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#class-getinstancesize"}},[a._v("#")]),a._v(" class_getInstanceSize")]),a._v(" "),_("ul",[_("li",[a._v("获取对象至少需要的内存大小，按8字节对齐，内存最少需要8字节")])]),a._v(" "),_("h3",{attrs:{id:"malloc-size"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#malloc-size"}},[a._v("#")]),a._v(" malloc_size")]),a._v(" "),_("ul",[_("li",[a._v("获取对象实际分配的内存大小，按16字节对齐，其中isa指针占8个字节，所以对象分配的内存最小为16字节")])]),a._v(" "),_("h2",{attrs:{id:"id-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#id-2"}},[a._v("#")]),a._v(" id")]),a._v(" "),_("p",[a._v("objc_object类型的结构体指针")]),a._v(" "),_("h3",{attrs:{id:"objc-object结构体只包含一个唯一的isa指针-因为每一个对象都必须依赖一个类来创建-所以它指向类对象-类对象是objc-class类型的结构体"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#objc-object结构体只包含一个唯一的isa指针-因为每一个对象都必须依赖一个类来创建-所以它指向类对象-类对象是objc-class类型的结构体"}},[a._v("#")]),a._v(" objc_object结构体只包含一个唯一的isa指针，因为每一个对象都必须依赖一个类来创建，所以它指向类对象(类对象是objc_class类型的结构体)，")]),a._v(" "),_("h2",{attrs:{id:"对象objc-object、类对象objc-class、元类对象objc-class的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象objc-object、类对象objc-class、元类对象objc-class的区别"}},[a._v("#")]),a._v(" 对象objc_object、类对象objc_class、元类对象objc_class的区别")]),a._v(" "),_("h3",{attrs:{id:"对象objc-object中只有一个isa指针-isa指针包含类对象地址和其他内存信息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象objc-object中只有一个isa指针-isa指针包含类对象地址和其他内存信息"}},[a._v("#")]),a._v(" 对象objc_object中只有一个isa指针(isa指针包含类对象地址和其他内存信息)")]),a._v(" "),_("h3",{attrs:{id:"类对象objc-class中存储了创建实例所需要的信息-类名、父类、实例大小、方法、协议等等-和一个指向元类对象的isa指针-通过这个isa指针-我们可以知道当前类是通过哪个元类对象创建来的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类对象objc-class中存储了创建实例所需要的信息-类名、父类、实例大小、方法、协议等等-和一个指向元类对象的isa指针-通过这个isa指针-我们可以知道当前类是通过哪个元类对象创建来的"}},[a._v("#")]),a._v(" 类对象objc_class中存储了创建实例所需要的信息(类名、父类、实例大小、方法、协议等等)和一个指向元类对象的isa指针，通过这个isa指针，我们可以知道当前类是通过哪个元类对象创建来的")]),a._v(" "),_("h3",{attrs:{id:"元类对象objc-class中存储了创建类对象所需要的信息-类名、父元类等等-和一个指向根元类的isa指针"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#元类对象objc-class中存储了创建类对象所需要的信息-类名、父元类等等-和一个指向根元类的isa指针"}},[a._v("#")]),a._v(" 元类对象objc_class中存储了创建类对象所需要的信息(类名、父元类等等)和一个指向根元类的isa指针")]),a._v(" "),_("h2",{attrs:{id:"内存管理方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存管理方案"}},[a._v("#")]),a._v(" 内存管理方案")]),a._v(" "),_("h3",{attrs:{id:"taggedpointer方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#taggedpointer方案"}},[a._v("#")]),a._v(" TaggedPointer方案")]),a._v(" "),_("ul",[_("li",[a._v("短的NSString/NSNumber地址直接存储值")])]),a._v(" "),_("h3",{attrs:{id:"nonpointer-isa方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nonpointer-isa方案"}},[a._v("#")]),a._v(" nonPointer_isa方案")]),a._v(" "),_("ul",[_("li",[a._v("存储附加信息、引用计数和类对象指针")]),a._v(" "),_("li",[a._v("引用计数值为extra_rc+SideTable中的计数值之和(如果has_sidetable_rc为1时)")])]),a._v(" "),_("h3",{attrs:{id:"sidetable方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sidetable方案"}},[a._v("#")]),a._v(" SideTable方案")]),a._v(" "),_("ul",[_("li",[a._v("当nonPointer_isa中的extra_rc超过上限时，使用SideTable管理引用计数，不过我发现extra_rc在64位机器上有19位，在32位机器上有7位，感觉已经够用了，是不是用不着散列表？")])]),a._v(" "),_("h3",{attrs:{id:"weak"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#weak"}},[a._v("#")]),a._v(" weak")]),a._v(" "),_("ul",[_("li",[a._v("weak是通过弱引用表管理，每新增一个弱引用，就将弱引用指针添加到散列表当中，并将原对象的weakly_referenced置为1")]),a._v(" "),_("li",[a._v("当原对象被释放时，根据原对象指针查找所属的弱引用表(即SideTable)，然后调用weak_clear_no_lock，并根据原对象的地址在SideTable中找出弱引用指针的数组，然后将弱引用的所有指针清空")]),a._v(" "),_("li",[a._v("弱引用指针是指针的指针，即&obj")])]),a._v(" "),_("h3",{attrs:{id:"strong"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#strong"}},[a._v("#")]),a._v(" strong")]),a._v(" "),_("ul",[_("li",[a._v("strong是通过extra_rc和引用计数表一起管理，当extra_rc大于可存储上限时，使用散列表存储，并将has_sidetable_rc置为1")])]),a._v(" "),_("h3",{attrs:{id:"sidetables"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sidetables"}},[a._v("#")]),a._v(" SideTables")]),a._v(" "),_("p",[a._v("通过对象指针获取所属的SideTable")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("SideTable")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("spinlock_t slock;")])]),a._v(" "),_("li",[_("p",[a._v("RefcountMap refcnts;")]),a._v(" "),_("ul",[_("li",[a._v("引用计数表")])])]),a._v(" "),_("li",[_("p",[a._v("weak_table_t weak_table;")]),a._v(" "),_("ul",[_("li",[a._v("弱引用表")])])]),a._v(" "),_("li",[_("p",[a._v("如果是retain操作，则通过对象指针到refcnts当中去获取引用计数值，再执行+1操作")])]),a._v(" "),_("li",[_("p",[a._v("如果是release操作，则通过对象指针到refcnts当中去获取引用计数值，再执行-1操作")])]),a._v(" "),_("li",[_("p",[a._v("如果是retainCount操作，则需要将extra_rc和 sidetable中的引用计数值相加")])])])])]),a._v(" "),_("h3",{attrs:{id:"dealloc操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dealloc操作"}},[a._v("#")]),a._v(" dealloc操作")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("如果是taggedPointer，则无需释放操作")])]),a._v(" "),_("li",[_("p",[a._v("如果是nonpointer，则需要额外步骤")]),a._v(" "),_("ul",[_("li",[a._v("1.如果有C++析构函数(即has_cxx_dtor为1)，则先调用析构函数")]),a._v(" "),_("li",[a._v("2.如果有关联对象(即has_assoc为1)，则先移除关联对象")]),a._v(" "),_("li",[a._v("3.如果有弱引用指针(即weakly_referenced为1)，则移除所有弱引用")]),a._v(" "),_("li",[a._v("4.如果有散列表引用计数(即has_sidetable_rc为1)，则清除引用计数表")]),a._v(" "),_("li",[a._v("5.最后调用free释放对象")])])])]),a._v(" "),_("h2",{attrs:{id:"kvo"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#kvo"}},[a._v("#")]),a._v(" KVO")]),a._v(" "),_("h3",{attrs:{id:"addobserver"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#addobserver"}},[a._v("#")]),a._v(" addObserver")]),a._v(" "),_("ul",[_("li",[a._v("添加观察者时，会将isa指针指向原类的子类，系统会在对应的key的setter方法当中添加willChange和didChange方法，以便于通知观察者值的改变")])]),a._v(" "),_("h3",{attrs:{id:"observevalueforkeypath"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#observevalueforkeypath"}},[a._v("#")]),a._v(" observeValueForKeyPath")]),a._v(" "),_("h2",{attrs:{id:"synthesize"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#synthesize"}},[a._v("#")]),a._v(" @synthesize")]),a._v(" "),_("p",[a._v("主要作用就是更改实例变量的名称，将之前的_testStr改成任意")]),a._v(" "),_("h3",{attrs:{id:"synthesize-teststr-test22"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#synthesize-teststr-test22"}},[a._v("#")]),a._v(" @synthesize testStr = test22;")]),a._v(" "),_("ul",[_("li",[a._v("将属性testStr的实例变量的名称改为test22")])]),a._v(" "),_("h3",{attrs:{id:"synthesize-teststr"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#synthesize-teststr"}},[a._v("#")]),a._v(" @synthesize testStr;")]),a._v(" "),_("ul",[_("li",[a._v("将属性testStr的实例变量名称改为testStr(之前为_testStr)")])]),a._v(" "),_("h3",{attrs:{id:"当一个对象调用obj-test22时-默认是从getter方法中取出实例变量-例如取得test22或者teststr"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#当一个对象调用obj-test22时-默认是从getter方法中取出实例变量-例如取得test22或者teststr"}},[a._v("#")]),a._v(" 当一个对象调用obj.test22时，默认是从getter方法中取出实例变量，例如取得test22或者testStr")]),a._v(" "),_("h3",{attrs:{id:"当一个对象调用obj-test22-123-时-默认是去设置实例变量test22或者teststr的值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#当一个对象调用obj-test22-123-时-默认是去设置实例变量test22或者teststr的值"}},[a._v("#")]),a._v(' 当一个对象调用obj.test22 = @"123"时，默认是去设置实例变量test22或者testStr的值')]),a._v(" "),_("p",[_("em",[a._v("XMind - Trial Version")])])])}),[],!1,null,null,null);t.default=e.exports}}]);