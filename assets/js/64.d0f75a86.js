(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{605:function(t,_,a){"use strict";a.r(_);var r=a(65),v=Object(r.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"pthread"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pthread"}},[t._v("#")]),t._v(" pthread")]),t._v(" "),a("h2",{attrs:{id:"创建线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建线程"}},[t._v("#")]),t._v(" 创建线程")]),t._v(" "),a("h3",{attrs:{id:"pthread-create-pthread-t-tid-pthread-attr-t-attr-func-f-void-arg"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pthread-create-pthread-t-tid-pthread-attr-t-attr-func-f-void-arg"}},[t._v("#")]),t._v(" pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg);")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("tid")]),t._v(" "),a("ul",[a("li",[t._v("线程id")])])]),t._v(" "),a("li",[a("p",[t._v("attr")]),t._v(" "),a("ul",[a("li",[t._v("创建线程时的属性，一般为NULL")])])]),t._v(" "),a("li",[a("p",[t._v("f")]),t._v(" "),a("ul",[a("li",[t._v("在新线程中运行的函数")])])]),t._v(" "),a("li",[a("p",[t._v("arg")]),t._v(" "),a("ul",[a("li",[t._v("创建新线程时带入的参数，然后从f中可获取到")])])])]),t._v(" "),a("h2",{attrs:{id:"终止线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#终止线程"}},[t._v("#")]),t._v(" 终止线程")]),t._v(" "),a("h3",{attrs:{id:"当例程函数返回时会隐式终止"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#当例程函数返回时会隐式终止"}},[t._v("#")]),t._v(" 当例程函数返回时会隐式终止")]),t._v(" "),a("h3",{attrs:{id:"显式终止-如果主线程调用pthread-exit-它会等待所有其他对等线程终止后再终止"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#显式终止-如果主线程调用pthread-exit-它会等待所有其他对等线程终止后再终止"}},[t._v("#")]),t._v(" 显式终止，如果主线程调用pthread_exit，它会等待所有其他对等线程终止后再终止")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("int pthread_exit(void *thread_return);")]),t._v(" "),a("ul",[a("li",[t._v("thread_return为线程返回值")])])]),t._v(" "),a("li",[a("p",[t._v("int pthread_cancel(pthread_t tid);")])])]),t._v(" "),a("h2",{attrs:{id:"线程等待"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程等待"}},[t._v("#")]),t._v(" 线程等待")]),t._v(" "),a("h3",{attrs:{id:"等待其他线程的退出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#等待其他线程的退出"}},[t._v("#")]),t._v(" 等待其他线程的退出")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("pthread_join(pthread_t tid, void **thread_reutrn);")]),t._v(" "),a("ul",[a("li",[t._v("pthread_join函数会阻塞当前线程，直到线程tid终止")]),t._v(" "),a("li",[t._v("thread_return为tid线程的返回值")])])])]),t._v(" "),a("h2",{attrs:{id:"分离线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分离线程"}},[t._v("#")]),t._v(" 分离线程")]),t._v(" "),a("h3",{attrs:{id:"结合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#结合"}},[t._v("#")]),t._v(" 结合")]),t._v(" "),a("p",[t._v("一个可结合的线程能够被其他线程收回其资源和杀死")]),t._v(" "),a("ul",[a("li",[t._v("默认情况下，线程被创建为可结合的。")])]),t._v(" "),a("h3",{attrs:{id:"分离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分离"}},[t._v("#")]),t._v(" 分离")]),t._v(" "),a("p",[t._v("一个分离线程时不能被其他线程回收或杀死的。他的内存资源在它终止时由系统自动释放")]),t._v(" "),a("ul",[a("li",[t._v("pthread_detach(pthread_t tid);")])]),t._v(" "),a("h2",{attrs:{id:"初始化线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初始化线程"}},[t._v("#")]),t._v(" 初始化线程")]),t._v(" "),a("h3",{attrs:{id:"pthread-once-pthread-once-t-once-control-void-init-routine-void"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pthread-once-pthread-once-t-once-control-void-init-routine-void"}},[t._v("#")]),t._v(" pthread_once(pthread_once_t *once_control, void (*init_routine)(void));")]),t._v(" "),a("ul",[a("li",[t._v("once_control总是被定义为全局变量：pthread_once_t once_control = PTHREAD_ONCE_INIT;")]),t._v(" "),a("li",[t._v("init_routine只会在第一次初始化时被调用")])]),t._v(" "),a("h2",{attrs:{id:"锁和信号量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁和信号量"}},[t._v("#")]),t._v(" 锁和信号量")]),t._v(" "),a("h3",{attrs:{id:"锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当上锁后，其他线程就无法访问临界区，会一直处于等待状态")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("例如")]),t._v(" "),a("ul",[a("li",[t._v("线程1：pthread_mutex_lock(&lock);\n表达式1\npthread_mutex_unlock(&lock);")]),t._v(" "),a("li",[t._v("线程2：pthread_mutex_lock(&lock);\n表达式2\npthread_mutex_unlock(&lock);")]),t._v(" "),a("li",[t._v("当线程1上锁后没释放资源时，线程2无法访问表达式2")])])])])])]),t._v(" "),a("h3",{attrs:{id:"信号量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[t._v("#")]),t._v(" 信号量")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("pthread_cond_wait(&cond, &lock);")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("先解锁，再上锁，这就决定了pthread_cond_wait必须在pthread_mutex_lock和pthread_mutex_unlock之间执行，因为自己有解锁和上锁动作。")]),t._v(" "),a("ul",[a("li",[t._v("unlock;\n告诉其他线程我要开始等待了，我交出我的时间片;\nlock;")])])]),t._v(" "),a("li",[a("p",[t._v("通常pthread_cond_wait必须在pthread_mutex_lock和pthread_mutex_unlock之间执行，即：")]),t._v(" "),a("ul",[a("li",[t._v("pthread_mutex_lock(&lock);\npthread_cond_wait(&cond, &lock);\npthread_mutex_unlock(&lock);")])])]),t._v(" "),a("li",[a("p",[t._v("例如")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("表达式3\npthread_mutex_lock(&lock);\n表达式4\npthread_cond_signal(&cond);\n表达式5\npthread_mutex_unlock(&lock);\n表达式6")])]),t._v(" "),a("li",[a("p",[t._v("表达式3\npthread_mutex_lock(&lock);\n表达式4\npthread_cond_signal(&cond);\n表达式5\npthread_mutex_unlock(&lock);\n表达式6")])]),t._v(" "),a("li",[a("p",[t._v("假设线程1先创建，上述线程1和2中表达式执行顺序为：0->1->3->4->5->6->2")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("可能你会有疑问，执行顺序难道不应该是：0->1->3然后无限等待吗？因为你会想说线程1已经拿到锁了没执行完，线程2怎么就可以开始执行表达式4了呢？")]),t._v(" "),a("ul",[a("li",[t._v("其实上面已经提到过了，在调用wait时，会先解锁，然后再上锁。当在执行表达式1时，还未调用wait前，本来线程2还在锁外等待，当调用wait时会解锁（此时线程1的时间片就会交出去了，这时线程2会立马入锁），然后线程1再上锁（只能锁外等待了，锁被线程2拿走了），后面立马执行表达式4、表达式5，表达式6，此时线程2解了锁，线程1可以接着执行表达式2了。")])])])])]),t._v(" "),a("li",[a("p",[t._v("如果线程2先创建，那么线程2直接执行到结束，线程1会一直等待。")])])])])])]),t._v(" "),a("li",[a("p",[t._v("当线程1中的锁有信号量在等待时，线程2创建后，可以直接入这个锁，因为线程2去上锁时，线程1中的wait会解锁再上锁，所以线程2可以直接进入。")])])]),t._v(" "),a("h2",{attrs:{id:"线程上下文切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程上下文切换"}},[t._v("#")]),t._v(" 线程上下文切换")]),t._v(" "),a("h3",{attrs:{id:"什么是线程的上下文切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程的上下文切换"}},[t._v("#")]),t._v(" 什么是线程的上下文切换？")]),t._v(" "),a("ul",[a("li",[t._v("CPU通过分配时间片来执行任务，当一个任务的时间片用完，就会切换到另一个任务。在切换之前会保存上一个任务的状态，当下次再切换到该任务，就会加载这个状态。")])]),t._v(" "),a("h3",{attrs:{id:"切入和切出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#切入和切出"}},[t._v("#")]),t._v(" 切入和切出")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("切出")]),t._v(" "),a("ul",[a("li",[t._v("一个线程被剥夺处理器的使用权而被暂停运行")])])]),t._v(" "),a("li",[a("p",[t._v("切入")]),t._v(" "),a("ul",[a("li",[t._v("一个线程被系统选中占用处理器开始或继续运行")])])])]),t._v(" "),a("h3",{attrs:{id:"上下文切换的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文切换的方法"}},[t._v("#")]),t._v(" 上下文切换的方法")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("自发性切换")]),t._v(" "),a("ul",[a("li",[t._v("Thread.sleep()")]),t._v(" "),a("li",[t._v("Object.wait()")]),t._v(" "),a("li",[t._v("Thread.yeild()")]),t._v(" "),a("li",[t._v("Thread.join()")]),t._v(" "),a("li",[t._v("LockSupport.park()")])])]),t._v(" "),a("li",[a("p",[t._v("非自发性切换")]),t._v(" "),a("ul",[a("li",[t._v("切出线程的时间片用完了")]),t._v(" "),a("li",[t._v("有一个比切出线程优先级更高的线程需要被运行")]),t._v(" "),a("li",[t._v("虚拟机的垃圾回收动作")])])])]),t._v(" "),a("h3",{attrs:{id:"上下文切换的开销"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文切换的开销"}},[t._v("#")]),t._v(" 上下文切换的开销")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("直接开销")]),t._v(" "),a("ul",[a("li",[t._v("操作系统保存恢复上下文所需的开销")]),t._v(" "),a("li",[t._v("线程调度器调度线程的开销")])])]),t._v(" "),a("li",[a("p",[t._v("间接开销")]),t._v(" "),a("ul",[a("li",[t._v("处理器高速缓存重新加载的开销")]),t._v(" "),a("li",[t._v("上下文切换可能导致整个一级高速缓存中的内容被冲刷，即被写入到下一级高速缓存或主存")])])])]),t._v(" "),a("p",[a("em",[t._v("XMind - Trial Version")])])])}),[],!1,null,null,null);_.default=v.exports}}]);