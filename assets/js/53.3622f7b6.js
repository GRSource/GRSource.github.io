(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{596:function(a,t,s){"use strict";s.r(t);var e=s(65),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"objective-c"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#objective-c"}},[a._v("#")]),a._v(" Objective-C")]),a._v(" "),s("h2",{attrs:{id:"分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[a._v("#")]),a._v(" 分类")]),a._v(" "),s("h3",{attrs:{id:"声明私有方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#声明私有方法"}},[a._v("#")]),a._v(" 声明私有方法")]),a._v(" "),s("ul",[s("li",[a._v("将分类放在.m文件当中")])]),a._v(" "),s("h3",{attrs:{id:"分解体积庞大的类文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分解体积庞大的类文件"}},[a._v("#")]),a._v(" 分解体积庞大的类文件")]),a._v(" "),s("ul",[s("li",[a._v("把同一功能的方法放到一个分类当中")])]),a._v(" "),s("h3",{attrs:{id:"把framework的私有方法公开化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#把framework的私有方法公开化"}},[a._v("#")]),a._v(" 把Framework的私有方法公开化")]),a._v(" "),s("h3",{attrs:{id:"运行时决议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#运行时决议"}},[a._v("#")]),a._v(" 运行时决议")]),a._v(" "),s("ul",[s("li",[a._v("在runtime时期将分类的方法添加到原类当中")])]),a._v(" "),s("h3",{attrs:{id:"为系统类添加分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为系统类添加分类"}},[a._v("#")]),a._v(" 为系统类添加分类")]),a._v(" "),s("h3",{attrs:{id:"分类可以添加哪些内容"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分类可以添加哪些内容"}},[a._v("#")]),a._v(" 分类可以添加哪些内容？")]),a._v(" "),s("ul",[s("li",[a._v("实例方法")]),a._v(" "),s("li",[a._v("类方法")]),a._v(" "),s("li",[a._v("协议")]),a._v(" "),s("li",[a._v("属性(只是添加了get和set方法，并没有添加实例变量)，可以通过关联对象添加实例")])]),a._v(" "),s("h2",{attrs:{id:"扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#扩展"}},[a._v("#")]),a._v(" 扩展")]),a._v(" "),s("h2",{attrs:{id:"消息传递"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息传递"}},[a._v("#")]),a._v(" 消息传递")]),a._v(" "),s("h3",{attrs:{id:"首先查找类对象的缓存-如果命中的话-通过函数指针调用它的实现-如果没有命中-就查找类对象的方法列表-查找成功就调用实现-如果不成功-就通过它的superclass逐级查找父类-一直到根类对象-如果在父类中命中-就调用相应的实现-不成功进入消息转发流程-然后结束"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首先查找类对象的缓存-如果命中的话-通过函数指针调用它的实现-如果没有命中-就查找类对象的方法列表-查找成功就调用实现-如果不成功-就通过它的superclass逐级查找父类-一直到根类对象-如果在父类中命中-就调用相应的实现-不成功进入消息转发流程-然后结束"}},[a._v("#")]),a._v(" 首先查找类对象的缓存，如果命中的话，通过函数指针调用它的实现，如果没有命中，就查找类对象的方法列表，查找成功就调用实现，如果不成功，就通过它的superClass逐级查找父类，一直到根类对象，如果在父类中命中，就调用相应的实现，不成功进入消息转发流程，然后结束")]),a._v(" "),s("h2",{attrs:{id:"消息转发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息转发"}},[a._v("#")]),a._v(" 消息转发")]),a._v(" "),s("h3",{attrs:{id:"resolveinstancemethod"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resolveinstancemethod"}},[a._v("#")]),a._v(" +resolveInstanceMethod:")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("YES")]),a._v(" "),s("ul",[s("li",[a._v("消息已处理")])])]),a._v(" "),s("li",[s("p",[a._v("NO")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("-forwardingTargetForSelector:")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("nil")]),a._v(" "),s("ul",[s("li",[a._v("-methodSignatureForSelector")])])]),a._v(" "),s("li",[s("p",[a._v("转发目标")])])])])])])]),a._v(" "),s("h2",{attrs:{id:"定时器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定时器"}},[a._v("#")]),a._v(" 定时器")]),a._v(" "),s("h3",{attrs:{id:"nstimer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nstimer"}},[a._v("#")]),a._v(" NSTimer")]),a._v(" "),s("h3",{attrs:{id:"cadisplaylink"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cadisplaylink"}},[a._v("#")]),a._v(" CADisplayLink")]),a._v(" "),s("ul",[s("li",[a._v("根据屏幕刷新频率定时操作")]),a._v(" "),s("li",[a._v("使用场合专一，适合做UI的不停重绘，比如自定义动画引擎，或者视频播放的渲染")])]),a._v(" "),s("h2",{attrs:{id:"cc-编译器生成汇编文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cc-编译器生成汇编文件"}},[a._v("#")]),a._v(" CC：编译器生成汇编文件")]),a._v(" "),s("h3",{attrs:{id:"as-将汇编文件生成二进制文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#as-将汇编文件生成二进制文件"}},[a._v("#")]),a._v(" AS：将汇编文件生成二进制文件")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("AR:打包器，为一个库删除或者增加模板代码模块")]),a._v(" "),s("ul",[s("li",[a._v("LD：链接器，分配地址空间，将多个目标文件链接成一个库或者可执行文件")])])])]),a._v(" "),s("h2",{attrs:{id:"sizeof"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sizeof"}},[a._v("#")]),a._v(" sizeof")]),a._v(" "),s("p",[a._v("编译时已经决定大小，如果目标是指针，表示指针占用内存的大小，通常64位机器为8字节，如果目标是值类型，则通常就是分配的内存大小。比如int *pointer_a;  sizeof(pointer_a)是8字节，sizeof(*pointer_a)是4字节")]),a._v(" "),s("h2",{attrs:{id:"malloc-size"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#malloc-size"}},[a._v("#")]),a._v(" malloc_size")]),a._v(" "),s("p",[a._v("系统实际分配的内存大小，为16的倍数，可根据class_getInstanceSize计算得到。例如当class_getInstanceSize为40时，为达到16的倍数，则malloc_size实际分配的大小为48.")]),a._v(" "),s("h2",{attrs:{id:"class-getinstancesize"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class-getinstancesize"}},[a._v("#")]),a._v(" class_getInstanceSize")]),a._v(" "),s("p",[a._v("获取当前对象自己和成员变量所占内存大小，8字节对齐，即8的倍数。例如：Test类，其中有三个int型变量，那么class_getInstanceSize大小计算为8+4+4+4=20，按照8字节对齐原则，所以class_getInstanceSize为24.")]),a._v(" "),s("h2",{attrs:{id:"llvm编译流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#llvm编译流程"}},[a._v("#")]),a._v(" LLVM编译流程")]),a._v(" "),s("p",[a._v("clang -ccc-print-phases main.m可以查看流程")]),a._v(" "),s("h3",{attrs:{id:"输入文件-找到源文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#输入文件-找到源文件"}},[a._v("#")]),a._v(" 输入文件，找到源文件")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("预处理阶段：这个过程处理包括宏的替换，头文件的导入")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("编译阶段：进行词法分析、语法分析、检测语法是否正确，最终生成IR中间代码")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("后端：这里LLVM会通过一个一个的pass去优化，每个pass做一些事情，最终生成汇编代码")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("汇编代码生成目标文件")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("链接：链接需要的动态库和静态库，生成可执行文件")]),a._v(" "),s("ul",[s("li",[a._v("绑定：通过不同的架构，生成对应的可执行文件")])])])])])])])])])])])]),a._v(" "),s("p",[s("em",[a._v("XMind - Trial Version")])])])}),[],!1,null,null,null);t.default=r.exports}}]);