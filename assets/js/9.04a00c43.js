(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{421:function(o,c,l){o.exports=l.p+"assets/img/Block例子.8e86a37a.png"},422:function(o,c,l){o.exports=l.p+"assets/img/__block.0d7b9fd9.png"},423:function(o,c,l){o.exports=l.p+"assets/img/Block内存.28d95b85.png"},424:function(o,c,l){o.exports=l.p+"assets/img/Block_Copy.92b14c02.png"},425:function(o,c,l){o.exports=l.p+"assets/img/栈Block销毁.c03f8e51.png"},426:function(o,c,l){o.exports=l.p+"assets/img/Block的Copy.f725d609.png"},427:function(o,c,l){o.exports=l.p+"assets/img/__block变量的Copy.26a60dfd.png"},551:function(o,c,l){"use strict";l.r(c);var _=l(65),t=Object(_.a)({},(function(){var o=this,c=o.$createElement,_=o._self._c||c;return _("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[_("h1",{attrs:{id:"block"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block"}},[o._v("#")]),o._v(" Block")]),o._v(" "),_("h2",{attrs:{id:"手写block"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#手写block"}},[o._v("#")]),o._v(" 手写Block")]),o._v(" "),_("p",[o._v("typedef void(^BlockA)(NSData *);"),_("br"),o._v("\ntypedef void(^BlockB)(BlockA, NSString *);"),_("br"),o._v("\ntypedef void(^BlockC)(void(^)(NSData *), NSString *);\ntypedef NSString *(^BlockC)(void(^)(NSData *), NSString *);\n@property (nonatomic, copy) void(^blockA)(NSData *);"),_("br"),o._v("\n@property (nonatomic, copy) void(^blockB)(void(^)(NSData *), NSString *);"),_("br"),o._v(" "),_("code",[o._v("- (void)func:(void(^)(NSData *))blockA;")]),_("br"),o._v(" "),_("code",[o._v("- (void)func:(void(^)(void(^)(NSData *), NSString *))blockB;")]),_("br"),o._v(" "),_("code",[o._v("- (void)func:(BlockA) block;")]),_("br"),o._v(" "),_("code",[o._v("- (void)func:(BlockB) block;")]),_("br"),o._v("\nvoid(^BlockA)(NSData *) = ^void(NSData *data) {")]),o._v(" "),_("p",[o._v("};"),_("br"),o._v("\nvoid(^BlockB)(void(^)(NSData *), NSString *) = ^void(void(^BlockA)(NSData *data), NSString *str) {")]),o._v(" "),_("p",[o._v("};")]),o._v(" "),_("h2",{attrs:{id:"block本质"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block本质"}},[o._v("#")]),o._v(" Block本质")]),o._v(" "),_("p",[o._v("什么是Block？"),_("br"),o._v("\nBlock是将函数及其执行上下文封装起来的对象。"),_("br"),o._v("\n什么是Block调用？"),_("br"),o._v("\nBlock调用即是函数的调用。")]),o._v(" "),_("h2",{attrs:{id:"block截获变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block截获变量"}},[o._v("#")]),o._v(" Block截获变量")]),o._v(" "),_("p",[_("img",{attrs:{src:l(421),alt:"Block例子"}}),o._v("\n结果为12"),_("br"),o._v("\nmultiplier加上static之后结果为8"),_("br"),o._v("\nmultiplier加上__block之后结果为8"),_("br"),o._v("\nBlock截获的变量分类：")]),o._v(" "),_("ul",[_("li",[o._v("局部变量，又分为基本数据类型和对象类型")]),o._v(" "),_("li",[o._v("静态局部变量")]),o._v(" "),_("li",[o._v("全局变量")]),o._v(" "),_("li",[o._v("静态全局变量")])]),o._v(" "),_("p",[o._v("1.对于基本类型的局部变量截获其值。"),_("br"),o._v("\n2.对于对象类型的局部变量连同所有权修饰符一起截获。  (weak/strong)"),_("br"),o._v("\n3.以指针形式截获静态局部变量。"),_("br"),o._v("\n4.不截获全局变量和静态全局变量。")]),o._v(" "),_("h2",{attrs:{id:"block和-weak"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block和-weak"}},[o._v("#")]),o._v(" __block和__weak")]),o._v(" "),_("p",[o._v("一般情况下，对被截获变量进行赋值操作需要添加__block修饰符。"),_("br"),o._v("\n对于基本数据类型和对象类型的局部变量需要使用__block进行赋值，对于静态局部变量、全局变量、静态全局变量不需要使用__block修饰符。"),_("br"),o._v("\n__block修饰的变量变成了对象。"),_("br"),o._v(" "),_("img",{attrs:{src:l(422),alt:"__block"}}),o._v("\n__forwarding指针是用来干什么的？")]),o._v(" "),_("h2",{attrs:{id:"block内存管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block内存管理"}},[o._v("#")]),o._v(" Block内存管理")]),o._v(" "),_("p",[o._v("Block类型有三种：")]),o._v(" "),_("ul",[_("li",[o._v("_NSConcreteGlobalBlock，全局block")]),o._v(" "),_("li",[o._v("_NSConcreteStackBlock，栈block")]),o._v(" "),_("li",[o._v("_NSConcreteMallocBlock，堆block")])]),o._v(" "),_("p",[_("img",{attrs:{src:l(423),alt:"Block内存"}})]),o._v(" "),_("p",[o._v("Block的Copy操作："),_("br"),o._v(" "),_("img",{attrs:{src:l(424),alt:"Block_Copy"}}),o._v("\n栈block拷贝之后到了堆，数据区的block拷贝之后什么也不做，堆block拷贝之后增加引用计数。")]),o._v(" "),_("p",[o._v("栈上Block的销毁："),_("br"),o._v(" "),_("img",{attrs:{src:l(425),alt:"栈Block销毁"}}),o._v("\n栈上的__block变量和Block在函数作用域结束后都会进行销毁。")]),o._v(" "),_("p",[o._v("栈上Block的Copy："),_("br"),o._v(" "),_("img",{attrs:{src:l(426),alt:"Block的Copy"}}),o._v("\n栈上的Block进行Copy操作，在MRC上会内存泄漏")]),o._v(" "),_("p",[o._v("栈上__block变量的Copy：\n"),_("img",{attrs:{src:l(427),alt:"__block变量的Copy"}})]),o._v(" "),_("p",[o._v("Block为什么使用copy而不使用strong？"),_("br"),o._v("\nblock变量是在栈上创建的，为了在作用域之外使用block，需要将它拷贝到堆区，而我们对block使用strong也是可以的，因为block的retain默认是用copy实现的，为了保持属性的使用和声明一致，最好使用copy")]),o._v(" "),_("p",[o._v("__forwarding存在的意义"),_("br"),o._v("\n不论在任何内存位置，我们都可以顺利的通过__forwarding访问同一个__block变量")]),o._v(" "),_("h2",{attrs:{id:"block循环引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block循环引用"}},[o._v("#")]),o._v(" Block循环引用")]),o._v(" "),_("p",[o._v("__block在MRC下，不会产生循环引用。在ARC下，会产生循环引用，引起内存泄漏。")]),o._v(" "),_("h2",{attrs:{id:"block里面self、weakself、strongself使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block里面self、weakself、strongself使用"}},[o._v("#")]),o._v(" Block里面self、weakSelf、strongSelf使用")]),o._v(" "),_("p",[o._v("1.不成环，并且想让block代码什么情况下都执行：两种方式：A.全部使用self就行；B.外面定义weak，block里面用strong，也行，多次一举。")]),o._v(" "),_("p",[o._v("2.不成环，并且想让block代码在当前VC释放的情况下不执行：两种方式：A.外面定义weak，里面使用weak，然后注意nil可能会crash的地方（加判断）；B.外面定义weak，block里面使用strong（或者直接使用self），自己加if判断，否是在当前页面，不在当前页面不执行。")]),o._v(" "),_("p",[o._v("3.成环，想让block代码无论如何都执行：必用weak。block里面用strong。")]),o._v(" "),_("p",[o._v("4.成环，想让block代码在当前VC释放的情况下不执行：两种方式：A.必用weak，block里面用strong，则自己加if判断不在当前页面就不执行；B.block里面使用weak，注意nil可能导致crash的地方。")]),o._v(" "),_("h2",{attrs:{id:"代理和block的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#代理和block的区别"}},[o._v("#")]),o._v(" 代理和block的区别")]),o._v(" "),_("p",[o._v("在应用场景上进行比较，block和代理本质上是不同的，因为block其实是一个对象，代理是一种设计模式。")]),o._v(" "),_("p",[o._v("block优势："),_("br"),o._v("\nblock代码可读性更好。因为block只要实现就可以了，而代理需要遵守协议并且实现协议里的方法，而两者还不在一个地方。代理使用起来也更麻烦，因为要声明协议、声明代理属性、遵守协议、实现协议里的方法。block不需要声明，也不需要遵守，只需要声明属性和实现就可以了。")]),o._v(" "),_("p",[o._v("block是一种轻量级的回调，可以直接访问上下文，由于block的代码时内联的，运行效率更高。block就是一个对象，实现了匿名函数的功能。所以我们可以把block当做一个成员变量、属性、参数使用，使用起来非常灵活。像AFNetworking请求数据和GCD实现多线程，都使用了block回调。")]),o._v(" "),_("p",[o._v("block劣势："),_("br"),o._v("\nblock运行成本高。block出栈需要将使用的数据从栈内存拷贝到堆内存，当然对象的话就是引用计数加1，使用完或者block置nil后才销毁。delegate只是保存了一个对象指针，直接回调，没有额外消耗，就像C的函数指针，只多了一个查表操作。"),_("br"),o._v("\nblock容易造成循环引用而不以察觉。因为为了block不被系统回收，所以我们都用copy关键字修饰，实行强引用。block对补货的变量也都是强引用，所以就会造成循环引用。")]),o._v(" "),_("p",[o._v("如何使用：")]),o._v(" "),_("ul",[_("li",[o._v("优先使用block")]),o._v(" "),_("li",[o._v("如果回调的状态很多，多余三个使用代理")]),o._v(" "),_("li",[o._v("如果回调的很频繁，次数很多，像UITableView，每次初始化、滑动、点击都会回调，使用代理")])])])}),[],!1,null,null,null);c.default=t.exports}}]);